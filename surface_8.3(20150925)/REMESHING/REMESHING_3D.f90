    MODULE REMESHING_3D
    USE SURFACE_MODULE_3D
    USE SURFACES_3D
    USE OPERATORS_3D
    USE PROPA_RECONST_REINITIAL_3D
    USE HIGHORDER_3D
    
    IMPLICIT NONE

    CONTAINS
    
    
    SUBROUTINE MESH_QUALITY_TRIANGLE_ONE_ORIENTATION(POINT, FACE, FACE_INDEX, CONNECTION_NUM, CONNECTION, INITIAL_AREA, DIVIDED_BOUNDARY, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
        IMPLICIT NONE

        REAL(8) :: POINT(:,:)
        INTEGER :: FACE(:,:)
        INTEGER :: FACE_INDEX
        INTEGER :: CONNECTION_NUM(:)
        INTEGER :: CONNECTION(:,:)
        REAL(8) :: INITIAL_AREA(:)
        INTEGER :: DIVIDED_BOUNDARY(:,:)
        REAL(8) :: F_SHAPE, F_SIZE, F_SIZE_SHAPE
        
        INTEGER :: K, I1, NUM
        REAL(8) :: N(3), N1(3)
        
        CALL TRIANGLE_NORMAL(POINT(:,FACE(1,FACE_INDEX)), POINT(:,FACE(2,FACE_INDEX)), POINT(:,FACE(3,FACE_INDEX)), N)
        NUM = 0
        DO K=1,3
            IF(DIVIDED_BOUNDARY(K,FACE_INDEX)==0) THEN
                CALL FACE_NEIGHBOR_FACE(FACE, CONNECTION_NUM, CONNECTION,FACE_INDEX,K, I1)
                CALL TRIANGLE_NORMAL(POINT(:,FACE(1,I1)), POINT(:,FACE(2,I1)), POINT(:,FACE(3,I1)), N1)
                IF(DOT_PRODUCT(N,N1)>0) THEN
                   NUM = NUM + 1
                END IF
            END IF
        END DO
        
        IF(NUM==0) THEN
            F_SIZE_SHAPE = 0.
            F_SIZE = 0.
            F_SHAPE = 0.
        ELSE
            CALL MESH_QUALITY_TRIANGLE_ONE(POINT(:,FACE(1,FACE_INDEX)), POINT(:,FACE(2,FACE_INDEX)), POINT(:,FACE(3,FACE_INDEX)), INITIAL_AREA(FACE_INDEX), F_SIZE_SHAPE, F_SIZE, F_SHAPE)
        END IF
        
    END SUBROUTINE MESH_QUALITY_TRIANGLE_ONE_ORIENTATION
    
    
    
    SUBROUTINE REMOVE_LARGE_REGION(TYP, REGION_NUM)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: I, J
    INTEGER :: ITER, REGION_NUM
    LOGICAL :: B
    INTEGER :: NEWPOINT_NUM, NEWFACE_NUM
    REAL(8), ALLOCATABLE :: NEWPOINT(:,:) 
    INTEGER, ALLOCATABLE :: NEWFACE(:,:)
    INTEGER, ALLOCATABLE :: POINT_INDEX(:)
    INTEGER, ALLOCATABLE :: FACE_INDEX(:)
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    ALLOCATE(NEWPOINT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(NEWFACE(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(POINT_INDEX(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_INDEX(SURFACE_CURRENT%SURFACE_FACES_NUM))

    POINT_INDEX(:) = 0
    FACE_INDEX(:) = 0

    NEWPOINT_NUM = 0
    B = .TRUE.
    ITER = 1


    DO WHILE(B)
        B = .FALSE.
        DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SURFACE_CURRENT%FACE_LOCATION(SURFACE_CURRENT%POINT_FACE_CONNECTION(1,I))==ITER) THEN
                B = .TRUE.
                IF(ITER .NE. REGION_NUM) THEN
                    NEWPOINT_NUM = NEWPOINT_NUM+1
                    NEWPOINT(:,NEWPOINT_NUM) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
                    POINT_INDEX(I) = NEWPOINT_NUM
                END IF
            END IF
        END DO
        ITER = ITER + 1
    END DO

    NEWFACE_NUM = 0
    B = .TRUE.
    ITER = 1

    DO WHILE(B)
        B = .FALSE.
        DO J = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
            IF(SURFACE_CURRENT%FACE_LOCATION(J)==ITER) THEN
                B = .TRUE.
                IF(ITER .NE. REGION_NUM) THEN
                    NEWFACE_NUM = NEWFACE_NUM+1
                    NEWFACE(:,NEWFACE_NUM) = SURFACE_CURRENT%SURFACE_FACES(:,J)
                    FACE_INDEX(J) = NEWFACE_NUM
                END IF
            END IF
        END DO
        ITER = ITER + 1
    END DO

    !write(*,*) 'NEWPOINT NUM', NEWPOINT_NUM
    !write(*,*) 'NEWFACE NUM', NEWFACE_NUM

    CALL NEW_POINTFACE_INDEX(TYP, NEWPOINT_NUM, NEWPOINT, NEWFACE_NUM, NEWFACE, POINT_INDEX, FACE_INDEX)

    !IF(TYP==1) THEN
    !    CALL CLASSIFY_PATCH(1)
    !END IF

    DEALLOCATE(NEWPOINT)
    DEALLOCATE(NEWFACE)
    DEALLOCATE(POINT_INDEX)
    DEALLOCATE(FACE_INDEX)

    END SUBROUTINE REMOVE_LARGE_REGION


    SUBROUTINE ATTACH_FLUID_CASE()
    IMPLICIT NONE
    INTEGER :: I,J,K,L,I1, REL, BOUNDARY_NUM
    LOGICAL :: BB,B,C,D, FLAG
    REAL(8) :: R, V(3)
    LOGICAL, ALLOCATABLE :: FLUID_POINT_ON_CASE(:), FLUID_FACE_ON_CASE(:), BEFORE_FLUID_FACE_ON_CASE(:), TEMP_FLUID_FACE_ON_CASE(:)
    
    
    ALLOCATE(FLUID_POINT_ON_CASE(SURFACE_FLUID%SURFACE_POINTS_NUM))
    FLUID_POINT_ON_CASE(:) = .FALSE.
    
    DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
        
        B = .FALSE.
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            IF(SURFACE_FLUID%FACE_ONINTERFACE(SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)) == 1) THEN
                B = .TRUE.
            END IF
        END DO
        
        C = .TRUE.
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            IF(SURFACE_FLUID%FACE_ONINTERFACE(SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)) == 2) THEN
                C = .FALSE.
            END IF
        END DO
        
        IF(.NOT. C) THEN
            FLUID_POINT_ON_CASE(I) = .TRUE.
        ELSE IF(B .AND. C) THEN
            R = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))
            
            REL = SURFACE_FLUID%POINT_RELATEDFACE(2+1,I)
            IF(REL .NE. 0) THEN
                CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_FLUID%SURFACE_POINTS(:,I), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,REL)), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,REL)), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,REL)), R)
            END IF
            
            IF(R < SURFACE_FLUID%MESH_SIZE/3.) THEN
                V(:) = SURFACE_FLUID%SURFACE_POINTS(:,I)
                
                CALL PROJECTION_FACE_POINT_HIGHORDER(V, REL, SURFACE_CASE%SURFACE_POINTS_NUM, SURFACE_CASE%SURFACE_POINTS, SURFACE_CASE%SURFACE_FACES, SURFACE_CASE%POINT_FACE_CONNECTION_NUM, SURFACE_CASE%POINT_FACE_CONNECTION, SURFACE_CASE%POINT_TYPE)
                
                IF(SQRT(DOT_PRODUCT(V-SURFACE_FLUID%SURFACE_POINTS(:,I), V-SURFACE_FLUID%SURFACE_POINTS(:,I))) < SURFACE_FLUID%MESH_SIZE/200. .OR. DOT_PRODUCT(V-SURFACE_FLUID%SURFACE_POINTS(:,I),SURFACE_FLUID%POINT_FORCE(:,I)) < 0) THEN
                    SURFACE_FLUID%SURFACE_POINTS(:,I) = V(:)
                    FLUID_POINT_ON_CASE(I) = .TRUE.
                    WRITE(*,*) 'FLUID POINT ATTACHED TO CASE'
                END IF
            END IF
        END IF
        
    END DO
    
    ALLOCATE(FLUID_FACE_ON_CASE(SURFACE_FLUID%SURFACE_FACES_NUM), BEFORE_FLUID_FACE_ON_CASE(SURFACE_FLUID%SURFACE_FACES_NUM), TEMP_FLUID_FACE_ON_CASE(SURFACE_FLUID%SURFACE_FACES_NUM))
    FLUID_FACE_ON_CASE(:) = .FALSE.
    BB = .FALSE.
    
    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
        IF(SURFACE_FLUID%FACE_ONINTERFACE(I)==1) THEN
            IF(FLUID_POINT_ON_CASE(SURFACE_FLUID%SURFACE_FACES(1,I)) .AND. FLUID_POINT_ON_CASE(SURFACE_FLUID%SURFACE_FACES(2,I)) .AND. FLUID_POINT_ON_CASE(SURFACE_FLUID%SURFACE_FACES(3,I))) THEN
                FLUID_FACE_ON_CASE(I) = .TRUE.
                BB = .TRUE.
            END IF
        ELSE IF(SURFACE_FLUID%FACE_ONINTERFACE(I)==2) THEN
            FLUID_FACE_ON_CASE(I) = .TRUE.
        END IF
    END DO
    
    IF(BB) THEN
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
        IF(FLUID_FACE_ON_CASE(I) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I)==1) THEN
            BOUNDARY_NUM = 0
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION,I,K, I1)
                IF(.NOT. FLUID_FACE_ON_CASE(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                    BOUNDARY_NUM = BOUNDARY_NUM + 1
                END IF
            END DO
            IF(BOUNDARY_NUM >= 2) THEN
                B = .TRUE.
                FLUID_FACE_ON_CASE(I) = .FALSE.
            END IF
        END IF
    END DO
    
    END DO
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    BEFORE_FLUID_FACE_ON_CASE(:) = FLUID_FACE_ON_CASE(:)
    TEMP_FLUID_FACE_ON_CASE(:) = FLUID_FACE_ON_CASE(:)
    
    DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
        C = .FALSE.
        D = .FALSE.
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)
            IF(FLUID_FACE_ON_CASE(I1)) THEN
                C = .TRUE.
            ELSE IF(.NOT. FLUID_FACE_ON_CASE(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                D = .TRUE.
            END IF
        END DO
        
        IF(C .AND. D) THEN
        
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)
            IF(.NOT. FLUID_FACE_ON_CASE(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                TEMP_FLUID_FACE_ON_CASE(I1) = .TRUE.
            END IF
        END DO
        
        END IF
    END DO
    
!    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
!        IF(FLUID_FACE_ON_CASE(I)) THEN
!            DO K=1,3
!                CALL FACE_NEIGHBOR_FACE(SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION,I,K, I1)
!                IF(.NOT. FLUID_FACE_ON_CASE(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
!                    TEMP_FLUID_FACE_ON_CASE(I1) = .TRUE.
!                END IF
!            END DO
!        END IF
!    END DO
    
    FLUID_FACE_ON_CASE(:) = TEMP_FLUID_FACE_ON_CASE(:)
    
    DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
        C = .FALSE.
        D = .FALSE.
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)
            IF(FLUID_FACE_ON_CASE(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                C = .TRUE.
            ELSE IF(.NOT. FLUID_FACE_ON_CASE(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                D = .TRUE.
            END IF
        END DO
        
        IF(C .AND. D) THEN
        
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)
            IF(FLUID_FACE_ON_CASE(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                TEMP_FLUID_FACE_ON_CASE(I1) = .FALSE.
            END IF
        END DO
        
        END IF
    END DO
    
!    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
!        IF(FLUID_FACE_ON_CASE(I) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I)==1) THEN
!            DO K=1,3
!                CALL FACE_NEIGHBOR_FACE(SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION,I,K, I1)
!                IF(.NOT. FLUID_FACE_ON_CASE(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
!                    TEMP_FLUID_FACE_ON_CASE(I) = .FALSE.
!                END IF
!            END DO
!        END IF
!    END DO
    
    FLUID_FACE_ON_CASE(:) = TEMP_FLUID_FACE_ON_CASE(:)
    
    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
        IF(FLUID_FACE_ON_CASE(I) .NE. BEFORE_FLUID_FACE_ON_CASE(I)) THEN
            B = .TRUE.
            EXIT
        END IF
    END DO
    
    END DO
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
        IF(FLUID_FACE_ON_CASE(I) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I)==1) THEN
            BOUNDARY_NUM = 0
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION,I,K, I1)
                IF(.NOT. FLUID_FACE_ON_CASE(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                    BOUNDARY_NUM = BOUNDARY_NUM + 1
                END IF
            END DO
            IF(BOUNDARY_NUM >= 2) THEN
                B = .TRUE.
                FLUID_FACE_ON_CASE(I) = .FALSE.
            END IF
        END IF
    END DO
    
    END DO
    
    FLAG = .FALSE.
    
    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
        IF(FLUID_FACE_ON_CASE(I) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I)==1) THEN
            FLAG = .TRUE.
            SURFACE_FLUID%FACE_ONINTERFACE(I) = 2
            
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION,I,K, I1)
                DO L=1,3
                    IF(SURFACE_FLUID%SURFACE_FACES(L,I1)==SURFACE_FLUID%SURFACE_FACES(K,I)) THEN
                        EXIT
                    END IF
                END DO
                
                IF(SURFACE_FLUID%FACE_ONINTERFACE(I1)==2) THEN
                    SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_ARRAY(K,I) = 0
                    SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_ARRAY(MOD(L+3-2,3) + 1,I1) = 0
                ELSE
                    SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_ARRAY(K,I) = 1
                    SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_ARRAY(MOD(L+3-2,3) + 1,I1) = 1
                END IF
            END DO
            
            WRITE(*,*) 'FLUID FACE ATTACHED TO CASE'
        END IF
    END DO
    
    IF(FLAG) THEN
    
    CALL RESET_DIVIDED_REGION_BOUNDARY(SURFACE_FLUID%SURFACE_POINTS_NUM, SURFACE_FLUID%SURFACE_POINTS, SURFACE_FLUID%SURFACE_FACES_NUM, SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION, SURFACE_FLUID%POINT_TYPE, SURFACE_FLUID%FACE_DIVIDED_REGION_ARRAY, SURFACE_FLUID%FACE_DIVIDED_REGION_NUM, SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_ARRAY, SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_NUM)
    
    CALL FIND_POINT_TYPE_USING_BOUNDARY(0)
    
    !SURFACE_FLUID%POINT_TYPE(:) = SURFACE_FLUID%INITIAL_POINT_TYPE(:)
    
    !CALL FIND_POINT_TYPE_4(0)
    !CALL FIND_POINT_TYPE_56(0)
    
    END IF
    
    END IF
    
    DEALLOCATE(FLUID_POINT_ON_CASE)
    DEALLOCATE(FLUID_FACE_ON_CASE, BEFORE_FLUID_FACE_ON_CASE, TEMP_FLUID_FACE_ON_CASE)
    
    
    END SUBROUTINE ATTACH_FLUID_CASE

    SUBROUTINE ATTACH_FLUID_AXIS()
    IMPLICIT NONE
    INTEGER :: I,J,K,L,I1, BOUNDARY_NUM
    LOGICAL :: BB, B,C,D, FLAG
    REAL(8) :: V(3), T1, V1(3), T2, V2(3), R1, R2
    LOGICAL, ALLOCATABLE :: FLUID_POINT_ON_AXIS(:), FLUID_FACE_ON_AXIS(:), BEFORE_FLUID_FACE_ON_AXIS(:), TEMP_FLUID_FACE_ON_AXIS(:)
    
    
    ALLOCATE(FLUID_POINT_ON_AXIS(SURFACE_FLUID%SURFACE_POINTS_NUM))
    FLUID_POINT_ON_AXIS(:) = .FALSE.
    
    DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
        
        B = .FALSE.
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            IF(SURFACE_FLUID%FACE_ONINTERFACE(SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)) == 1) THEN
                B = .TRUE.
            END IF
        END DO
        
        C = .TRUE.
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            IF(SURFACE_FLUID%FACE_ONINTERFACE(SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)) == -1) THEN
                C = .FALSE.
            END IF
        END DO
        
        IF(.NOT. C) THEN
            FLUID_POINT_ON_AXIS(I) = .TRUE.
        ELSE IF(B .AND. C) THEN
             V(:) = SURFACE_FLUID%SURFACE_POINTS(:,I)
             
             T1 = (DOT_PRODUCT(V, MODEL_AXIS_EQN(1:3,1)) + MODEL_AXIS_EQN(4,1))/DOT_PRODUCT(MODEL_AXIS_EQN(1:3,1), MODEL_AXIS_EQN(1:3,1))
             V1 = V - T1 * MODEL_AXIS_EQN(1:3,1)
             R1 = SQRT(DOT_PRODUCT(V1-V,V1-V))
             
             T2 = (DOT_PRODUCT(V, MODEL_AXIS_EQN(1:3,2)) + MODEL_AXIS_EQN(4,2))/DOT_PRODUCT(MODEL_AXIS_EQN(1:3,2), MODEL_AXIS_EQN(1:3,2))
             V2 = V - T1 * MODEL_AXIS_EQN(1:3,2)
             R2 = SQRT(DOT_PRODUCT(V2-V,V2-V))
             
            IF(R1 < SURFACE_FLUID%MESH_SIZE/3.) THEN
                IF(SQRT(DOT_PRODUCT(V1-V, V1-V)) < SURFACE_FLUID%MESH_SIZE/200. .OR. DOT_PRODUCT(V1-V,SURFACE_FLUID%POINT_FORCE(:,I)) < 0) THEN
                    SURFACE_FLUID%SURFACE_POINTS(:,I) = V1(:)
                    FLUID_POINT_ON_AXIS(I) = .TRUE.
                    WRITE(*,*) 'FLUID POINT ATTACHED TO AXIS'
                END IF
            END IF
             
            IF(R2 < SURFACE_FLUID%MESH_SIZE/3.) THEN
                IF(SQRT(DOT_PRODUCT(V2-V, V2-V)) < SURFACE_FLUID%MESH_SIZE/200. .OR. DOT_PRODUCT(V2-V,SURFACE_FLUID%POINT_FORCE(:,I)) < 0) THEN
                    SURFACE_FLUID%SURFACE_POINTS(:,I) = V2(:)
                    FLUID_POINT_ON_AXIS(I) = .TRUE.
                    WRITE(*,*) 'FLUID POINT ATTACHED TO AXIS'
                END IF
            END IF
        END IF
        
    END DO
    
    ALLOCATE(FLUID_FACE_ON_AXIS(SURFACE_FLUID%SURFACE_FACES_NUM), BEFORE_FLUID_FACE_ON_AXIS(SURFACE_FLUID%SURFACE_FACES_NUM), TEMP_FLUID_FACE_ON_AXIS(SURFACE_FLUID%SURFACE_FACES_NUM))
    FLUID_FACE_ON_AXIS(:) = .FALSE.
    
    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
        IF(SURFACE_FLUID%FACE_ONINTERFACE(I)==1) THEN
            IF(FLUID_POINT_ON_AXIS(SURFACE_FLUID%SURFACE_FACES(1,I)) .AND. FLUID_POINT_ON_AXIS(SURFACE_FLUID%SURFACE_FACES(2,I)) .AND. FLUID_POINT_ON_AXIS(SURFACE_FLUID%SURFACE_FACES(3,I))) THEN
                FLUID_FACE_ON_AXIS(I) = .TRUE.
                BB = .TRUE.
            END IF
        ELSE IF(SURFACE_FLUID%FACE_ONINTERFACE(I)==-1) THEN
            FLUID_FACE_ON_AXIS(I) = .TRUE.
        END IF
    END DO
    
    IF(BB) THEN
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
        IF(FLUID_FACE_ON_AXIS(I) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I)==1) THEN
            BOUNDARY_NUM = 0
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION,I,K, I1)
                IF(.NOT. FLUID_FACE_ON_AXIS(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                    BOUNDARY_NUM = BOUNDARY_NUM + 1
                END IF
            END DO
            IF(BOUNDARY_NUM >= 2) THEN
                B = .TRUE.
                FLUID_FACE_ON_AXIS(I) = .FALSE.
            END IF
        END IF
    END DO
    
    END DO
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    BEFORE_FLUID_FACE_ON_AXIS(:) = FLUID_FACE_ON_AXIS(:)
    TEMP_FLUID_FACE_ON_AXIS(:) = FLUID_FACE_ON_AXIS(:)
    
    DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
        C = .FALSE.
        D = .FALSE.
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)
            IF(FLUID_FACE_ON_AXIS(I1)) THEN
                C = .TRUE.
            ELSE IF(.NOT. FLUID_FACE_ON_AXIS(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                D = .TRUE.
            END IF
        END DO
        
        IF(C .AND. D) THEN
        
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)
            IF(.NOT. FLUID_FACE_ON_AXIS(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                TEMP_FLUID_FACE_ON_AXIS(I1) = .TRUE.
            END IF
        END DO
        
        END IF
    END DO
    
!    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
!        IF(FLUID_FACE_ON_AXIS(I)) THEN
!            DO K=1,3
!                CALL FACE_NEIGHBOR_FACE(SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION,I,K, I1)
!                IF(.NOT. FLUID_FACE_ON_AXIS(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
!                    TEMP_FLUID_FACE_ON_AXIS(I1) = .TRUE.
!                END IF
!            END DO
!        END IF
!    END DO
    
    FLUID_FACE_ON_AXIS(:) = TEMP_FLUID_FACE_ON_AXIS(:)
    
    DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
        C = .FALSE.
        D = .FALSE.
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)
            IF(FLUID_FACE_ON_AXIS(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                C = .TRUE.
            ELSE IF(.NOT. FLUID_FACE_ON_AXIS(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                D = .TRUE.
            END IF
        END DO
        
        IF(C .AND. D) THEN
        
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)
            IF(FLUID_FACE_ON_AXIS(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                TEMP_FLUID_FACE_ON_AXIS(I1) = .FALSE.
            END IF
        END DO
        
        END IF
    END DO
    
!    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
!        IF(FLUID_FACE_ON_AXIS(I) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I)==1) THEN
!            DO K=1,3
!                CALL FACE_NEIGHBOR_FACE(SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION,I,K, I1)
!                IF(.NOT. FLUID_FACE_ON_AXIS(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
!                    TEMP_FLUID_FACE_ON_AXIS(I) = .FALSE.
!                END IF
!            END DO
!        END IF
!    END DO
    
    FLUID_FACE_ON_AXIS(:) = TEMP_FLUID_FACE_ON_AXIS(:)
    
    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
        IF(FLUID_FACE_ON_AXIS(I) .NE. BEFORE_FLUID_FACE_ON_AXIS(I)) THEN
            B = .TRUE.
            EXIT
        END IF
    END DO
    
    END DO
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
        IF(FLUID_FACE_ON_AXIS(I) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I)==1) THEN
            BOUNDARY_NUM = 0
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION,I,K, I1)
                IF(.NOT. FLUID_FACE_ON_AXIS(I1) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I1)==1) THEN
                    BOUNDARY_NUM = BOUNDARY_NUM + 1
                END IF
            END DO
            IF(BOUNDARY_NUM >= 2) THEN
                B = .TRUE.
                FLUID_FACE_ON_AXIS(I) = .FALSE.
            END IF
        END IF
    END DO
    
    END DO
    
    FLAG = .FALSE.
    
    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
        IF(FLUID_FACE_ON_AXIS(I) .AND. SURFACE_FLUID%FACE_ONINTERFACE(I)==1) THEN
            FLAG = .TRUE.
            SURFACE_FLUID%FACE_ONINTERFACE(I) = -1
            
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION,I,K, I1)
                DO L=1,3
                    IF(SURFACE_FLUID%SURFACE_FACES(L,I1)==SURFACE_FLUID%SURFACE_FACES(K,I)) THEN
                        EXIT
                    END IF
                END DO
                
                IF(SURFACE_FLUID%FACE_ONINTERFACE(I1)==-1) THEN
                    SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_ARRAY(K,I) = 0
                    SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_ARRAY(MOD(L+3-2,3) + 1,I1) = 0
                ELSE
                    SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_ARRAY(K,I) = 1
                    SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_ARRAY(MOD(L+3-2,3) + 1,I1) = 1
                END IF
            END DO
            
            WRITE(*,*) 'FLUID FACE ATTACHED TO AXIS'
        END IF
    END DO
    
    IF(FLAG) THEN
    
    CALL RESET_DIVIDED_REGION_BOUNDARY(SURFACE_FLUID%SURFACE_POINTS_NUM, SURFACE_FLUID%SURFACE_POINTS, SURFACE_FLUID%SURFACE_FACES_NUM, SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION, SURFACE_FLUID%POINT_TYPE, SURFACE_FLUID%FACE_DIVIDED_REGION_ARRAY, SURFACE_FLUID%FACE_DIVIDED_REGION_NUM, SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_ARRAY, SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_NUM)
    
    CALL FIND_POINT_TYPE_USING_BOUNDARY(0)
    
    !SURFACE_FLUID%POINT_TYPE(:) = SURFACE_FLUID%INITIAL_POINT_TYPE(:)
    
    !CALL FIND_POINT_TYPE_4(0)
    !CALL FIND_POINT_TYPE_56(0)
    
    END IF
    
    END IF
    
    DEALLOCATE(FLUID_POINT_ON_AXIS)
    DEALLOCATE(FLUID_FACE_ON_AXIS, BEFORE_FLUID_FACE_ON_AXIS, TEMP_FLUID_FACE_ON_AXIS)
    
    
    END SUBROUTINE ATTACH_FLUID_AXIS


    SUBROUTINE ZIPPER_PROPEL_IMPACT_ZONE(FLAG)
    IMPLICIT NONE
    INTEGER :: I, J, K, IPZ, DIR, PAIR_NUM
    !INTEGER :: I1, I2, J1, J2, IPZ1, IPZ2, IND
    REAL(8) :: R !, R1, R2, R3
    INTEGER, ALLOCATABLE :: MATCH_INDEX(:,:)!, PATCH_PARENT(:), PATCH_BEFORE_INDEX(:)
    LOGICAL :: B, FLAG, TEMPFLAG, THINFLAG

    FLAG = .FALSE.

    TEMPFLAG = .FALSE.
    THINFLAG = .FALSE.
    B = .TRUE.
    DIR = 0
    ALLOCATE(MATCH_INDEX(SURFACE_PROPEL%SURFACE_FACES_NUM,2))
    !ALLOCATE(PATCH_PARENT(SURFACE_PROPEL%SURFACE_FACES_NUM))

    !DO J=1,SURFACE_PROPEL%SURFACE_PATCHES_NUM
    !    DO I=1,SURFACE_PROPEL%SURFACE_FACES_NUM
    !        IF(SURFACE_PROPEL%FACE_LOCATION(I) .EQ. J) THEN
    !            I1 = SURFACE_PROPEL%SURFACE_EDGES(1,I)
    !            I2 = SURFACE_PROPEL%SURFACE_EDGES(2,I)
    !            J1 = SURFACE_PROPEL%POINT_EDGE_CONNECTION(1,I1)
    !            J2 = SURFACE_PROPEL%POINT_EDGE_CONNECTION(2,I2)
    !            IPZ = SURFACE_PROPEL%FACE_IMPACT_ZONE(1+1, I)
    !            IPZ1 = SURFACE_PROPEL%FACE_IMPACT_ZONE(1+1, J1)
    !            IPZ2 = SURFACE_PROPEL%FACE_IMPACT_ZONE(1+1, J2)
    !            		   
    !            IF(IPZ.NE.0 .AND. IPZ1 .NE. 0 .AND. IPZ2 .NE. 0) THEN
    !                CALL DISTANCE_FACE_FACE_TYPE(I,1,IPZ,1,DIR,  R1,B)
    !                CALL DISTANCE_FACE_FACE_TYPE(J1,1,IPZ1,1,DIR,  R2,B)
    !                CALL DISTANCE_FACE_FACE_TYPE(J2,1,IPZ2,1,DIR,  R3,B)
    !                IF(MAX(ABS(R1),MAX(ABS(R2),ABS(R3))) .LT. SURFACE_FLUID%MESH_SIZE * 10.) THEN
    !                    IND = I
    !                    THINFLAG = .TRUE.
    !                    SURFACE_PROPEL%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_PROPEL%FACE_LOCATION(IND)) = 11
    !                    EXIT
    !                END IF
    !            END IF
    !        END IF
    !    END DO
    !END DO

    DO I=1,SURFACE_PROPEL%SURFACE_FACES_NUM
        IPZ = SURFACE_PROPEL%FACE_IMPACT_ZONE(1+1, I)
        IF(IPZ.NE.0) THEN
            CALL DISTANCE_FACE_FACE_TYPE(I,1,IPZ,1,DIR,  R,B)
            IF(R < SURFACE_FLUID%MESH_SIZE * THIN_REGION_ATTACHMENT) THEN
                TEMPFLAG = .TRUE.
                EXIT
            END IF
        END IF
    END DO

    PAIR_NUM = 0
    IF(TEMPFLAG) THEN
        DO I=1,SURFACE_PROPEL%SURFACE_FACES_NUM
            IPZ = SURFACE_PROPEL%FACE_IMPACT_ZONE(1+1, I)

            IF(IPZ.NE.0) THEN
                IF(SURFACE_PROPEL%FACE_IMPACT_ZONE(1+1,IPZ) .EQ. I) THEN
                    IF(PAIR_NUM .EQ. 0) THEN
                        PAIR_NUM = PAIR_NUM + 1
                        MATCH_INDEX(PAIR_NUM,1) = I
                        MATCH_INDEX(PAIR_NUM,2) = IPZ
                    ELSE
                        B = .TRUE.
                        DO J=1,PAIR_NUM
                            IF(MATCH_INDEX(J,2) .EQ. I) THEN
                                B = .FALSE.
                                EXIT
                            END IF
                        END DO

                        IF(B) THEN
                            PAIR_NUM = PAIR_NUM + 1
                            MATCH_INDEX(PAIR_NUM,1) = I
                            MATCH_INDEX(PAIR_NUM,2) = IPZ
                        END IF
                    END IF
                END IF
            END IF

        END DO

        DO K=1,PAIR_NUM
            CALL DISTANCE_FACE_FACE_TYPE(MATCH_INDEX(K,1),1,MATCH_INDEX(K,2),1,DIR,  R,B)
            IF(MATCH_INDEX(K,2) .NE. 0) THEN
                IF(R < SURFACE_FLUID%MESH_SIZE * THIN_REGION_ATTACHMENT * 1.5) THEN
                    SURFACE_PROPEL%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_PROPEL%FACE_LOCATION(MATCH_INDEX(K,1))) = 3

                    CALL REMOVE_LARGE_REGION(1, SURFACE_PROPEL%FACE_LOCATION(MATCH_INDEX(K,1)))
                    !CALL ATTACH_TWO_EDGES(1, MATCH_INDEX(K,1), MATCH_INDEX(K,2))
                    FLAG = .TRUE.
                    EXIT
                END IF
            END IF
        END DO

        CALL RESET_PATCH(1)!, PATCH_BEFORE_INDEX = PATCH_BEFORE_INDEX)                
        !CALL REMOVE_SMALL_REGIONS(1, PATCH_BEFORE_INDEX, PATCH_PARENT = PATCH_PARENT, FLAG = FLAG)
    END IF

    DEALLOCATE(MATCH_INDEX)
    !DEALLOCATE(PATCH_PARENT)

    END SUBROUTINE ZIPPER_PROPEL_IMPACT_ZONE





    SUBROUTINE MESH_QUALITY_PROCESS(TYP, FLAG)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL :: FLAG
    INTEGER :: FACE_NUM
    INTEGER, ALLOCATABLE :: FACE(:,:)
    REAL(8), ALLOCATABLE :: INITIAL_AREA(:)
    REAL(8), ALLOCATABLE :: QUALITY_ARRAY(:)
    INTEGER :: I
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    FLAG = .FALSE.

    FACE_NUM = SURFACE_CURRENT%SURFACE_FACES_NUM/2

    ALLOCATE(FACE(4,FACE_NUM))
    ALLOCATE(INITIAL_AREA(FACE_NUM))
    ALLOCATE(QUALITY_ARRAY(FACE_NUM))

    DO I=1,FACE_NUM
        FACE(1,I) = SURFACE_CURRENT%SURFACE_FACES(1,2*I-1)
        FACE(2,I) = SURFACE_CURRENT%SURFACE_FACES(2,2*I-1)
        FACE(3,I) = SURFACE_CURRENT%SURFACE_FACES(3,2*I-1)
        FACE(4,I) = SURFACE_CURRENT%SURFACE_FACES(3,2*I)

        INITIAL_AREA(I) = SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(2*I-1) + SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(2*I)
    END DO

    !CALL MESH_QUALITY_SQUARE(SURFACE_CURRENT%SURFACE_POINTS, FACE_NUM, FACE, INITIAL_AREA, QUALITY_ARRAY)
    CALL MESH_QUALITY_SQUARE(SURFACE_CURRENT%SURFACE_POINTS, FACE_NUM, FACE, INITIAL_AREA, QUALITY_ARRAY, FILE_NUM = SURFACE_PRESSURE_ITER, TYP = 1)   

    DO I=1,FACE_NUM
        IF(QUALITY_ARRAY(I) < SURFACE_CURRENT%SURFACE_INITIAL_MESH_QUALITY(I) / 2.) THEN !0.4) THEN
            FLAG = .TRUE.
            SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_CURRENT%FACE_LOCATION(2*I)) = 1
        END IF
    END DO
    DEALLOCATE(FACE)
    DEALLOCATE(INITIAL_AREA)
    DEALLOCATE(QUALITY_ARRAY)
    END SUBROUTINE MESH_QUALITY_PROCESS

    
    
    SUBROUTINE MERGE_POINT_NEIGHBOR_FACE(CONNECTION_NUM, CONNECTION, P2, P4, J0, J1)
    IMPLICIT NONE
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: P2, P4, J0, J1, NUM1, NUM2, L, IDX
    INTEGER, ALLOCATABLE :: TEMP_CONNECTION(:)

    
    NUM1 = CONNECTION_NUM(P2)
    NUM2 = CONNECTION_NUM(P4)

    ALLOCATE(TEMP_CONNECTION(NUM1))
    DO L=1,NUM1
        TEMP_CONNECTION(L) = CONNECTION(L,P2)
    END DO

    CONNECTION_NUM(P2) = 0

    IDX = 0

    DO L=1,NUM1
        IF(J0 == TEMP_CONNECTION(L)) THEN
            IDX = MOD(L,NUM1)+1

            EXIT
        END IF
    END DO

    DO WHILE(J1 .NE. TEMP_CONNECTION(IDX))
        CONNECTION_NUM(P2) = CONNECTION_NUM(P2) + 1
        CONNECTION(CONNECTION_NUM(P2), P2) = TEMP_CONNECTION(IDX)

        IDX = MOD(IDX,NUM1)+1
    END DO

    DO L=1,NUM2
        IF(J1 == CONNECTION(L,P4)) THEN
            IDX = MOD(L,NUM2)+1

            EXIT
        END IF
    END DO

    DO WHILE(J0 .NE. CONNECTION(IDX,P4))
        CONNECTION_NUM(P2) = CONNECTION_NUM(P2) + 1
        CONNECTION(CONNECTION_NUM(P2), P2) = CONNECTION(IDX,P4)

        IDX = MOD(IDX,NUM2)+1
    END DO

    DEALLOCATE(TEMP_CONNECTION)

    END SUBROUTINE MERGE_POINT_NEIGHBOR_FACE

    
    
    SUBROUTINE INSERT_POINT_NEIGHBOR_FACE(CONNECTION_NUM, CONNECTION, I0, J_INSERT, J_NEIGHBOR)
    IMPLICIT NONE
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: I0, J_INSERT, J_NEIGHBOR, NUM, K,L

    NUM = CONNECTION_NUM(I0)
    DO L=1,NUM
        IF(J_NEIGHBOR == CONNECTION(L,I0)) THEN
            DO K=NUM,L+1,-1
                CONNECTION(K+1,I0) = CONNECTION(K,I0)
            END DO
            CONNECTION(L+1,I0) = J_INSERT

            EXIT
        END IF
    END DO

    CONNECTION_NUM(I0) = CONNECTION_NUM(I0) + 1

    END SUBROUTINE INSERT_POINT_NEIGHBOR_FACE

    
    
    SUBROUTINE REMOVE_POINT_NEIGHBOR_FACE(CONNECTION_NUM, CONNECTION, I0, J_REMOVE)
    IMPLICIT NONE
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: I0, J_REMOVE, NUM, K,L

    NUM = CONNECTION_NUM(I0)
    DO L=1,NUM
        IF(J_REMOVE == CONNECTION(L,I0)) THEN
            DO K=L,NUM-1
                CONNECTION(K,I0) = CONNECTION(K+1,I0)
            END DO

            EXIT
        END IF
    END DO

    CONNECTION_NUM(I0) = CONNECTION_NUM(I0) - 1

    END SUBROUTINE REMOVE_POINT_NEIGHBOR_FACE

    
    
    SUBROUTINE CHANGE_POINT_NEIGHBOR_FACE(CONNECTION_NUM, CONNECTION, I0, J_BEFORE, J_AFTER)
    IMPLICIT NONE
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: I0, J_BEFORE, J_AFTER, NUM, L

    
    NUM = CONNECTION_NUM(I0)
    DO L=1,NUM
        IF(J_BEFORE == CONNECTION(L,I0)) THEN
            CONNECTION(L,I0) = J_AFTER

            EXIT
        END IF
    END DO

    END SUBROUTINE CHANGE_POINT_NEIGHBOR_FACE

    
    
    SUBROUTINE CHANGE_POINT_INDEX(FACE, CONNECTION_NUM, CONNECTION, I_BEFORE, I_AFTER)
    IMPLICIT NONE
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: I_BEFORE, I_AFTER, NUM, J, K, L

    NUM = CONNECTION_NUM(I_BEFORE)
    DO L=1,NUM
        J = CONNECTION(L,I_BEFORE)
        DO K=1,3
            IF(I_BEFORE == FACE(K,J)) THEN
                FACE(K,J) = I_AFTER
                EXIT
            END IF
        END DO
    END DO

    END SUBROUTINE CHANGE_POINT_INDEX


    
    SUBROUTINE CHANGE_FACE_INDEX(FACE, CONNECTION_NUM, CONNECTION, J_BEFORE, J_AFTER)
    IMPLICIT NONE
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: J_BEFORE, J_AFTER, NUM, I, K, L

    DO K=1,3
        I = FACE(K,J_BEFORE)
        NUM = CONNECTION_NUM(I)
        DO L=1,NUM
            IF(J_BEFORE == CONNECTION(L,I)) THEN
                CONNECTION(L,I) = J_AFTER
                EXIT
            END IF
        END DO
    END DO

    END SUBROUTINE CHANGE_FACE_INDEX

    
    
    SUBROUTINE EDGE_SPLITTING_PROCESS_ONE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, TEMP_NEWONINTERFACE, &
    TEMP_NEWLOCATION, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_ABLATION_FLAG, TEMP_CONNECTION, TEMP_CONNECTION_NUM, I, K, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, POINT_NEW1, POINT_NEW2, POINT_NEW3, POINT_NEW4, POINT_NEW5)
    IMPLICIT NONE
    REAL(8) :: TEMPPOINT(:,:)
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: TEMPINITIALPOINT_TYPE(:)
    INTEGER :: TEMPPOINT_TYPE(:)
    INTEGER :: TEMP_NEWONINTERFACE(:)
    INTEGER :: TEMP_NEWLOCATION(:)
    REAL(8) :: TEMP_NEWEDGELENGTH(:,:)
    REAL(8) :: TEMP_NEWFACEAREA(:)
    INTEGER :: TEMP_ABLATION_FLAG(:)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    INTEGER :: TEMP_POINT_NUM, TEMP_FACE_NUM
    REAL(8) :: XYZN(3)
    INTEGER :: I, K, L, I1, POINT_IDX1, POINT_IDX2, POINT_IDX3, POINT_IDX4
    REAL(8) :: EDGELENGTH12, EDGELENGTH23, EDGELENGTH34, EDGELENGTH14, EDGELENGTH24
    INTEGER, OPTIONAL :: DIVIDED_REGION_ARRAY(:)
    INTEGER, OPTIONAL :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER :: BOUNDARY_FLAG12, BOUNDARY_FLAG24, BOUNDARY_FLAG41, BOUNDARY_FLAG23, BOUNDARY_FLAG34, BOUNDARY_FLAG42
    INTEGER, OPTIONAL :: POINT_NEW1, POINT_NEW2, POINT_NEW3, POINT_NEW4, POINT_NEW5


    CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)

    POINT_IDX1 = TEMPFACE(MOD(K+3-2, 3) + 1, I)
    POINT_IDX2 = TEMPFACE(K, I)

    DO L=1,3
        IF(TEMPFACE(L,I1)==POINT_IDX2) THEN
            POINT_IDX3 = TEMPFACE(MOD(L,3) + 1, I1)
            EXIT
        END IF
    END DO

    POINT_IDX4 = TEMPFACE(MOD(K,3) + 1, I)

    EDGELENGTH12 = TEMP_NEWEDGELENGTH(MOD(K+3-2, 3) + 1, I)
    EDGELENGTH23 = TEMP_NEWEDGELENGTH(L,I1)
    EDGELENGTH34 = TEMP_NEWEDGELENGTH(MOD(L,3) + 1,I1)
    EDGELENGTH14 = TEMP_NEWEDGELENGTH(MOD(K,3) + 1,I)
    EDGELENGTH24 = TEMP_NEWEDGELENGTH(K,I)

    !XYZN = (TEMPPOINT(:,POINT_IDX2)+TEMPPOINT(:,POINT_IDX4))/2.
    CALL NEWPOINT_HIGHORDER(I, K, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, DIVIDED_BOUNDARY_ARRAY, XYZN)

    TEMP_POINT_NUM = TEMP_POINT_NUM+1
    TEMP_FACE_NUM = TEMP_FACE_NUM+2

    TEMPPOINT(:,TEMP_POINT_NUM) = XYZN

    TEMPFACE(1,TEMP_FACE_NUM-1) = TEMP_POINT_NUM
    TEMPFACE(2,TEMP_FACE_NUM-1) = POINT_IDX2
    TEMPFACE(3,TEMP_FACE_NUM-1) = POINT_IDX3

    TEMPFACE(1,TEMP_FACE_NUM) = TEMP_POINT_NUM
    TEMPFACE(2,TEMP_FACE_NUM) = POINT_IDX4
    TEMPFACE(3,TEMP_FACE_NUM) = POINT_IDX1

    TEMPFACE(1,I) = TEMP_POINT_NUM
    TEMPFACE(2,I) = POINT_IDX1
    TEMPFACE(3,I) = POINT_IDX2

    TEMPFACE(1,I1) = TEMP_POINT_NUM
    TEMPFACE(2,I1) = POINT_IDX3
    TEMPFACE(3,I1) = POINT_IDX4

    TEMPINITIALPOINT_TYPE(TEMP_POINT_NUM) = MIN(TEMPINITIALPOINT_TYPE(POINT_IDX2), TEMPINITIALPOINT_TYPE(POINT_IDX4))
    TEMPPOINT_TYPE(TEMP_POINT_NUM) = MIN(TEMPPOINT_TYPE(POINT_IDX2), TEMPPOINT_TYPE(POINT_IDX4))

    IF(PRESENT(DIVIDED_BOUNDARY_ARRAY)) THEN
        IF(DIVIDED_BOUNDARY_ARRAY(K,I)==0) THEN
            TEMPINITIALPOINT_TYPE(TEMP_POINT_NUM) = 1
            TEMPPOINT_TYPE(TEMP_POINT_NUM) = 1
        END IF
    END IF

    TEMP_NEWONINTERFACE(TEMP_FACE_NUM-1) = TEMP_NEWONINTERFACE(I1)
    TEMP_NEWONINTERFACE(TEMP_FACE_NUM) = TEMP_NEWONINTERFACE(I)

    TEMP_NEWLOCATION(TEMP_FACE_NUM-1) = TEMP_NEWLOCATION(I1)
    TEMP_NEWLOCATION(TEMP_FACE_NUM) = TEMP_NEWLOCATION(I)

    TEMP_NEWFACEAREA(TEMP_FACE_NUM-1) = TEMP_NEWFACEAREA(I1)
    TEMP_NEWFACEAREA(TEMP_FACE_NUM) = TEMP_NEWFACEAREA(I)

    TEMP_NEWEDGELENGTH(1,I) = (EDGELENGTH14+EDGELENGTH12)/2.
    TEMP_NEWEDGELENGTH(2,I) = EDGELENGTH12
    TEMP_NEWEDGELENGTH(3,I) = EDGELENGTH24
    TEMP_NEWEDGELENGTH(1,I1) = (EDGELENGTH23+EDGELENGTH34)/2.
    TEMP_NEWEDGELENGTH(2,I1) = EDGELENGTH34
    TEMP_NEWEDGELENGTH(3,I1) = EDGELENGTH24
    TEMP_NEWEDGELENGTH(1,TEMP_FACE_NUM-1) = EDGELENGTH24
    TEMP_NEWEDGELENGTH(2,TEMP_FACE_NUM-1) = EDGELENGTH23
    TEMP_NEWEDGELENGTH(3,TEMP_FACE_NUM-1) = (EDGELENGTH23+EDGELENGTH34)/2.
    TEMP_NEWEDGELENGTH(1,TEMP_FACE_NUM) = EDGELENGTH24
    TEMP_NEWEDGELENGTH(2,TEMP_FACE_NUM) = EDGELENGTH14
    TEMP_NEWEDGELENGTH(3,TEMP_FACE_NUM) = (EDGELENGTH14+EDGELENGTH12)/2.

    TEMP_ABLATION_FLAG(TEMP_FACE_NUM-1) = TEMP_ABLATION_FLAG(I1)
    TEMP_ABLATION_FLAG(TEMP_FACE_NUM) = TEMP_ABLATION_FLAG(I)

    IF(PRESENT(DIVIDED_REGION_ARRAY)) THEN
        DIVIDED_REGION_ARRAY(TEMP_FACE_NUM-1) = DIVIDED_REGION_ARRAY(I1)
        DIVIDED_REGION_ARRAY(TEMP_FACE_NUM) = DIVIDED_REGION_ARRAY(I)
    END IF

    IF(PRESENT(DIVIDED_BOUNDARY_ARRAY)) THEN
        BOUNDARY_FLAG12 = DIVIDED_BOUNDARY_ARRAY(MOD(K+3-2, 3) + 1, I)
        BOUNDARY_FLAG24 = DIVIDED_BOUNDARY_ARRAY(K,I)
        BOUNDARY_FLAG41 = DIVIDED_BOUNDARY_ARRAY(MOD(K,3) + 1,I)
        BOUNDARY_FLAG23 = DIVIDED_BOUNDARY_ARRAY(L,I1)
        BOUNDARY_FLAG34 = DIVIDED_BOUNDARY_ARRAY(MOD(L,3) + 1,I1)
        BOUNDARY_FLAG42 = DIVIDED_BOUNDARY_ARRAY(MOD(L+3-2,3) + 1,I1)

        DIVIDED_BOUNDARY_ARRAY(1,I) = 0
        DIVIDED_BOUNDARY_ARRAY(2,I) = BOUNDARY_FLAG12
        DIVIDED_BOUNDARY_ARRAY(3,I) = BOUNDARY_FLAG24
        DIVIDED_BOUNDARY_ARRAY(1,I1) = 0
        DIVIDED_BOUNDARY_ARRAY(2,I1) = BOUNDARY_FLAG34
        DIVIDED_BOUNDARY_ARRAY(3,I1) = BOUNDARY_FLAG42
        DIVIDED_BOUNDARY_ARRAY(1,TEMP_FACE_NUM-1) = BOUNDARY_FLAG42
        DIVIDED_BOUNDARY_ARRAY(2,TEMP_FACE_NUM-1) = BOUNDARY_FLAG23
        DIVIDED_BOUNDARY_ARRAY(3,TEMP_FACE_NUM-1) = 0
        DIVIDED_BOUNDARY_ARRAY(1,TEMP_FACE_NUM) = BOUNDARY_FLAG24
        DIVIDED_BOUNDARY_ARRAY(2,TEMP_FACE_NUM) = BOUNDARY_FLAG41
        DIVIDED_BOUNDARY_ARRAY(3,TEMP_FACE_NUM) = 0
    END IF

    CALL INSERT_POINT_NEIGHBOR_FACE(TEMP_CONNECTION_NUM, TEMP_CONNECTION, POINT_IDX1, TEMP_FACE_NUM, I)
    CALL INSERT_POINT_NEIGHBOR_FACE(TEMP_CONNECTION_NUM, TEMP_CONNECTION, POINT_IDX3, TEMP_FACE_NUM-1, I1)

    CALL CHANGE_POINT_NEIGHBOR_FACE(TEMP_CONNECTION_NUM, TEMP_CONNECTION, POINT_IDX2, I1, TEMP_FACE_NUM-1)
    CALL CHANGE_POINT_NEIGHBOR_FACE(TEMP_CONNECTION_NUM, TEMP_CONNECTION, POINT_IDX4, I, TEMP_FACE_NUM)

    TEMP_CONNECTION_NUM(TEMP_POINT_NUM) = 4
    TEMP_CONNECTION(1,TEMP_POINT_NUM) = I
    TEMP_CONNECTION(2,TEMP_POINT_NUM) = TEMP_FACE_NUM-1
    TEMP_CONNECTION(3,TEMP_POINT_NUM) = I1
    TEMP_CONNECTION(4,TEMP_POINT_NUM) = TEMP_FACE_NUM

    IF(PRESENT(POINT_NEW1)) THEN
        POINT_NEW1 = POINT_IDX1
    END IF

    IF(PRESENT(POINT_NEW2)) THEN
        POINT_NEW2 = POINT_IDX2
    END IF

    IF(PRESENT(POINT_NEW3)) THEN
        POINT_NEW3 = POINT_IDX3
    END IF

    IF(PRESENT(POINT_NEW4)) THEN
        POINT_NEW4 = POINT_IDX4
    END IF

    IF(PRESENT(POINT_NEW5)) THEN
        POINT_NEW5 = TEMP_POINT_NUM
    END IF

    END SUBROUTINE EDGE_SPLITTING_PROCESS_ONE

    
    
    SUBROUTINE EDGE_COLLAPSING_PROCESS_ONE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, TEMP_NEWONINTERFACE, &
    TEMP_NEWLOCATION, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_ABLATION_FLAG, TEMP_CONNECTION, TEMP_CONNECTION_NUM, I, K, COLLAPSING_EDGE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, POINT_NEW1, POINT_NEW2, POINT_NEW3)
    IMPLICIT NONE
    REAL(8) :: TEMPPOINT(:,:)
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: TEMPINITIALPOINT_TYPE(:)
    INTEGER :: TEMPPOINT_TYPE(:)
    INTEGER :: TEMP_NEWONINTERFACE(:)
    INTEGER :: TEMP_NEWLOCATION(:)
    REAL(8) :: TEMP_NEWEDGELENGTH(:,:)
    REAL(8) :: TEMP_NEWFACEAREA(:)
    INTEGER :: TEMP_ABLATION_FLAG(:)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    LOGICAL, OPTIONAL :: COLLAPSING_EDGE(:,:)
    INTEGER :: TEMP_POINT_NUM, TEMP_FACE_NUM
    REAL(8) :: XYZN(3),XYZC(3)
    INTEGER :: I, K, L, I1, POINT_IDX1, POINT_IDX2, POINT_IDX3, POINT_IDX4
    REAL(8) :: EDGELENGTH12, EDGELENGTH23, EDGELENGTH34, EDGELENGTH14, EDGELENGTH24
    INTEGER, OPTIONAL :: DIVIDED_REGION_ARRAY(:)
    INTEGER, OPTIONAL :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER :: BOUNDARY_FLAG12, BOUNDARY_FLAG24, BOUNDARY_FLAG41, BOUNDARY_FLAG23, BOUNDARY_FLAG34, BOUNDARY_FLAG42, II1, II2, II3, II4, L1, L2, L3, L4
    INTEGER, OPTIONAL :: POINT_NEW1, POINT_NEW2, POINT_NEW3

    
    CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I,K, I1)

    POINT_IDX1 = TEMPFACE(MOD(K+3-2, 3) + 1, I)
    POINT_IDX2 = TEMPFACE(K, I)

    DO L=1,3
        IF(TEMPFACE(L,I1)==POINT_IDX2) THEN
            POINT_IDX3 = TEMPFACE(MOD(L,3) + 1, I1)
            EXIT
        END IF
    END DO

    POINT_IDX4 = TEMPFACE(MOD(K,3) + 1, I)

    !XYZC = (TEMPPOINT(:,POINT_IDX2)+TEMPPOINT(:,POINT_IDX4))/2.
    CALL NEWPOINT_HIGHORDER(I, K, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, DIVIDED_BOUNDARY_ARRAY, XYZC)

    IF(TEMPPOINT_TYPE(POINT_IDX2) > TEMPPOINT_TYPE(POINT_IDX4)) THEN
        XYZN = TEMPPOINT(:,POINT_IDX2)
    ELSE IF(TEMPPOINT_TYPE(POINT_IDX4) > TEMPPOINT_TYPE(POINT_IDX2)) THEN
        XYZN = TEMPPOINT(:,POINT_IDX4)
    ELSE IF(TEMPINITIALPOINT_TYPE(POINT_IDX2) > TEMPINITIALPOINT_TYPE(POINT_IDX4)) THEN
        XYZN = TEMPPOINT(:,POINT_IDX2)
    ELSE IF(TEMPINITIALPOINT_TYPE(POINT_IDX4) > TEMPINITIALPOINT_TYPE(POINT_IDX2)) THEN
        XYZN = TEMPPOINT(:,POINT_IDX4)
    ELSE
        XYZN = XYZC
    END IF

    !! END MODIFIED

    TEMPPOINT(:,POINT_IDX2) = XYZN
    TEMPINITIALPOINT_TYPE(POINT_IDX2) = MAX(TEMPINITIALPOINT_TYPE(POINT_IDX2), TEMPINITIALPOINT_TYPE(POINT_IDX4))
    TEMPPOINT_TYPE(POINT_IDX2) = MAX(TEMPPOINT_TYPE(POINT_IDX2), TEMPPOINT_TYPE(POINT_IDX4))


    CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I,MOD(K+3-2, 3) + 1, II1)
    CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I1,L, II2)
    CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I1,MOD(L,3) + 1, II3)
    CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I,MOD(K,3) + 1, II4)

    DO L1=1,3
        IF(TEMPFACE(L1,II1)==POINT_IDX2) THEN
            EXIT
        END IF
    END DO

    DO L2=1,3
        IF(TEMPFACE(L2,II2)==POINT_IDX3) THEN
            EXIT
        END IF
    END DO

    DO L3=1,3
        IF(TEMPFACE(L3,II3)==POINT_IDX4) THEN
            EXIT
        END IF
    END DO

    DO L4=1,3
        IF(TEMPFACE(L4,II4)==POINT_IDX1) THEN
            EXIT
        END IF
    END DO

    EDGELENGTH12 = TEMP_NEWEDGELENGTH(MOD(K+3-2, 3) + 1, I)
    EDGELENGTH23 = TEMP_NEWEDGELENGTH(L,I1)
    EDGELENGTH34 = TEMP_NEWEDGELENGTH(MOD(L,3) + 1,I1)
    EDGELENGTH14 = TEMP_NEWEDGELENGTH(MOD(K,3) + 1,I)

    TEMP_NEWEDGELENGTH(L1,II1) = (EDGELENGTH12+EDGELENGTH14)/2.
    TEMP_NEWEDGELENGTH(L2,II2) = (EDGELENGTH23+EDGELENGTH34)/2.
    TEMP_NEWEDGELENGTH(L3,II3) = (EDGELENGTH23+EDGELENGTH34)/2.
    TEMP_NEWEDGELENGTH(L4,II4) = (EDGELENGTH12+EDGELENGTH14)/2.


    IF(PRESENT(DIVIDED_BOUNDARY_ARRAY)) THEN
        BOUNDARY_FLAG12 = DIVIDED_BOUNDARY_ARRAY(MOD(K+3-2, 3) + 1, I)
        BOUNDARY_FLAG24 = DIVIDED_BOUNDARY_ARRAY(K,I)
        BOUNDARY_FLAG41 = DIVIDED_BOUNDARY_ARRAY(MOD(K,3) + 1,I)
        BOUNDARY_FLAG23 = DIVIDED_BOUNDARY_ARRAY(L,I1)
        BOUNDARY_FLAG34 = DIVIDED_BOUNDARY_ARRAY(MOD(L,3) + 1,I1)
        BOUNDARY_FLAG42 = DIVIDED_BOUNDARY_ARRAY(MOD(L+3-2,3) + 1,I1)
        
        IF(BOUNDARY_FLAG12 .NE. 0) THEN
            DIVIDED_BOUNDARY_ARRAY(L4,II4) = BOUNDARY_FLAG12
        END IF

        IF(BOUNDARY_FLAG23 .NE. 0) THEN
            DIVIDED_BOUNDARY_ARRAY(L3,II3) = BOUNDARY_FLAG23
        END IF

        IF(BOUNDARY_FLAG34 .NE. 0) THEN
            DIVIDED_BOUNDARY_ARRAY(L2,II2) = BOUNDARY_FLAG34
        END IF

        IF(BOUNDARY_FLAG41 .NE. 0) THEN
            DIVIDED_BOUNDARY_ARRAY(L1,II1) = BOUNDARY_FLAG41
        END IF
    END IF

    CALL CHANGE_POINT_INDEX(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, POINT_IDX4, POINT_IDX2)
    CALL REMOVE_POINT_NEIGHBOR_FACE(TEMP_CONNECTION_NUM, TEMP_CONNECTION, POINT_IDX1, I)
    CALL REMOVE_POINT_NEIGHBOR_FACE(TEMP_CONNECTION_NUM, TEMP_CONNECTION, POINT_IDX3, I1)
    CALL MERGE_POINT_NEIGHBOR_FACE(TEMP_CONNECTION_NUM, TEMP_CONNECTION, POINT_IDX2, POINT_IDX4, I, I1)

    IF(POINT_IDX4 .NE. TEMP_POINT_NUM) THEN
        CALL CHANGE_POINT_INDEX(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_POINT_NUM, POINT_IDX4)

        TEMPPOINT(:,POINT_IDX4) = TEMPPOINT(:,TEMP_POINT_NUM)
        TEMPINITIALPOINT_TYPE(POINT_IDX4) = TEMPINITIALPOINT_TYPE(TEMP_POINT_NUM)
        TEMPPOINT_TYPE(POINT_IDX4) = TEMPPOINT_TYPE(TEMP_POINT_NUM)
        TEMP_CONNECTION(:,POINT_IDX4) = TEMP_CONNECTION(:,TEMP_POINT_NUM)
        TEMP_CONNECTION_NUM(POINT_IDX4) = TEMP_CONNECTION_NUM(TEMP_POINT_NUM)
    END IF

    IF(I .NE. TEMP_FACE_NUM) THEN
        CALL CHANGE_FACE_INDEX(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_FACE_NUM, I)

        TEMPFACE(:,I) = TEMPFACE(:,TEMP_FACE_NUM)
        TEMP_NEWONINTERFACE(I) = TEMP_NEWONINTERFACE(TEMP_FACE_NUM)
        TEMP_NEWLOCATION(I) = TEMP_NEWLOCATION(TEMP_FACE_NUM)
        TEMP_NEWEDGELENGTH(:,I) = TEMP_NEWEDGELENGTH(:,TEMP_FACE_NUM)
        TEMP_NEWFACEAREA(I) = TEMP_NEWFACEAREA(TEMP_FACE_NUM)
        IF(PRESENT(COLLAPSING_EDGE)) THEN
            COLLAPSING_EDGE(:,I) = COLLAPSING_EDGE(:,TEMP_FACE_NUM)
        END IF
        TEMP_ABLATION_FLAG(I) = TEMP_ABLATION_FLAG(TEMP_FACE_NUM)

        IF(PRESENT(DIVIDED_REGION_ARRAY)) THEN
            DIVIDED_REGION_ARRAY(I) = DIVIDED_REGION_ARRAY(TEMP_FACE_NUM)
        END IF

        IF(PRESENT(DIVIDED_BOUNDARY_ARRAY)) THEN
            DIVIDED_BOUNDARY_ARRAY(:,I) = DIVIDED_BOUNDARY_ARRAY(:,TEMP_FACE_NUM)
        END IF
    END IF

    IF(I1 == TEMP_FACE_NUM) THEN
        I1 = I
    END IF

    IF(I1 .NE. TEMP_FACE_NUM-1) THEN
        CALL CHANGE_FACE_INDEX(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_FACE_NUM-1, I1)

        TEMPFACE(:,I1) = TEMPFACE(:,TEMP_FACE_NUM-1)
        TEMP_NEWONINTERFACE(I1) = TEMP_NEWONINTERFACE(TEMP_FACE_NUM-1)
        TEMP_NEWLOCATION(I1) = TEMP_NEWLOCATION(TEMP_FACE_NUM-1)
        TEMP_NEWEDGELENGTH(:,I1) = TEMP_NEWEDGELENGTH(:,TEMP_FACE_NUM-1)
        TEMP_NEWFACEAREA(I1) = TEMP_NEWFACEAREA(TEMP_FACE_NUM-1)
        IF(PRESENT(COLLAPSING_EDGE)) THEN
            COLLAPSING_EDGE(:,I1) = COLLAPSING_EDGE(:,TEMP_FACE_NUM-1)
        END IF
        TEMP_ABLATION_FLAG(I1) = TEMP_ABLATION_FLAG(TEMP_FACE_NUM-1)

        IF(PRESENT(DIVIDED_REGION_ARRAY)) THEN
            DIVIDED_REGION_ARRAY(I1) = DIVIDED_REGION_ARRAY(TEMP_FACE_NUM-1)
        END IF

        IF(PRESENT(DIVIDED_BOUNDARY_ARRAY)) THEN
            DIVIDED_BOUNDARY_ARRAY(:,I1) = DIVIDED_BOUNDARY_ARRAY(:,TEMP_FACE_NUM-1)
        END IF
    END IF

    TEMP_POINT_NUM = TEMP_POINT_NUM-1
    TEMP_FACE_NUM = TEMP_FACE_NUM-2

    IF(PRESENT(POINT_NEW1)) THEN
        IF(POINT_IDX1==TEMP_POINT_NUM+1) THEN
            POINT_NEW1 = POINT_IDX4
        ELSE
            POINT_NEW1 = POINT_IDX1
        END IF
    END IF

    IF(PRESENT(POINT_NEW2)) THEN
        IF(POINT_IDX2==TEMP_POINT_NUM+1) THEN
            POINT_NEW2 = POINT_IDX4
        ELSE
            POINT_NEW2 = POINT_IDX2
        END IF
    END IF

    IF(PRESENT(POINT_NEW3)) THEN
        IF(POINT_IDX3==TEMP_POINT_NUM+1) THEN
            POINT_NEW3 = POINT_IDX4
        ELSE
            POINT_NEW3 = POINT_IDX3
        END IF
    END IF


    END SUBROUTINE EDGE_COLLAPSING_PROCESS_ONE

    
    
    SUBROUTINE EDGE_FLIPPING_PROCESS_ONE(TEMPFACE, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_CONNECTION, TEMP_CONNECTION_NUM, I, K, DIVIDED_BOUNDARY_ARRAY)
    IMPLICIT NONE
    INTEGER :: TEMPFACE(:,:)
    REAL(8) :: TEMP_NEWEDGELENGTH(:,:)
    REAL(8) :: TEMP_NEWFACEAREA(:)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    INTEGER :: I, K, L, I1, POINT_IDX1, POINT_IDX2, POINT_IDX3, POINT_IDX4
    REAL(8) :: EDGELENGTH12, EDGELENGTH23, EDGELENGTH34, EDGELENGTH14, EDGELENGTH24
    INTEGER, OPTIONAL :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER :: BOUNDARY_FLAG12, BOUNDARY_FLAG24, BOUNDARY_FLAG41, BOUNDARY_FLAG23, BOUNDARY_FLAG34, BOUNDARY_FLAG42
    REAL(8) :: R

    CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)

    POINT_IDX1 = TEMPFACE(MOD(K+3-2, 3) + 1, I)
    POINT_IDX2 = TEMPFACE(K, I)

    DO L=1,3
        IF(TEMPFACE(L,I1)==POINT_IDX2) THEN
            POINT_IDX3 = TEMPFACE(MOD(L,3) + 1, I1)
            EXIT
        END IF
    END DO

    POINT_IDX4 = TEMPFACE(MOD(K,3) + 1, I)

    EDGELENGTH12 = TEMP_NEWEDGELENGTH(MOD(K+3-2, 3) + 1, I)
    EDGELENGTH23 = TEMP_NEWEDGELENGTH(L,I1)
    EDGELENGTH34 = TEMP_NEWEDGELENGTH(MOD(L,3) + 1,I1)
    EDGELENGTH14 = TEMP_NEWEDGELENGTH(MOD(K,3) + 1,I)
    EDGELENGTH24 = TEMP_NEWEDGELENGTH(K,I)

    TEMPFACE(1,I) = POINT_IDX1
    TEMPFACE(2,I) = POINT_IDX2
    TEMPFACE(3,I) = POINT_IDX3

    TEMPFACE(1,I1) = POINT_IDX3
    TEMPFACE(2,I1) = POINT_IDX4
    TEMPFACE(3,I1) = POINT_IDX1

    R = (TEMP_NEWFACEAREA(I) + TEMP_NEWFACEAREA(I1))/2.

    TEMP_NEWFACEAREA(I) = R
    TEMP_NEWFACEAREA(I1) = R

    TEMP_NEWEDGELENGTH(1,I) = EDGELENGTH12
    TEMP_NEWEDGELENGTH(2,I) = EDGELENGTH23
    TEMP_NEWEDGELENGTH(3,I) = EDGELENGTH24
    TEMP_NEWEDGELENGTH(1,I1) = EDGELENGTH34
    TEMP_NEWEDGELENGTH(2,I1) = EDGELENGTH14
    TEMP_NEWEDGELENGTH(3,I1) = EDGELENGTH24

    IF(PRESENT(DIVIDED_BOUNDARY_ARRAY)) THEN

    BOUNDARY_FLAG12 = DIVIDED_BOUNDARY_ARRAY(MOD(K+3-2, 3) + 1, I)
    BOUNDARY_FLAG24 = DIVIDED_BOUNDARY_ARRAY(K,I)
    BOUNDARY_FLAG41 = DIVIDED_BOUNDARY_ARRAY(MOD(K,3) + 1,I)
    BOUNDARY_FLAG23 = DIVIDED_BOUNDARY_ARRAY(L,I1)
    BOUNDARY_FLAG34 = DIVIDED_BOUNDARY_ARRAY(MOD(L,3) + 1,I1)
    BOUNDARY_FLAG42 = DIVIDED_BOUNDARY_ARRAY(MOD(L+3-2,3) + 1,I1)


    DIVIDED_BOUNDARY_ARRAY(1,I) = BOUNDARY_FLAG12
    DIVIDED_BOUNDARY_ARRAY(2,I) = BOUNDARY_FLAG23
    DIVIDED_BOUNDARY_ARRAY(3,I) = 0
    DIVIDED_BOUNDARY_ARRAY(1,I1) = BOUNDARY_FLAG34
    DIVIDED_BOUNDARY_ARRAY(2,I1) = BOUNDARY_FLAG41
    DIVIDED_BOUNDARY_ARRAY(3,I1) = 0
    END IF


    CALL INSERT_POINT_NEIGHBOR_FACE(TEMP_CONNECTION_NUM, TEMP_CONNECTION, POINT_IDX1, I1, I)
    CALL INSERT_POINT_NEIGHBOR_FACE(TEMP_CONNECTION_NUM, TEMP_CONNECTION, POINT_IDX3, I, I1)
    CALL REMOVE_POINT_NEIGHBOR_FACE(TEMP_CONNECTION_NUM, TEMP_CONNECTION, POINT_IDX2, I1)
    CALL REMOVE_POINT_NEIGHBOR_FACE(TEMP_CONNECTION_NUM, TEMP_CONNECTION, POINT_IDX4, I)

    END SUBROUTINE EDGE_FLIPPING_PROCESS_ONE

    
    
    SUBROUTINE CHECK_FACE_REMESHING_AVAILABLE(FACE, CONNECTION_NUM, CONNECTION, I0, REMESHING_EDGE,        B)
    IMPLICIT NONE
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: I0
    LOGICAL :: REMESHING_EDGE(:,:)
    LOGICAL :: B
    INTEGER :: K,L,I1,I2

    B = .TRUE.
    DO K=1,3
        IF(REMESHING_EDGE(K,I0)) THEN
            B = .FALSE.
            EXIT
        END IF

        CALL FACE_NEIGHBOR_FACE(FACE, CONNECTION_NUM, CONNECTION,I0,K, I1)
        DO L=1,3
            CALL FACE_NEIGHBOR_FACE(FACE, CONNECTION_NUM, CONNECTION,I1,L, I2)
            IF(I2==I0) THEN
                EXIT
            END IF
        END DO

        IF(L==4) THEN
            L=5
        END IF

        IF(REMESHING_EDGE(L,I2)) THEN
            B = .FALSE.
            EXIT
        END IF
    END DO
    END SUBROUTINE CHECK_FACE_REMESHING_AVAILABLE

    SUBROUTINE QUALITY_PRINT(POINT, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, INITIAL_AREA, DIVIDED_BOUNDARY)
        IMPLICIT NONE

        REAL(8) :: POINT(:,:)
        INTEGER :: FACE_NUM
        INTEGER :: FACE(:,:)
        INTEGER :: CONNECTION_NUM(:)
        INTEGER :: CONNECTION(:,:)
        REAL(8) :: INITIAL_AREA(:)
        INTEGER :: DIVIDED_BOUNDARY(:,:)
        REAL(8) :: F_SHAPE, F_SIZE, F_SIZE_SHAPE
        
        INTEGER :: QUALITY_SUM(10)
        REAL(8) :: QUALITY_PERCENT(10)
        INTEGER :: NUM
        INTEGER :: I
        
        CHARACTER(500) ::STR, TEMPSTR
        
        QUALITY_SUM(:) = 0
        DO I=1, FACE_NUM
            CALL MESH_QUALITY_TRIANGLE_ONE_ORIENTATION(POINT, FACE, I, CONNECTION_NUM, CONNECTION, INITIAL_AREA, DIVIDED_BOUNDARY, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
            NUM = MAX(MIN(CEILING(F_SHAPE / 0.1), 10), 1)
            QUALITY_SUM(NUM) = QUALITY_SUM(NUM) + 1
        END DO
        
        QUALITY_PERCENT(:) = REAL(QUALITY_SUM(:)) / REAL(FACE_NUM) * 100.
        
        STR = ''
        TEMPSTR = ''
        DO I=1,10
            WRITE(TEMPSTR,*) QUALITY_PERCENT(I)
            TEMPSTR = TRIM(ADJUSTL(TEMPSTR))
            STR = TRIM(ADJUSTL(STR)) // ' ' // TEMPSTR(1:6)
            TEMPSTR = ''
        END DO
        
        WRITE(*,*) 'QUALITY : ', STR(1:LEN_TRIM(STR))
    END SUBROUTINE
    
    SUBROUTINE QUALITY_LEAST_SQUARE(POINT, FACE_NUM, FACE, INITIAL_AREA, S)
    IMPLICIT NONE
    REAL(8) :: POINT(:,:)
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    REAL(8) :: INITIAL_AREA(:)
    REAL(8) :: F_SHAPE, F_SIZE, F_SIZE_SHAPE, S
    INTEGER :: I

    S = 0
    DO I=1,FACE_NUM
        CALL MESH_QUALITY_TRIANGLE_ONE(POINT(:,FACE(1,I)), POINT(:,FACE(2,I)), POINT(:,FACE(3,I)), INITIAL_AREA(I), F_SIZE_SHAPE, F_SIZE, F_SHAPE)
        S = S + (F_SHAPE - 1.)**2
    END DO

    END SUBROUTINE QUALITY_LEAST_SQUARE

    
    
    SUBROUTINE DEGREE_LEAST_SQUARE(POINT_NUM, CONNECTION_NUM,        S)
    IMPLICIT NONE
    INTEGER :: POINT_NUM
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: I, S

    S = 0
    DO I=1,POINT_NUM
        S = S + (CONNECTION_NUM(I) - 6)**2
    END DO

    END SUBROUTINE DEGREE_LEAST_SQUARE




    SUBROUTINE MAKE_LOCAL_REGION(POINT_NUM, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_FLAG, START_POINT_IDX,        LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, USED_FACE)
    IMPLICIT NONE
    INTEGER :: POINT_NUM
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: DIVIDED_REGION_ARRAY(:)
    INTEGER :: DIVIDED_REGION_FLAG
    INTEGER :: START_POINT_IDX
    INTEGER :: LOCAL_REGION_ARRAY(:), LOCAL_REGION_NUM, LOCAL_REGION_NUM_MAX, BEFORE_LOCAL_REGION_NUM
    INTEGER, ALLOCATABLE :: BOUNDARY_ARRAY(:)
    INTEGER :: BOUNDARY_NUM
    LOGICAL :: B, C
    LOGICAL :: IS_INTERIOR_POINT(:)
    LOGICAL :: USED_FACE(:)
    LOGICAL, ALLOCATABLE :: IS_BOUNDARY_POINT(:)
    INTEGER :: I, J, I1, I2, ITER

    LOCAL_REGION_NUM_MAX = 100

    ALLOCATE(IS_BOUNDARY_POINT(POINT_NUM))

    DO I=1,POINT_NUM
        IS_INTERIOR_POINT(I) = .FALSE.
        IS_BOUNDARY_POINT(I) = .FALSE.
    END DO
    DO I=1,FACE_NUM
        USED_FACE(I) = .FALSE.
    END DO

    ALLOCATE(BOUNDARY_ARRAY(5*LOCAL_REGION_NUM_MAX))

    BOUNDARY_NUM = 1
    BOUNDARY_ARRAY(BOUNDARY_NUM) = START_POINT_IDX

    IS_BOUNDARY_POINT(START_POINT_IDX) = .TRUE.

    LOCAL_REGION_NUM = 0
    BEFORE_LOCAL_REGION_NUM = 0

    B = .TRUE.
    DO WHILE(B)

    DO ITER=1,BOUNDARY_NUM
        I = BOUNDARY_ARRAY(ITER)
        C = .TRUE.

        DO J=1,CONNECTION_NUM(I)
            IF(.NOT. USED_FACE(CONNECTION(J,I))) THEN
                IF(DIVIDED_REGION_ARRAY(CONNECTION(J,I)) .NE. DIVIDED_REGION_FLAG) THEN
                    C = .FALSE.
                ELSE
                    CALL POINT_NEIGHBOR_POINT(FACE, CONNECTION, I, MOD(J,CONNECTION_NUM(I))+1, I1)
                    CALL POINT_NEIGHBOR_POINT(FACE, CONNECTION, I, J, I2)

                    IF(.NOT. USED_FACE(CONNECTION(J,I)) .AND. .NOT. USED_FACE(CONNECTION(MOD(J,CONNECTION_NUM(I))+1,I)) .AND. IS_BOUNDARY_POINT(I1)) THEN
                        C = .FALSE.
                    ELSE IF(.NOT. USED_FACE(CONNECTION(J,I)) .AND. .NOT. USED_FACE(CONNECTION(MOD(J+CONNECTION_NUM(I)-2,CONNECTION_NUM(I))+1,I)) .AND. IS_BOUNDARY_POINT(I2)) THEN
                        C = .FALSE.
                    ELSE
                        USED_FACE(CONNECTION(J,I)) = .TRUE.

                        LOCAL_REGION_NUM = LOCAL_REGION_NUM + 1
                        LOCAL_REGION_ARRAY(LOCAL_REGION_NUM) = CONNECTION(J,I)
                    END IF
                END IF
            END IF
        END DO

        IF(C) THEN
            IS_INTERIOR_POINT(I) = .TRUE.
        END IF
    END DO

    BOUNDARY_NUM = 0
    IS_BOUNDARY_POINT(:) = .FALSE.

    DO ITER=1,LOCAL_REGION_NUM
        I = LOCAL_REGION_ARRAY(ITER)
        DO J=1,3
            IF(.NOT. IS_INTERIOR_POINT(FACE(J,I)) .AND. .NOT. IS_BOUNDARY_POINT(FACE(J,I))) THEN
                IS_BOUNDARY_POINT(FACE(J,I)) = .TRUE.

                BOUNDARY_NUM = BOUNDARY_NUM + 1
                BOUNDARY_ARRAY(BOUNDARY_NUM) = FACE(J,I)
            END IF
        END DO
    END DO

    B = .TRUE.

    IF(LOCAL_REGION_NUM == BEFORE_LOCAL_REGION_NUM) THEN
        B = .FALSE.
    END IF
    IF(LOCAL_REGION_NUM > LOCAL_REGION_NUM_MAX) THEN
        B = .FALSE.
    END IF

    IF(B) THEN
        BEFORE_LOCAL_REGION_NUM = LOCAL_REGION_NUM
    END IF
    END DO
    
    DEALLOCATE(IS_BOUNDARY_POINT)
    DEALLOCATE(BOUNDARY_ARRAY)

    END SUBROUTINE MAKE_LOCAL_REGION
    
    SUBROUTINE LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, REGION_FLAG, POINT_IDX, LOCAL_CON_NUM, MIN_NUM, MAX_NUM)
        IMPLICIT NONE
        REAL(8) :: TEMPPOINT(:,:)
        INTEGER :: TEMPFACE(:,:)
        INTEGER :: TEMP_CONNECTION_NUM(:)
        INTEGER :: TEMP_CONNECTION(:,:)
        INTEGER :: DIVIDED_REGION_ARRAY(:)
        INTEGER :: REGION_FLAG
        
        INTEGER :: POINT_IDX
        INTEGER :: LOCAL_CON_NUM, MIN_NUM, MAX_NUM
        
        INTEGER :: J, K, I1
        REAL(8) :: V1(3), V2(3), ANGLE, TOTAL_ANGLE, LOCAL_ANGLE
        
        LOCAL_CON_NUM = 0
        TOTAL_ANGLE = 0.
	LOCAL_ANGLE = 0.
        DO J=1,TEMP_CONNECTION_NUM(POINT_IDX)
            I1 = TEMP_CONNECTION(J,POINT_IDX)
            DO K=1,3
                IF(TEMPFACE(K,I1)==POINT_IDX) THEN
                    EXIT
                END IF
            END DO
            V1 = TEMPPOINT(:,TEMPFACE(MOD(K,3)+1,I1)) - TEMPPOINT(:,TEMPFACE(K,I1))
            V2 = TEMPPOINT(:,TEMPFACE(MOD(K+1,3)+1,I1)) - TEMPPOINT(:,TEMPFACE(K,I1))
            
            ANGLE = ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            TOTAL_ANGLE = TOTAL_ANGLE + ANGLE
            
            IF(DIVIDED_REGION_ARRAY(I1)==REGION_FLAG) THEN
                LOCAL_CON_NUM = LOCAL_CON_NUM + 1
                LOCAL_ANGLE = LOCAL_ANGLE + ANGLE
            END IF
        END DO
        
        IF(LOCAL_CON_NUM == TEMP_CONNECTION_NUM(POINT_IDX)) THEN
            MIN_NUM = MAX(NINT(LOCAL_ANGLE / (PI/180. * 90.)), 4)
            MAX_NUM = CEILING(LOCAL_ANGLE / (PI/180. * 45.))
        ELSE
            MIN_NUM = MAX(NINT(LOCAL_ANGLE / (PI/180. * 90.)), NINT(4. * LOCAL_ANGLE/TOTAL_ANGLE), 1)
            MAX_NUM = CEILING(LOCAL_ANGLE / (PI/180. * 45.))
        END IF
    END SUBROUTINE
    
    SUBROUTINE LOCAL_REGION_FLIPPING(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, FLAG)
    IMPLICIT NONE
    INTEGER :: TEMP_POINT_NUM
    REAL(8) :: TEMPPOINT(:,:)
    INTEGER :: TEMP_FACE_NUM
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    INTEGER :: TEMPINITIALPOINT_TYPE(:)
    REAL(8) :: TEMP_NEWEDGELENGTH(:,:)
    REAL(8) :: TEMP_NEWFACEAREA(:)
    INTEGER :: LOCAL_REGION_ARRAY(:), LOCAL_REGION_NUM
    LOGICAL :: IS_INTERIOR_POINT(:)
    LOGICAL :: LOCAL_REGION_FACES(:)
    INTEGER :: DIVIDED_REGION_ARRAY(:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    LOGICAL, OPTIONAL :: FLAG
    INTEGER :: LL
    LOGICAL :: B
    INTEGER :: ITER, I, K, I1, SMOOTHING_NUM
    
    REAL(8) :: QUALITY_AFTER
    
    !INTEGER :: DEG_TOTAL
    !REAL(8) :: QUALITY_TOTAL
    
    SMOOTHING_NUM = 1


    LL = 0
    B = .TRUE.
    DO WHILE(B .AND. LL<30)

    DO I=1,SMOOTHING_NUM
        CALL AREA_BASED_NULLSPACE_SMOOTHING(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, TEMP_NEWFACEAREA, IS_INTERIOR_POINT)
    END DO

    B = .FALSE.
    DO ITER=1,LOCAL_REGION_NUM
        I = LOCAL_REGION_ARRAY(ITER)
        DO K=1,3
            CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)
            
            IF(LOCAL_REGION_FACES(I) .AND. LOCAL_REGION_FACES(I1)) THEN
            
            CALL FLIPPING_AVAILABLE_QUALITY(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    B, QUALITY_AFTER)
            IF(B) THEN
                CALL EDGE_FLIPPING_PROCESS_ONE(TEMPFACE, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_CONNECTION, TEMP_CONNECTION_NUM, I, K, DIVIDED_BOUNDARY_ARRAY = DIVIDED_BOUNDARY_ARRAY)
                
                IF(PRESENT(FLAG)) THEN
                    FLAG = .TRUE.
                END IF
                
                CALL QUALITY_PRINT(TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, DIVIDED_BOUNDARY_ARRAY)
                !CALL DEGREE_LEAST_SQUARE(TEMP_POINT_NUM, TEMP_CONNECTION_NUM, DEG_TOTAL)
                !CALL QUALITY_LEAST_SQUARE(TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_NEWFACEAREA, QUALITY_TOTAL)
                !WRITE(*,*) 'DEG :', DEG_TOTAL, 'QUALITY : ', QUALITY_TOTAL
                EXIT
            END IF

            END IF
        END DO
        !END IF
    END DO
    
    LL = LL + 1
    END DO


    END SUBROUTINE LOCAL_REGION_FLIPPING

    
    
    SUBROUTINE SPL_COL_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, I, K, I1,    B)
    IMPLICIT NONE
    REAL(8) :: TEMPPOINT(:,:)
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: I, J, K, L, I1, II, POINT_IDX1, POINT_IDX2, POINT_IDX3, POINT_IDX4
    REAL(8) :: S, S1, F_SIZE_SHAPE, F_SIZE, F_SHAPE, F_SIZE_SHAPE1, F_SIZE1, F_SHAPE1, S_NEW, S1_NEW, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW, F_SIZE_SHAPE1_NEW, F_SIZE1_NEW, F_SHAPE1_NEW, QUALITY_BEFORE, QUALITY_AFTER, NEWPOINT(3)
    INTEGER :: NUM_BEFORE, NUM_AFTER
    LOGICAL :: B
    
    B = .FALSE.
    NUM_BEFORE = 0
    NUM_AFTER = 0

    POINT_IDX1 = TEMPFACE(MOD(K+3-2, 3) + 1, I)

    POINT_IDX2 = TEMPFACE(K, I)

    DO J=1,3
        IF(TEMPFACE(J,I1)==POINT_IDX2) THEN
            POINT_IDX3 = TEMPFACE(MOD(J,3) + 1, I1)
            EXIT
        END IF
    END DO

    POINT_IDX4 = TEMPFACE(MOD(K,3) + 1, I)

    S = 1.
    S1 = 1.

    CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX3), TEMPPOINT(:,POINT_IDX4), S1, F_SIZE_SHAPE1, F_SIZE1, F_SHAPE1)

    QUALITY_BEFORE = 1./(F_SHAPE1+MINERROR)**2
    NUM_BEFORE = NUM_BEFORE + 1
    
    DO L=1, TEMP_CONNECTION_NUM(POINT_IDX1)
        II = TEMP_CONNECTION(L,POINT_IDX1)
        CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,II)), TEMPPOINT(:,TEMPFACE(2,II)), TEMPPOINT(:,TEMPFACE(3,II)), S, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
        QUALITY_BEFORE = QUALITY_BEFORE + 1./(F_SHAPE+MINERROR)**2
        NUM_BEFORE = NUM_BEFORE + 1
    END DO

    S_NEW = 1.
    S1_NEW = 1.

    NEWPOINT = (TEMPPOINT(:,POINT_IDX2)+TEMPPOINT(:,POINT_IDX4))/2.

    CALL MESH_QUALITY_TRIANGLE_ONE(NEWPOINT, TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX3), S_NEW, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
    CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX3), TEMPPOINT(:,POINT_IDX4), NEWPOINT, S1_NEW, F_SIZE_SHAPE1_NEW, F_SIZE1_NEW, F_SHAPE1_NEW)

    QUALITY_AFTER = 1./(F_SHAPE_NEW+MINERROR)**2 + 1./(F_SHAPE1_NEW+MINERROR)**2
    NUM_AFTER = NUM_AFTER + 1

    DO L=1, TEMP_CONNECTION_NUM(POINT_IDX1)
        II = TEMP_CONNECTION(L,POINT_IDX1)
        IF(II.NE.I) THEN
            IF(TEMPFACE(1,II)==POINT_IDX1) THEN
                CALL MESH_QUALITY_TRIANGLE_ONE(NEWPOINT, TEMPPOINT(:,TEMPFACE(2,II)), TEMPPOINT(:,TEMPFACE(3,II)), S, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
            ELSE IF(TEMPFACE(2,II)==POINT_IDX1) THEN
                CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,II)), NEWPOINT, TEMPPOINT(:,TEMPFACE(3,II)), S, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
            ELSE
                CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,II)), TEMPPOINT(:,TEMPFACE(2,II)), NEWPOINT, S, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
            END IF
        END IF
        QUALITY_AFTER = QUALITY_AFTER + 1./(F_SHAPE+MINERROR)**2
        NUM_AFTER = NUM_AFTER + 1
    END DO
    
    QUALITY_BEFORE = QUALITY_BEFORE / REAL(NUM_BEFORE)
    QUALITY_AFTER = QUALITY_AFTER / REAL(NUM_AFTER)
    
    IF(QUALITY_AFTER < QUALITY_BEFORE .AND. QUALITY_AFTER < 100. .AND. TEMP_CONNECTION_NUM(POINT_IDX2)>=5 .AND. TEMP_CONNECTION_NUM(POINT_IDX4)>=5) THEN
        B = .TRUE.
    END IF

    END SUBROUTINE SPL_COL_AVAILABLE
    
    SUBROUTINE SMOOTHING_AVAILABLE_QUALITY(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, POINT_INDEX,    B, QUALITY_AFTER, V)
        IMPLICIT NONE
        REAL(8) :: TEMPPOINT(:,:)
        INTEGER :: TEMPFACE(:,:)
        INTEGER :: TEMP_CONNECTION_NUM(:)
        INTEGER :: TEMP_CONNECTION(:,:)
        INTEGER :: TEMPPOINT_TYPE(:)
        INTEGER :: POINT_INDEX
        LOGICAL :: B
        REAL(8) :: QUALITY_AFTER, V(3)
        
        INTEGER :: L,J1, I
        REAL(8) :: S, F_SIZE_SHAPE, F_SIZE, F_SHAPE, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW
        REAL(8) :: QUALITY_BEFORE
        INTEGER :: NUM_BEFORE, NUM_AFTER
        
        B = .FALSE.
        NUM_BEFORE = 0
        NUM_AFTER = 0
        QUALITY_BEFORE = 0.
        QUALITY_AFTER = 0.
        V(:) = 0.
        IF(TEMPPOINT_TYPE(POINT_INDEX)==1) THEN
            DO L=1,TEMP_CONNECTION_NUM(POINT_INDEX)
                CALL POINT_NEIGHBOR_POINT(TEMPFACE, TEMP_CONNECTION, POINT_INDEX, L, J1)
                V = V + TEMPPOINT(:,J1)/REAL(TEMP_CONNECTION_NUM(POINT_INDEX))
            END DO
            
            DO L=1,TEMP_CONNECTION_NUM(POINT_INDEX)
                I = TEMP_CONNECTION(L,POINT_INDEX)
                S = 1.
                CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,I)), TEMPPOINT(:,TEMPFACE(2,I)), TEMPPOINT(:,TEMPFACE(3,I)), S, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
                QUALITY_BEFORE = QUALITY_BEFORE + 1./(F_SHAPE+MINERROR)**2
                NUM_BEFORE = NUM_BEFORE + 1
                
                IF(TEMPFACE(1,I)==POINT_INDEX) THEN
                    CALL MESH_QUALITY_TRIANGLE_ONE(V, TEMPPOINT(:,TEMPFACE(2,I)), TEMPPOINT(:,TEMPFACE(3,I)), S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
                ELSE IF(TEMPFACE(2,I)==POINT_INDEX) THEN
                    CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,I)), V, TEMPPOINT(:,TEMPFACE(3,I)), S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
                ELSE
                    CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,I)), TEMPPOINT(:,TEMPFACE(2,I)), V, S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
                END IF
                QUALITY_AFTER = QUALITY_AFTER + 1./(F_SHAPE_NEW+MINERROR)**2
                NUM_AFTER = NUM_AFTER + 1
            END DO
            
            QUALITY_BEFORE = QUALITY_BEFORE / REAL(NUM_BEFORE)
            QUALITY_AFTER = QUALITY_AFTER / REAL(NUM_AFTER)
            
            IF(QUALITY_AFTER < QUALITY_BEFORE) THEN ! .AND. QUALITY_AFTER < 100.) THEN
                B = .TRUE.
            END IF
        ELSE
            QUALITY_AFTER = 10000.
        END IF
        
    END SUBROUTINE SMOOTHING_AVAILABLE_QUALITY
    
    SUBROUTINE SPLITTING_AVAILABLE_QUALITY(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    B, QUALITY_AFTER)
        IMPLICIT NONE
        REAL(8) :: TEMPPOINT(:,:)
        INTEGER :: TEMPFACE(:,:)
        INTEGER :: TEMP_CONNECTION_NUM(:)
        INTEGER :: TEMP_CONNECTION(:,:)
        INTEGER :: TEMPPOINT_TYPE(:)
        INTEGER :: TEMPINITIALPOINT_TYPE(:)
        INTEGER :: DIVIDED_REGION_ARRAY(:)
        INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
        INTEGER :: I, K, I1
        LOGICAL :: B
        REAL(8) :: QUALITY_AFTER
        
        INTEGER :: J, POINT_IDX1, POINT_IDX2, POINT_IDX3, POINT_IDX4
        REAL(8) :: S, S1, F_SIZE_SHAPE, F_SIZE, F_SHAPE, F_SIZE_SHAPE1, F_SIZE1, F_SHAPE1, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW, QUALITY_BEFORE, XYZN(3)
        
        INTEGER :: NUM_BEFORE, NUM_AFTER
        
        B = .FALSE.
        
        NUM_BEFORE = 0
        NUM_AFTER = 0
        
        CALL SPLITTING_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    B)
        
        IF(B) THEN
        
        POINT_IDX1 = TEMPFACE(MOD(K+3-2, 3) + 1, I)
        
        POINT_IDX2 = TEMPFACE(K, I)
        
        DO J=1,3
            IF(TEMPFACE(J,I1)==POINT_IDX2) THEN
                POINT_IDX3 = TEMPFACE(MOD(J,3) + 1, I1)
                EXIT
            END IF
        END DO
        
        POINT_IDX4 = TEMPFACE(MOD(K,3) + 1, I)
        
        XYZN = (TEMPPOINT(:,POINT_IDX2)+TEMPPOINT(:,POINT_IDX4))/2.
        
        QUALITY_BEFORE = 0.
        QUALITY_AFTER = 0.
        
        S = 1.
        S1 = 1.
        
        CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX1), TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX4), S, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
        CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX3), TEMPPOINT(:,POINT_IDX4), S1, F_SIZE_SHAPE1, F_SIZE1, F_SHAPE1)
        
        QUALITY_BEFORE = 1./(F_SHAPE+MINERROR)**2 + 1./(F_SHAPE1+MINERROR)**2
        NUM_BEFORE = NUM_BEFORE + 2
        
        QUALITY_AFTER = 0.
        
        CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX1), TEMPPOINT(:,POINT_IDX2), XYZN, S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
        
        QUALITY_AFTER = QUALITY_AFTER + 1./(F_SHAPE_NEW+MINERROR)**2
        NUM_AFTER = NUM_AFTER + 1
        
        CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX3), XYZN, S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
        
        QUALITY_AFTER = QUALITY_AFTER + 1./(F_SHAPE_NEW+MINERROR)**2
        NUM_AFTER = NUM_AFTER + 1
        
        CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX3), TEMPPOINT(:,POINT_IDX4), XYZN, S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
        
        QUALITY_AFTER = QUALITY_AFTER + 1./(F_SHAPE_NEW+MINERROR)**2
        NUM_AFTER = NUM_AFTER + 1
        
        CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX4), TEMPPOINT(:,POINT_IDX1), XYZN, S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
        
        QUALITY_AFTER = QUALITY_AFTER + 1./(F_SHAPE_NEW+MINERROR)**2
        NUM_AFTER = NUM_AFTER + 1
        
        QUALITY_BEFORE = QUALITY_BEFORE / REAL(NUM_BEFORE)
        QUALITY_AFTER = QUALITY_AFTER / REAL(NUM_AFTER)
        
        IF(QUALITY_AFTER < QUALITY_BEFORE) THEN ! .AND. QUALITY_AFTER < 100.) THEN
            B = .TRUE.
        END IF
        
        ELSE
            QUALITY_AFTER = 10000.
        END IF
        
    END SUBROUTINE
    
    SUBROUTINE COLLAPSING_AVAILABLE_QUALITY(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    B, QUALITY_AFTER)
        IMPLICIT NONE
        REAL(8) :: TEMPPOINT(:,:)
        INTEGER :: TEMPFACE(:,:)
        INTEGER :: TEMP_CONNECTION_NUM(:)
        INTEGER :: TEMP_CONNECTION(:,:)
        INTEGER :: TEMPPOINT_TYPE(:)
        INTEGER :: TEMPINITIALPOINT_TYPE(:)
        INTEGER :: DIVIDED_REGION_ARRAY(:)
        INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
        INTEGER :: I, K, I1
        LOGICAL :: B
        REAL(8) :: QUALITY_AFTER
        
        INTEGER :: J, L, II, POINT_IDX1, POINT_IDX2, POINT_IDX3, POINT_IDX4
        REAL(8) :: S, S1, F_SIZE_SHAPE, F_SIZE, F_SHAPE, F_SIZE_SHAPE1, F_SIZE1, F_SHAPE1, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW, QUALITY_BEFORE, N(3), N_NEW(3), XYZC(3), XYZN(3)
        INTEGER :: NUM_BEFORE, NUM_AFTER
        
        B = .FALSE.
        
        NUM_BEFORE = 0
        NUM_AFTER = 0
        
        CALL COLLAPSING_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    B)
        
        IF(B) THEN
        
        POINT_IDX1 = TEMPFACE(MOD(K+3-2, 3) + 1, I)
        
        POINT_IDX2 = TEMPFACE(K, I)
        
        DO J=1,3
            IF(TEMPFACE(J,I1)==POINT_IDX2) THEN
                POINT_IDX3 = TEMPFACE(MOD(J,3) + 1, I1)
                EXIT
            END IF
        END DO
        
        POINT_IDX4 = TEMPFACE(MOD(K,3) + 1, I)
        
        XYZC = (TEMPPOINT(:,POINT_IDX2)+TEMPPOINT(:,POINT_IDX4))/2.
        
        IF(TEMPPOINT_TYPE(POINT_IDX2) > TEMPPOINT_TYPE(POINT_IDX4)) THEN
            XYZN = TEMPPOINT(:,POINT_IDX2)
        ELSE IF(TEMPPOINT_TYPE(POINT_IDX4) > TEMPPOINT_TYPE(POINT_IDX2)) THEN
            XYZN = TEMPPOINT(:,POINT_IDX4)
        ELSE IF(TEMPINITIALPOINT_TYPE(POINT_IDX2) > TEMPINITIALPOINT_TYPE(POINT_IDX4)) THEN
            XYZN = TEMPPOINT(:,POINT_IDX2)
        ELSE IF(TEMPINITIALPOINT_TYPE(POINT_IDX4) > TEMPINITIALPOINT_TYPE(POINT_IDX2)) THEN
            XYZN = TEMPPOINT(:,POINT_IDX4)
        ELSE
            XYZN = XYZC
        END IF
        
        QUALITY_BEFORE = 0.
        QUALITY_AFTER = 0.
        
        S = 1.
        S1 = 1.
        
        CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX1), TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX4), S, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
        CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX3), TEMPPOINT(:,POINT_IDX4), S1, F_SIZE_SHAPE1, F_SIZE1, F_SHAPE1)
        
        QUALITY_BEFORE = 1./(F_SHAPE+MINERROR)**2 + 1./(F_SHAPE1+MINERROR)**2
        NUM_BEFORE = NUM_BEFORE + 2
        
        DO L=1,TEMP_CONNECTION_NUM(POINT_IDX2)
            II = TEMP_CONNECTION(L,POINT_IDX2)
            
            IF(II.NE.I .AND. II.NE.I1) THEN
                CALL TRIANGLE_NORMAL(TEMPPOINT(:,TEMPFACE(1,II)), TEMPPOINT(:,TEMPFACE(2,II)), TEMPPOINT(:,TEMPFACE(3,II)), N)
                CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,II)), TEMPPOINT(:,TEMPFACE(2,II)), TEMPPOINT(:,TEMPFACE(3,II)), S, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
                QUALITY_BEFORE = QUALITY_BEFORE + 1./(F_SHAPE+MINERROR)**2
                NUM_BEFORE = NUM_BEFORE + 1
                
                IF(TEMPFACE(1,II)==POINT_IDX2) THEN
                    CALL TRIANGLE_NORMAL(XYZN, TEMPPOINT(:,TEMPFACE(2,II)), TEMPPOINT(:,TEMPFACE(3,II)), N_NEW)
                    CALL MESH_QUALITY_TRIANGLE_ONE(XYZN, TEMPPOINT(:,TEMPFACE(2,II)), TEMPPOINT(:,TEMPFACE(3,II)), S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
                ELSE IF(TEMPFACE(2,II)==POINT_IDX2) THEN
                    CALL TRIANGLE_NORMAL(TEMPPOINT(:,TEMPFACE(1,II)), XYZN, TEMPPOINT(:,TEMPFACE(3,II)), N_NEW)
                    CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,II)), XYZN, TEMPPOINT(:,TEMPFACE(3,II)), S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
                ELSE
                    CALL TRIANGLE_NORMAL(TEMPPOINT(:,TEMPFACE(1,II)), TEMPPOINT(:,TEMPFACE(2,II)), XYZN, N_NEW)
                    CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,II)), TEMPPOINT(:,TEMPFACE(2,II)), XYZN, S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
                END IF
                
                IF(DOT_PRODUCT(N, N_NEW) < 0.) THEN
                    F_SHAPE_NEW = 0.
                END IF
                
                QUALITY_AFTER = QUALITY_AFTER + 1./(F_SHAPE_NEW+MINERROR)**2
                NUM_AFTER = NUM_AFTER + 1
            END IF
        END DO
        
        DO L=1,TEMP_CONNECTION_NUM(POINT_IDX4)
            II = TEMP_CONNECTION(L,POINT_IDX4)
            
            IF(II.NE.I .AND. II.NE.I1) THEN
                CALL TRIANGLE_NORMAL(TEMPPOINT(:,TEMPFACE(1,II)), TEMPPOINT(:,TEMPFACE(2,II)), TEMPPOINT(:,TEMPFACE(3,II)), N)
                CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,II)), TEMPPOINT(:,TEMPFACE(2,II)), TEMPPOINT(:,TEMPFACE(3,II)), S, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
                QUALITY_BEFORE = QUALITY_BEFORE + 1./(F_SHAPE+MINERROR)**2
                NUM_BEFORE = NUM_BEFORE + 1
                
                IF(TEMPFACE(1,II)==POINT_IDX4) THEN
                    CALL TRIANGLE_NORMAL(XYZN, TEMPPOINT(:,TEMPFACE(2,II)), TEMPPOINT(:,TEMPFACE(3,II)), N_NEW)
                    CALL MESH_QUALITY_TRIANGLE_ONE(XYZN, TEMPPOINT(:,TEMPFACE(2,II)), TEMPPOINT(:,TEMPFACE(3,II)), S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
                ELSE IF(TEMPFACE(2,II)==POINT_IDX4) THEN
                    CALL TRIANGLE_NORMAL(TEMPPOINT(:,TEMPFACE(1,II)), XYZN, TEMPPOINT(:,TEMPFACE(3,II)), N_NEW)
                    CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,II)), XYZN, TEMPPOINT(:,TEMPFACE(3,II)), S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
                ELSE
                    CALL TRIANGLE_NORMAL(TEMPPOINT(:,TEMPFACE(1,II)), TEMPPOINT(:,TEMPFACE(2,II)), XYZN, N_NEW)
                    CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,II)), TEMPPOINT(:,TEMPFACE(2,II)), XYZN, S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
                END IF
                
                IF(DOT_PRODUCT(N, N_NEW) < 0.) THEN
                    F_SHAPE_NEW = 0.
                END IF
                
                QUALITY_AFTER = QUALITY_AFTER + 1./(F_SHAPE_NEW+MINERROR)**2
                NUM_AFTER = NUM_AFTER + 1
            END IF
        END DO
        
        QUALITY_BEFORE = QUALITY_BEFORE / REAL(NUM_BEFORE)
        QUALITY_AFTER = QUALITY_AFTER / REAL(NUM_AFTER)
        
        IF(QUALITY_AFTER < QUALITY_BEFORE) THEN ! .AND. QUALITY_AFTER < 100.) THEN
            B = .TRUE.
        END IF
        
        ELSE
            QUALITY_AFTER = 10000.
        END IF
        
    END SUBROUTINE
    
    
    SUBROUTINE FLIPPING_AVAILABLE_QUALITY(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    B, QUALITY_AFTER)
    IMPLICIT NONE
    REAL(8) :: TEMPPOINT(:,:)
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: DIVIDED_REGION_ARRAY(:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    
    INTEGER :: I, J, K, I1, POINT_IDX1, POINT_IDX2, POINT_IDX3, POINT_IDX4
    LOGICAL :: B
    REAL(8) :: S, S1, F_SIZE_SHAPE, F_SIZE, F_SHAPE, F_SIZE_SHAPE1, F_SIZE1, F_SHAPE1, S_NEW, S1_NEW, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW, F_SIZE_SHAPE1_NEW, F_SIZE1_NEW, F_SHAPE1_NEW, QUALITY_BEFORE, QUALITY_AFTER, N(3), N1(3), N_NEW(3), N1_NEW(3)
    INTEGER :: LOCAL_CON_NUM1, MIN_NUM1, MAX_NUM1, LOCAL_CON_NUM2, MIN_NUM2, MAX_NUM2, LOCAL_CON_NUM3, MIN_NUM3, MAX_NUM3, LOCAL_CON_NUM4, MIN_NUM4, MAX_NUM4
    
    INTEGER :: NUM_BEFORE, NUM_AFTER
    
    B = .FALSE.
    NUM_BEFORE = 0
    NUM_AFTER = 0
    
    IF(DIVIDED_BOUNDARY_ARRAY(K,I)==0) THEN
    
    POINT_IDX1 = TEMPFACE(MOD(K+3-2, 3) + 1, I)
    POINT_IDX2 = TEMPFACE(K, I)
    DO J=1,3
        IF(TEMPFACE(J,I1)==POINT_IDX2) THEN
            POINT_IDX3 = TEMPFACE(MOD(J,3) + 1, I1)
            EXIT
        END IF
    END DO
    POINT_IDX4 = TEMPFACE(MOD(K,3) + 1, I)
    
    S = 1.
    S1 = 1.
    
    CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX1), TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX4), S, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
    CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX3), TEMPPOINT(:,POINT_IDX4), S1, F_SIZE_SHAPE1, F_SIZE1, F_SHAPE1)
    
    CALL TRIANGLE_NORMAL(TEMPPOINT(:,POINT_IDX1), TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX4), N)
    CALL TRIANGLE_NORMAL(TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX3), TEMPPOINT(:,POINT_IDX4), N1)
    
    S_NEW = 1.
    S1_NEW = 1.
    
    CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX1), TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX3), S_NEW, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
    CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,POINT_IDX3), TEMPPOINT(:,POINT_IDX4), TEMPPOINT(:,POINT_IDX1), S1_NEW, F_SIZE_SHAPE1_NEW, F_SIZE1_NEW, F_SHAPE1_NEW)
    
    CALL TRIANGLE_NORMAL(TEMPPOINT(:,POINT_IDX1), TEMPPOINT(:,POINT_IDX2), TEMPPOINT(:,POINT_IDX3), N_NEW)
    CALL TRIANGLE_NORMAL(TEMPPOINT(:,POINT_IDX3), TEMPPOINT(:,POINT_IDX4), TEMPPOINT(:,POINT_IDX1), N1_NEW)
    
    IF(DOT_PRODUCT(N,N1)<0) THEN
        F_SHAPE = 0.
        F_SHAPE1 = 0.
    END IF
    IF(DOT_PRODUCT(N_NEW,N1_NEW)<0) THEN
        F_SHAPE_NEW = 0.
        F_SHAPE1_NEW = 0.
    END IF
    
    QUALITY_BEFORE = 1./(F_SHAPE+MINERROR) + 1./(F_SHAPE1+MINERROR)
    NUM_BEFORE = NUM_BEFORE + 2
    QUALITY_AFTER = 1./(F_SHAPE_NEW+MINERROR) + 1./(F_SHAPE1_NEW+MINERROR)
    NUM_AFTER = NUM_AFTER + 2
    
    QUALITY_BEFORE = QUALITY_BEFORE / REAL(NUM_BEFORE)
    QUALITY_AFTER = QUALITY_AFTER / REAL(NUM_AFTER)
    
    CALL LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_ARRAY(I), POINT_IDX1, LOCAL_CON_NUM1, MIN_NUM1, MAX_NUM1)
    CALL LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_ARRAY(I), POINT_IDX2, LOCAL_CON_NUM2, MIN_NUM2, MAX_NUM2)
    CALL LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_ARRAY(I), POINT_IDX3, LOCAL_CON_NUM3, MIN_NUM3, MAX_NUM3)
    CALL LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_ARRAY(I), POINT_IDX4, LOCAL_CON_NUM4, MIN_NUM4, MAX_NUM4)

    IF(QUALITY_AFTER<QUALITY_BEFORE .AND. QUALITY_AFTER < 100. .AND. LOCAL_CON_NUM2 > MIN_NUM2 .AND. LOCAL_CON_NUM4 > MIN_NUM4 .AND. LOCAL_CON_NUM1 < MAX_NUM1 .AND. LOCAL_CON_NUM3 < MAX_NUM3) THEN
        B = .TRUE.
    END IF
    
    END IF
    
    IF(.NOT. B) THEN
        QUALITY_AFTER = 10000.
    END IF
    
    END SUBROUTINE FLIPPING_AVAILABLE_QUALITY
    
    
    SUBROUTINE SPLITTING_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    B)
    IMPLICIT NONE
    REAL(8) :: TEMPPOINT(:,:)
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: DIVIDED_REGION_ARRAY(:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER :: I, J, K, I1, POINT_IDX1, POINT_IDX2, POINT_IDX3, POINT_IDX4
    LOGICAL :: B, C
    
    INTEGER :: LOCAL_CON_NUM, MIN_NUM, MAX_NUM

    B = .FALSE.

    POINT_IDX1 = TEMPFACE(MOD(K+3-2, 3) + 1, I)
    POINT_IDX2 = TEMPFACE(K, I)
    DO J=1,3
        IF(TEMPFACE(J,I1)==POINT_IDX2) THEN
            POINT_IDX3 = TEMPFACE(MOD(J,3) + 1, I1)
            EXIT
        END IF
    END DO
    POINT_IDX4 = TEMPFACE(MOD(K,3) + 1, I)
    
    C = .TRUE.
    
    CALL LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_ARRAY(I), POINT_IDX1, LOCAL_CON_NUM, MIN_NUM, MAX_NUM)
    IF(LOCAL_CON_NUM >= MAX_NUM) THEN
        C = .FALSE.
    END IF
    
    CALL LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_ARRAY(I1), POINT_IDX3, LOCAL_CON_NUM, MIN_NUM, MAX_NUM)
    IF(LOCAL_CON_NUM >= MAX_NUM) THEN
        C = .FALSE.
    END IF
    
    IF(C) THEN
    
    IF(.NOT. (DIVIDED_BOUNDARY_ARRAY(MOD(K,3) + 1, I) .NE. 0 .AND. DIVIDED_BOUNDARY_ARRAY(MOD(J,3) + 1, I1) .NE. 0) .AND. .NOT. (DIVIDED_BOUNDARY_ARRAY(MOD(K+3-2,3) + 1, I) .NE. 0 .AND. DIVIDED_BOUNDARY_ARRAY(J, I1) .NE. 0)) THEN
        B = .TRUE.
    END IF
    
    END IF

    END SUBROUTINE SPLITTING_AVAILABLE

    
    
    SUBROUTINE COLLAPSING_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    B)
    IMPLICIT NONE
    REAL(8) :: TEMPPOINT(:,:)
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: DIVIDED_REGION_ARRAY(:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER :: I, J, K, I1, POINT_IDX1, POINT_IDX2, POINT_IDX3, POINT_IDX4
    INTEGER :: L1, L2, L3, L4, II1, II2, II3, II4
    LOGICAL :: B, C
    
    INTEGER :: LOCAL_CON_NUM, MIN_NUM, MAX_NUM, LOCAL_CON_NUM1, MIN_NUM1, MAX_NUM1, LOCAL_CON_NUM2, MIN_NUM2, MAX_NUM2

    B = .FALSE.

    POINT_IDX1 = TEMPFACE(MOD(K+3-2, 3) + 1, I)
    POINT_IDX2 = TEMPFACE(K, I)
    DO J=1,3
        IF(TEMPFACE(J,I1)==POINT_IDX2) THEN
            POINT_IDX3 = TEMPFACE(MOD(J,3) + 1, I1)
            EXIT
        END IF
    END DO
    POINT_IDX4 = TEMPFACE(MOD(K,3) + 1, I)
    
    C = .TRUE.
    
    CALL LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_ARRAY(I), POINT_IDX1, LOCAL_CON_NUM, MIN_NUM, MAX_NUM)
    IF(LOCAL_CON_NUM <= MIN_NUM) THEN
        C = .FALSE.
    END IF
    
    CALL LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_ARRAY(I1), POINT_IDX3, LOCAL_CON_NUM, MIN_NUM, MAX_NUM)
    IF(LOCAL_CON_NUM <= MIN_NUM) THEN
        C = .FALSE.
    END IF
    
    CALL LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_ARRAY(I), POINT_IDX2, LOCAL_CON_NUM1, MIN_NUM1, MAX_NUM1)
    CALL LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_ARRAY(I), POINT_IDX4, LOCAL_CON_NUM2, MIN_NUM2, MAX_NUM2)
    IF(LOCAL_CON_NUM1 + LOCAL_CON_NUM2 - 4 >= MAX(MAX_NUM1, MAX_NUM2)) THEN
        C = .FALSE.
    END IF
    
    CALL LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_ARRAY(I1), POINT_IDX2, LOCAL_CON_NUM1, MIN_NUM1, MAX_NUM1)
    CALL LOCAL_REGION_PROPER_CONNECTION_NUM(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_ARRAY(I1), POINT_IDX4, LOCAL_CON_NUM2, MIN_NUM2, MAX_NUM2)
    IF(LOCAL_CON_NUM1 + LOCAL_CON_NUM2 - 4 >= MAX(MAX_NUM1, MAX_NUM2)) THEN
        C = .FALSE.
    END IF
    
    IF(C) THEN
    
    IF(DIVIDED_BOUNDARY_ARRAY(MOD(K,3) + 1, I) == 0 .AND. DIVIDED_BOUNDARY_ARRAY(MOD(K+3-2,3) + 1, I) == 0 .AND. DIVIDED_BOUNDARY_ARRAY(MOD(J,3) + 1, I1) == 0 .AND. DIVIDED_BOUNDARY_ARRAY(J, I1) == 0) THEN
        B = .TRUE.
    ELSE IF(.NOT. (DIVIDED_BOUNDARY_ARRAY(MOD(K,3) + 1, I) .NE. 0 .AND. DIVIDED_BOUNDARY_ARRAY(MOD(K+3-2,3) + 1, I) .NE. 0) .AND. .NOT. (DIVIDED_BOUNDARY_ARRAY(MOD(J,3) + 1, I1) .NE. 0 .AND. DIVIDED_BOUNDARY_ARRAY(J, I1) .NE. 0)) THEN

    CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I,MOD(K+3-2, 3) + 1, II1)
    CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I1,J, II2)
    CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I1,MOD(J,3) + 1, II3)
    CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I,MOD(K,3) + 1, II4)
    
    DO L1=1,3
        IF(TEMPFACE(L1,II1)==POINT_IDX2) THEN
            EXIT
        END IF
    END DO

    DO L2=1,3
        IF(TEMPFACE(L2,II2)==POINT_IDX3) THEN
            EXIT
        END IF
    END DO

    DO L3=1,3
        IF(TEMPFACE(L3,II3)==POINT_IDX4) THEN
            EXIT
        END IF
    END DO

    DO L4=1,3
        IF(TEMPFACE(L4,II4)==POINT_IDX1) THEN
            EXIT
        END IF
    END DO

    IF(.NOT. (DIVIDED_BOUNDARY_ARRAY(MOD(K,3) + 1, I) .NE. 0 .AND. DIVIDED_BOUNDARY_ARRAY(MOD(L1,3) + 1, II1) == DIVIDED_BOUNDARY_ARRAY(MOD(K,3) + 1, I)) .AND. .NOT. (DIVIDED_BOUNDARY_ARRAY(MOD(K+3-2,3) + 1, I) .NE. 0 .AND. DIVIDED_BOUNDARY_ARRAY(MOD(L4+3-2,3) + 1, II4) == DIVIDED_BOUNDARY_ARRAY(MOD(K+3-2,3) + 1, I)) .AND. .NOT. (DIVIDED_BOUNDARY_ARRAY(J, I1) .NE. 0 .AND. DIVIDED_BOUNDARY_ARRAY(MOD(L3,3) + 1, II3) == DIVIDED_BOUNDARY_ARRAY(J, I1)) .AND. .NOT. (DIVIDED_BOUNDARY_ARRAY(MOD(J,3) + 1, I1) .NE. 0 .AND. DIVIDED_BOUNDARY_ARRAY(MOD(L2+3-2,3) + 1, II2) == DIVIDED_BOUNDARY_ARRAY(MOD(J,3) + 1, I1))) THEN
        B = .TRUE.
    END IF
    END IF
    
    END IF
    
    END SUBROUTINE COLLAPSING_AVAILABLE

    
    
    SUBROUTINE REMESHING_PROCESS(TYP, FLAG)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL :: FLAG
    REAL(8) , ALLOCATABLE :: TEMPPOINT(:,:)
    INTEGER, ALLOCATABLE :: TEMPFACE(:,:)
    INTEGER, ALLOCATABLE :: TEMPINITIALPOINT_TYPE(:)
    INTEGER, ALLOCATABLE :: TEMPPOINT_TYPE(:)
    INTEGER, ALLOCATABLE :: TEMP_NEWONINTERFACE(:)
    INTEGER, ALLOCATABLE :: TEMP_NEWLOCATION(:)
    REAL(8), ALLOCATABLE :: TEMP_NEWEDGELENGTH(:,:)
    REAL(8), ALLOCATABLE :: TEMP_NEWFACEAREA(:)
    INTEGER, ALLOCATABLE :: TEMP_ABLATION_FLAG(:)
    INTEGER, ALLOCATABLE :: TEMP_CONNECTION(:,:)
    INTEGER, ALLOCATABLE :: TEMP_CONNECTION_NUM(:)
    INTEGER :: TEMP_POINT_NUM, TEMP_FACE_NUM
    INTEGER, ALLOCATABLE :: DIVIDED_REGION_ARRAY(:)
    INTEGER :: DIVIDED_REGION_NUM
    INTEGER, ALLOCATABLE :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER :: DIVIDED_BOUNDARY_NUM
    REAL(8) :: ONE_REGION_AREA
    REAL(8) :: ONE_REGION_INITIAL_AREA
    REAL(8) :: ONE_BOUNDARY_LENGTH
    REAL(8) :: ONE_BOUNDARY_INITIAL_LENGTH
    INTEGER :: I, J, K, L, I1, J1, ITER, IMAX, IMIN, I1MAX, I1MIN, KMAX, KMIN, SMOOTHING_NUM, FLIP_START, FLIP_START1, FLIP_START2, FLIP_REGION1, FLIP_REGION2, REGION_FACE_NUM
    REAL(8) :: V1(3), V2(3), N(3), AREA, R, RMAX, RMIN, V1_1(3), V2_1(3), N1(3), AREA1, LENGTH, F_SHAPE, F_SIZE, F_SIZE_SHAPE, QUALITY_AFTER
    LOGICAL :: B, BB, C
    INTEGER :: REGION1!, REGION2, REGION3
    !INTEGER :: POINT_IDX1, POINT_IDX2, POINT_IDX3, POINT_IDX4

    !INTEGER :: II1, II2, II3, II4, L1, L2, L3, L4



    INTEGER, ALLOCATABLE :: LOCAL_REGION_ARRAY(:)
    INTEGER :: LOCAL_REGION_NUM
    LOGICAL, ALLOCATABLE :: IS_INTERIOR_POINT(:)
    LOGICAL, ALLOCATABLE :: LOCAL_REGION_FACES(:)

    INTEGER :: POINT_NEW1, POINT_NEW2, POINT_NEW3, POINT_NEW4, POINT_NEW5

    INTEGER :: TEMPTIME

    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    SMOOTHING_NUM = 1

    FLAG = .FALSE.

    ALLOCATE(TEMPPOINT(3,3*SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(TEMPFACE(3,3*SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(TEMPINITIALPOINT_TYPE(3*SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(TEMPPOINT_TYPE(3*SURFACE_CURRENT%SURFACE_POINTS_NUM))

    ALLOCATE(TEMP_NEWONINTERFACE(3*SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(TEMP_NEWLOCATION(3*SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(TEMP_NEWFACEAREA(3*SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(TEMP_NEWEDGELENGTH(3,3*SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(TEMP_ABLATION_FLAG(3*SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(TEMP_CONNECTION(30,3*SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(TEMP_CONNECTION_NUM(3*SURFACE_CURRENT%SURFACE_POINTS_NUM))

    TEMP_POINT_NUM = SURFACE_CURRENT%SURFACE_POINTS_NUM
    TEMP_FACE_NUM = SURFACE_CURRENT%SURFACE_FACES_NUM

    ALLOCATE(DIVIDED_REGION_ARRAY(3*SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(DIVIDED_BOUNDARY_ARRAY(3,3*SURFACE_CURRENT%SURFACE_FACES_NUM))

    !$OMP PARALLEL DO PRIVATE(I)
    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        TEMPPOINT(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
        TEMPINITIALPOINT_TYPE(I) = SURFACE_CURRENT%INITIAL_POINT_TYPE(I)
        TEMPPOINT_TYPE(I) = SURFACE_CURRENT%POINT_TYPE(I)
        TEMP_CONNECTION(:,I) = SURFACE_CURRENT%POINT_FACE_CONNECTION(:,I)
        TEMP_CONNECTION_NUM(I) = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
    END DO
    !$OMP END PARALLEL DO

    !$OMP PARALLEL DO PRIVATE(I)
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        TEMPFACE(:,I) = SURFACE_CURRENT%SURFACE_FACES(:,I)
        TEMP_NEWONINTERFACE(I) = SURFACE_CURRENT%FACE_ONINTERFACE(I)

        IF(TYP==0 .OR. TYP==1) THEN
            TEMP_NEWLOCATION(I) = SURFACE_CURRENT%FACE_LOCATION(I)
        ELSE
            TEMP_NEWLOCATION(I) = 0
        END IF

        TEMP_NEWFACEAREA(I) = SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(I)
        TEMP_NEWEDGELENGTH(:,I) = SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(:,I)
        TEMP_ABLATION_FLAG(I) = SURFACE_CURRENT%FACE_ABLATION_FLAG(I)
    END DO
    !$OMP END PARALLEL DO

    DIVIDED_REGION_ARRAY(:) = 0
    DIVIDED_REGION_NUM = 0

    DIVIDED_BOUNDARY_ARRAY(:,:) = 0
    DIVIDED_BOUNDARY_NUM = 0

    !! TESTTEST !!
    ALLOCATE(LOCAL_REGION_ARRAY(1000))
    LOCAL_REGION_ARRAY(:) = 0
    ALLOCATE(IS_INTERIOR_POINT(3*SURFACE_CURRENT%SURFACE_POINTS_NUM))
    IS_INTERIOR_POINT(:) = .FALSE.
    ALLOCATE(LOCAL_REGION_FACES(3*SURFACE_CURRENT%SURFACE_FACES_NUM))
    LOCAL_REGION_FACES(:) = .FALSE.

    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        DIVIDED_REGION_ARRAY(I) = SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I)
        DIVIDED_BOUNDARY_ARRAY(:,I) = SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(:,I)
    END DO

    DIVIDED_REGION_NUM = SURFACE_CURRENT%FACE_DIVIDED_REGION_NUM
    DIVIDED_BOUNDARY_NUM = SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_NUM

    TEMPTIME = 0





    !! MAIN LOOP !!


    !! 1. length-based splitting and collapsing in ridge region !!


    DO ITER=1,DIVIDED_BOUNDARY_NUM
        B = .FALSE.
        BB = .FALSE.
        
        ONE_BOUNDARY_LENGTH = 0.
        ONE_BOUNDARY_INITIAL_LENGTH = 0.

        RMAX = 0.
        RMIN = 10.

        DO I=1,TEMP_FACE_NUM
            DO K=1,3
                IF(DIVIDED_BOUNDARY_ARRAY(K,I)==ITER) THEN
                    CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)

                    IF(I1>I) THEN

                    V1 = TEMPPOINT(:,TEMPFACE(MOD(K,3)+1,I)) - TEMPPOINT(:,TEMPFACE(K,I))

                    LENGTH = SQRT(DOT_PRODUCT(V1,V1))

                    ONE_BOUNDARY_LENGTH = ONE_BOUNDARY_LENGTH + LENGTH
                    ONE_BOUNDARY_INITIAL_LENGTH = ONE_BOUNDARY_INITIAL_LENGTH + TEMP_NEWEDGELENGTH(K,I)

                    R = LENGTH/TEMP_NEWEDGELENGTH(K,I)
                    
                    CALL SPLITTING_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    C)

                    IF(C) THEN
                        IF(R>RMAX) THEN
                            RMAX = R
                            IMAX = I
                            I1MAX = I1
                            KMAX = K
                        END IF
                    END IF

                    CALL COLLAPSING_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    C)

                    IF(C) THEN
                        IF(R<RMIN) THEN
                            RMIN = R
                            IMIN = I
                            I1MIN = I1
                            KMIN = K
                        END IF
                    END IF

                    END IF
                END IF
            END DO
        END DO

        IF(ONE_BOUNDARY_LENGTH > ONE_BOUNDARY_INITIAL_LENGTH * 1.05 .OR. ONE_BOUNDARY_LENGTH < ONE_BOUNDARY_INITIAL_LENGTH / 1.05) THEN
            B = .TRUE.
            BB = .TRUE.
        END IF
        
        IF(RMAX > 2. .OR. RMIN < 0.5) THEN
            B = .TRUE.
        END IF
        
        DO WHILE(B)

        RMAX = 0.
        RMIN = 10.

        IMAX = 0
        IMIN = 0

        ONE_BOUNDARY_LENGTH = 0.
        ONE_BOUNDARY_INITIAL_LENGTH = 0.

        DO I=1,TEMP_FACE_NUM
            DO K=1,3
                IF(DIVIDED_BOUNDARY_ARRAY(K,I)==ITER) THEN
                    CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)

                    IF(I1>I) THEN

                    V1 = TEMPPOINT(:,TEMPFACE(MOD(K,3)+1,I)) - TEMPPOINT(:,TEMPFACE(K,I))

                    LENGTH = SQRT(DOT_PRODUCT(V1,V1))

                    ONE_BOUNDARY_LENGTH = ONE_BOUNDARY_LENGTH + LENGTH
                    ONE_BOUNDARY_INITIAL_LENGTH = ONE_BOUNDARY_INITIAL_LENGTH + TEMP_NEWEDGELENGTH(K,I)

                    R = LENGTH/TEMP_NEWEDGELENGTH(K,I)

                    CALL SPLITTING_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    C)

                    IF(C) THEN
                        IF(R>RMAX) THEN
                            RMAX = R
                            IMAX = I
                            I1MAX = I1
                            KMAX = K
                        END IF
                    END IF

                    CALL COLLAPSING_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    C)

                    IF(C) THEN
                        IF(R<RMIN) THEN
                            RMIN = R
                            IMIN = I
                            I1MIN = I1
                            KMIN = K
                        END IF
                    END IF

                    END IF
                END IF
            END DO
        END DO

        B = .FALSE.

        IF(IMAX .NE. 0) THEN

        IF((BB .AND. ONE_BOUNDARY_LENGTH > ONE_BOUNDARY_INITIAL_LENGTH + TEMP_NEWEDGELENGTH(KMAX,IMAX)) .OR. RMAX > 2.) THEN
            FLAG = .TRUE.
            B = .TRUE.

            FLIP_REGION1 = DIVIDED_REGION_ARRAY(IMAX)
            FLIP_REGION2 = DIVIDED_REGION_ARRAY(I1MAX)

            CALL EDGE_SPLITTING_PROCESS_ONE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, TEMP_NEWONINTERFACE, &
            TEMP_NEWLOCATION, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_ABLATION_FLAG, TEMP_CONNECTION, TEMP_CONNECTION_NUM, IMAX, KMAX, DIVIDED_REGION_ARRAY = DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY = DIVIDED_BOUNDARY_ARRAY, POINT_NEW1 = POINT_NEW1, POINT_NEW2 = POINT_NEW2, POINT_NEW3 = POINT_NEW3, POINT_NEW4 = POINT_NEW4, POINT_NEW5 = POINT_NEW5)

            FLIP_START1 = POINT_NEW1
            FLIP_START2 = POINT_NEW3

            WRITE(*,*) 'SPLITTING ON BOUNDARY NUMBER ', ITER
        END IF

        END IF

        IF(.NOT. B .AND. IMIN .NE. 0) THEN

        IF((BB .AND. ONE_BOUNDARY_LENGTH < ONE_BOUNDARY_INITIAL_LENGTH - TEMP_NEWEDGELENGTH(KMIN,IMIN)) .OR. RMIN < 0.5) THEN
            FLAG = .TRUE.
            B = .TRUE.

            FLIP_REGION1 = DIVIDED_REGION_ARRAY(IMIN)
            FLIP_REGION2 = DIVIDED_REGION_ARRAY(I1MIN)

            CALL EDGE_COLLAPSING_PROCESS_ONE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, TEMP_NEWONINTERFACE, &
            TEMP_NEWLOCATION, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_ABLATION_FLAG, TEMP_CONNECTION, TEMP_CONNECTION_NUM, IMIN, KMIN, DIVIDED_REGION_ARRAY = DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY = DIVIDED_BOUNDARY_ARRAY, POINT_NEW1 = POINT_NEW1, POINT_NEW2 = POINT_NEW2, POINT_NEW3 = POINT_NEW3)

            FLIP_START1 = POINT_NEW1
            FLIP_START2 = POINT_NEW3

            WRITE(*,*) 'COLLAPSING ON BOUNDARY NUMBER ', ITER

        END IF

        END IF

        IF(B) THEN
            CALL FLUID_SMOOTHING_REMESH(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, TEMP_NEWEDGELENGTH, TEMPINITIALPOINT_TYPE,  DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_NUM, DIVIDED_BOUNDARY_ARRAY)

            CALL MAKE_LOCAL_REGION(TEMP_POINT_NUM, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, FLIP_REGION1, FLIP_START1, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES)
            CALL LOCAL_REGION_FLIPPING(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY)

            TEMPTIME = TEMPTIME + 1
            !CALL TEST_SAVINGDATA_TECPLOT(TEMPTIME, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, LOCAL_REGION_FACES)

            CALL MAKE_LOCAL_REGION(TEMP_POINT_NUM, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, FLIP_REGION2, FLIP_START2, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES)
            CALL LOCAL_REGION_FLIPPING(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE,  TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY)

            TEMPTIME = TEMPTIME + 1
            !CALL TEST_SAVINGDATA_TECPLOT(TEMPTIME, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, LOCAL_REGION_FACES)
        END IF

        END DO
    END DO

    IF(FLAG) THEN
        CALL RESET_DIVIDED_REGION_BOUNDARY(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM)
    END IF


    !! 2-1. Change region nubmer of small face !!


    !        DO ITER=1,DIVIDED_REGION_NUM
    !        
    !        B = .FALSE.
    !        BB = .FALSE.
    !                
    !        DO I=1,TEMP_FACE_NUM
    !            IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
    !                V1 = TEMPPOINT(:,TEMPFACE(2,I)) - TEMPPOINT(:,TEMPFACE(1,I))
    !                V2 = TEMPPOINT(:,TEMPFACE(3,I)) - TEMPPOINT(:,TEMPFACE(1,I))
    !                
    !                CALL VEC_CURL1(V1,V2, N)
    !                
    !                AREA = SQRT(DOT_PRODUCT(N,N))/2.
    !                
    !                R = AREA/TEMP_NEWFACEAREA(I)
    !                IF(R<0.5 .OR. R>2.) THEN
    !                    B = .TRUE.
    !                    EXIT
    !                END IF
    !            END IF
    !        END DO
    !        
    !        IF(B) THEN
    !        
    !            ALLOCATE(TEMP_DIVIDED_REGION_ARRAY(TEMP_FACE_NUM))
    !            
    !            TEMP_DIVIDED_REGION_ARRAY(:) = DIVIDED_REGION_ARRAY(1:TEMP_FACE_NUM)
    !                
    !                DO I=1,TEMP_FACE_NUM
    !                    IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
    !                        
    !                        V1 = TEMPPOINT(:,TEMPFACE(2,I)) - TEMPPOINT(:,TEMPFACE(1,I))
    !                        V2 = TEMPPOINT(:,TEMPFACE(3,I)) - TEMPPOINT(:,TEMPFACE(1,I))
    !                        
    !                        CALL VEC_CURL1(V1,V2, N)
    !                        
    !                        AREA = SQRT(DOT_PRODUCT(N,N))/2.
    !                            
    !                        R = AREA/TEMP_NEWFACEAREA(I)
    !                        !IF(R<0.5 .OR. R>2.) THEN
    !                        
    !                        DO K=1,3
    !                            CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)
    !                            
    !                            IF(DIVIDED_REGION_ARRAY(I1)==ITER) THEN
    !                                
    !                                POINT_IDX1 = TEMPFACE(MOD(K+3-2, 3) + 1, I)
    !                                POINT_IDX2 = TEMPFACE(K, I)
    !                                DO J=1,3
    !                                    IF(TEMPFACE(J,I1)==POINT_IDX2) THEN
    !                                        POINT_IDX3 = TEMPFACE(MOD(J,3) + 1, I1)
    !                                        EXIT
    !                                    END IF
    !                                END DO
    !                                POINT_IDX4 = TEMPFACE(MOD(K,3) + 1, I)
    !                                
    !                                CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I,MOD(K+3-2, 3) + 1, II1)
    !                                CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I1,J, II2)
    !                                CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I1,MOD(J,3) + 1, II3)
    !                                CALL FACE_NEIGHBOR_FACE(TEMPFACE,TEMP_CONNECTION_NUM,TEMP_CONNECTION,I,MOD(K,3) + 1, II4)
    !                                
    !                                IF(DIVIDED_REGION_ARRAY(II1)==ITER .AND. DIVIDED_REGION_ARRAY(II3)==ITER .AND. DIVIDED_REGION_ARRAY(II2).NE.ITER .AND. DIVIDED_REGION_ARRAY(II4).NE.ITER .AND. DIVIDED_REGION_ARRAY(II2).NE.DIVIDED_REGION_ARRAY(II4)) THEN
    !                                    IF(TEMPPOINT_TYPE(POINT_IDX1)>=4 .AND. TEMPPOINT_TYPE(POINT_IDX4)>=4) THEN
    !                                        TEMP_DIVIDED_REGION_ARRAY(I) = DIVIDED_REGION_ARRAY(II2)
    !                                        TEMP_DIVIDED_REGION_ARRAY(I1) = DIVIDED_REGION_ARRAY(II2)
    !                                    ELSE IF(TEMPPOINT_TYPE(POINT_IDX2)>=4 .AND. TEMPPOINT_TYPE(POINT_IDX3)>=4) THEN
    !                                        TEMP_DIVIDED_REGION_ARRAY(I) = DIVIDED_REGION_ARRAY(II4)
    !                                        TEMP_DIVIDED_REGION_ARRAY(I1) = DIVIDED_REGION_ARRAY(II4)
    !                                    ELSE IF(TEMP_NEWONINTERFACE(II4)==-1) THEN
    !                                        TEMP_DIVIDED_REGION_ARRAY(I) = DIVIDED_REGION_ARRAY(II2)
    !                                        TEMP_DIVIDED_REGION_ARRAY(I1) = DIVIDED_REGION_ARRAY(II2)
    !                                    ELSE IF(TEMP_NEWONINTERFACE(II2)==-1) THEN
    !                                        TEMP_DIVIDED_REGION_ARRAY(I) = DIVIDED_REGION_ARRAY(II4)
    !                                        TEMP_DIVIDED_REGION_ARRAY(I1) = DIVIDED_REGION_ARRAY(II4)
    !                                    ELSE
    !                                        TEMP_DIVIDED_REGION_ARRAY(I) = MIN(DIVIDED_REGION_ARRAY(II2), DIVIDED_REGION_ARRAY(II4))
    !                                        TEMP_DIVIDED_REGION_ARRAY(I1) = MIN(DIVIDED_REGION_ARRAY(II2), DIVIDED_REGION_ARRAY(II4))
    !                                    END IF
    !                                    
    !                                    BB = .TRUE.
    !                                ELSE IF(DIVIDED_REGION_ARRAY(II2)==ITER .AND. DIVIDED_REGION_ARRAY(II4)==ITER .AND. DIVIDED_REGION_ARRAY(II1).NE.ITER .AND. DIVIDED_REGION_ARRAY(II3).NE.ITER .AND. DIVIDED_REGION_ARRAY(II1).NE.DIVIDED_REGION_ARRAY(II3)) THEN
    !                                    IF(TEMPPOINT_TYPE(POINT_IDX1)>=4 .AND. TEMPPOINT_TYPE(POINT_IDX2)>=4) THEN
    !                                        TEMP_DIVIDED_REGION_ARRAY(I) = DIVIDED_REGION_ARRAY(II3)
    !                                        TEMP_DIVIDED_REGION_ARRAY(I1) = DIVIDED_REGION_ARRAY(II3)
    !                                    ELSE IF(TEMPPOINT_TYPE(POINT_IDX3)>=4 .AND. TEMPPOINT_TYPE(POINT_IDX4)>=4) THEN
    !                                        TEMP_DIVIDED_REGION_ARRAY(I) = DIVIDED_REGION_ARRAY(II1)
    !                                        TEMP_DIVIDED_REGION_ARRAY(I1) = DIVIDED_REGION_ARRAY(II1)
    !                                    ELSE IF(TEMP_NEWONINTERFACE(II1)==-1) THEN
    !                                        TEMP_DIVIDED_REGION_ARRAY(I) = DIVIDED_REGION_ARRAY(II3)
    !                                        TEMP_DIVIDED_REGION_ARRAY(I1) = DIVIDED_REGION_ARRAY(II3)
    !                                    ELSE IF(TEMP_NEWONINTERFACE(II3)==-1) THEN
    !                                        TEMP_DIVIDED_REGION_ARRAY(I) = DIVIDED_REGION_ARRAY(II1)
    !                                        TEMP_DIVIDED_REGION_ARRAY(I1) = DIVIDED_REGION_ARRAY(II1)
    !                                    ELSE
    !                                        TEMP_DIVIDED_REGION_ARRAY(I) = MIN(DIVIDED_REGION_ARRAY(II1), DIVIDED_REGION_ARRAY(II3))
    !                                        TEMP_DIVIDED_REGION_ARRAY(I1) = MIN(DIVIDED_REGION_ARRAY(II1), DIVIDED_REGION_ARRAY(II3))
    !                                    END IF
    !                                    
    !                                    BB = .TRUE.
    !                                END IF
    !                            END IF
    !                        END DO
    !                        
    !                        !END IF
    !                    END IF
    !                END DO
    !            
    !            IF(BB) THEN
    !                DIVIDED_REGION_ARRAY(1:TEMP_FACE_NUM) = TEMP_DIVIDED_REGION_ARRAY(:)
    !                CALL RESET_DIVIDED_REGION_BOUNDARY(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM)
    !                
    !                WRITE(*,*) 'REGION CHANGED'
    !            END IF
    !        
    !            DEALLOCATE(TEMP_DIVIDED_REGION_ARRAY)
    !        
    !        END IF
    !        
    !        END DO


    !! 2-2. Remove small region !!


    !        DO ITER=1,DIVIDED_REGION_NUM
    !        
    !        B = .FALSE.
    !        
    !        REGION_FACE_NUM = 0
    !        
    !        DO I=1,TEMP_FACE_NUM
    !            IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
    !                REGION_FACE_NUM = REGION_FACE_NUM + 1
    !            END IF
    !        END DO
    !        
    !        IF(REGION_FACE_NUM < 6) THEN
    !            B = .TRUE.
    !        END IF
    !        
    !        IF(B) THEN
    !        
    !            ONE_REGION_AREA = 0.
    !            ONE_REGION_INITIAL_AREA = 0.
    !            II1 = 0
    !            II2 = 0
    !            II3 = 0
    !            
    !            DO I=1,TEMP_FACE_NUM
    !                IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
    !                    
    !                    V1 = TEMPPOINT(:,TEMPFACE(2,I)) - TEMPPOINT(:,TEMPFACE(1,I))
    !                    V2 = TEMPPOINT(:,TEMPFACE(3,I)) - TEMPPOINT(:,TEMPFACE(1,I))
    !                    
    !                    CALL VEC_CURL1(V1,V2, N)
    !                    
    !                    AREA = SQRT(DOT_PRODUCT(N,N))/2
    !                    
    !                    ONE_REGION_AREA = ONE_REGION_AREA + AREA
    !                    ONE_REGION_INITIAL_AREA = ONE_REGION_INITIAL_AREA + TEMP_NEWFACEAREA(I)
    !                    
    !                    CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)
    !                    
    !                    IF(DIVIDED_REGION_ARRAY(I1).NE.ITER) THEN
    !                        IF(TEMPPOINT_TYPE(TEMPFACE(K,I))>=4 .AND. TEMPPOINT_TYPE(TEMPFACE(MOD(K,3)+1,I))>=4) THEN
    !                            II3 = DIVIDED_REGION_ARRAY(I1)
    !                        ELSE IF(TEMP_NEWONINTERFACE(I1)==-1) THEN
    !                            II2 = DIVIDED_REGION_ARRAY(I1)
    !                        ELSE
    !                            II1 = DIVIDED_REGION_ARRAY(I1)
    !                        END IF
    !                    END IF
    !                END IF
    !            END DO
    !            
    !            IF(ONE_REGION_AREA < ONE_REGION_INITIAL_AREA/2.) THEN
    !                IF(II1==0 .AND. II2==0) THEN
    !                    II1 = II3
    !                ELSE IF(II1==0) THEN
    !                    II1 = II2
    !                END IF
    !                
    !                DO I=1,TEMP_FACE_NUM
    !                    IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
    !                        DIVIDED_REGION_ARRAY(I) = II1
    !                    END IF
    !                END DO
    !                
    !                CALL RESET_DIVIDED_REGION_BOUNDARY(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM)
    !                
    !                WRITE(*,*) 'REGION CHANGED'
    !            END IF
    !        END IF
    !        END DO


    !! 3. Area-based splitting and collapsing in smooth region !!


    DO ITER=1,DIVIDED_REGION_NUM
        B = .FALSE.
        BB = .FALSE.
        
        ONE_REGION_AREA = 0.
        ONE_REGION_INITIAL_AREA = 0.

        RMAX = 0.
        RMIN = 10.

        DO I=1,TEMP_FACE_NUM
            IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN

            V1 = TEMPPOINT(:,TEMPFACE(2,I)) - TEMPPOINT(:,TEMPFACE(1,I))
            V2 = TEMPPOINT(:,TEMPFACE(3,I)) - TEMPPOINT(:,TEMPFACE(1,I))

            CALL VEC_CURL1(V1,V2, N)

            AREA = SQRT(DOT_PRODUCT(N,N))/2

            ONE_REGION_AREA = ONE_REGION_AREA + AREA
            ONE_REGION_INITIAL_AREA = ONE_REGION_INITIAL_AREA + TEMP_NEWFACEAREA(I)

            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)

                IF(DIVIDED_BOUNDARY_ARRAY(K,I) == 0) THEN

                V1_1 = TEMPPOINT(:,TEMPFACE(2,I1)) - TEMPPOINT(:,TEMPFACE(1,I1))
                V2_1 = TEMPPOINT(:,TEMPFACE(3,I1)) - TEMPPOINT(:,TEMPFACE(1,I1))

                CALL VEC_CURL1(V1_1,V2_1, N1)

                AREA1 = SQRT(DOT_PRODUCT(N1,N1))/2.

                R = AREA/TEMP_NEWFACEAREA(I) * AREA1/TEMP_NEWFACEAREA(I1)

                CALL SPLITTING_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    C)

                IF(C) THEN
                    IF(R>RMAX) THEN
                        RMAX = R
                        IMAX = I
                        I1MAX = I1
                        KMAX = K
                    END IF
                END IF

                CALL COLLAPSING_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    C)

                IF(C) THEN
                    IF(R<RMIN) THEN
                        RMIN = R
                        IMIN = I
                        I1MIN = I1
                        KMIN = K
                    END IF
                END IF

                END IF
            END DO
            END IF
        END DO

        WRITE(*,*) 'RMAX = ', RMAX, 'RMIN = ', RMIN
        !WRITE(*,*) 'IMAX = ', IMAX, 'I1MAX = ', I1MAX, 'IMIN = ', IMIN, 'I1MIN = ', I1MIN

        IF(ONE_REGION_AREA > ONE_REGION_INITIAL_AREA * 1.1 .OR. ONE_REGION_AREA < ONE_REGION_INITIAL_AREA / 1.1) THEN
            B = .TRUE.
            BB = .TRUE.
        END IF
        
        IF(RMAX > 9. .OR. RMIN < 1./9.) THEN
            B = .TRUE.
        END IF
        
        DO WHILE(B)

        RMAX = 0.
        RMIN = 10.

        IMAX = 0
        IMIN = 0

        ONE_REGION_AREA = 0.
        ONE_REGION_INITIAL_AREA = 0.

        DO I=1,TEMP_FACE_NUM
            IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN

            V1 = TEMPPOINT(:,TEMPFACE(2,I)) - TEMPPOINT(:,TEMPFACE(1,I))
            V2 = TEMPPOINT(:,TEMPFACE(3,I)) - TEMPPOINT(:,TEMPFACE(1,I))

            CALL VEC_CURL1(V1,V2, N)

            AREA = SQRT(DOT_PRODUCT(N,N))/2

            ONE_REGION_AREA = ONE_REGION_AREA + AREA
            ONE_REGION_INITIAL_AREA = ONE_REGION_INITIAL_AREA + TEMP_NEWFACEAREA(I)

            DO K=1,3
                CALL FACE_NEIGHBOR_FACE( TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)

                IF(DIVIDED_BOUNDARY_ARRAY(K,I) == 0) THEN

                V1_1 = TEMPPOINT(:,TEMPFACE(2,I1)) - TEMPPOINT(:,TEMPFACE(1,I1))
                V2_1 = TEMPPOINT(:,TEMPFACE(3,I1)) - TEMPPOINT(:,TEMPFACE(1,I1))

                CALL VEC_CURL1(V1_1,V2_1, N1)

                AREA1 = SQRT(DOT_PRODUCT(N1,N1))/2.

                R = AREA/TEMP_NEWFACEAREA(I) * AREA1/TEMP_NEWFACEAREA(I1)

                CALL SPLITTING_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    C)

                IF(C) THEN
                    IF(R>RMAX) THEN
                        RMAX = R
                        IMAX = I
                        I1MAX = I1
                        KMAX = K
                    END IF
                END IF

                CALL COLLAPSING_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    C)

                IF(C) THEN
                    IF(R<RMIN) THEN
                        RMIN = R
                        IMIN = I
                        I1MIN = I1
                        KMIN = K
                    END IF
                END IF

                END IF
            END DO
            END IF
        END DO

        B = .FALSE.

        IF(IMAX .NE. 0) THEN

        IF((BB .AND. ONE_REGION_AREA > ONE_REGION_INITIAL_AREA + TEMP_NEWFACEAREA(IMAX) + TEMP_NEWFACEAREA(I1MAX)) .OR. RMAX > 9.) THEN
            FLAG = .TRUE.
            B = .TRUE.

            CALL EDGE_SPLITTING_PROCESS_ONE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, TEMP_NEWONINTERFACE, &
            TEMP_NEWLOCATION, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_ABLATION_FLAG, TEMP_CONNECTION, TEMP_CONNECTION_NUM, IMAX, KMAX, DIVIDED_REGION_ARRAY = DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY = DIVIDED_BOUNDARY_ARRAY, POINT_NEW1 = POINT_NEW1, POINT_NEW2 = POINT_NEW2, POINT_NEW3 = POINT_NEW3, POINT_NEW4 = POINT_NEW4, POINT_NEW5 = POINT_NEW5)

            FLIP_START = POINT_NEW5

            WRITE(*,*) 'SPLITTING ON REGION NUMBER ', ITER

        END IF

        END IF

        IF(.NOT. B .AND. IMIN .NE. 0) THEN

        IF((BB .AND. ONE_REGION_AREA < ONE_REGION_INITIAL_AREA - TEMP_NEWFACEAREA(IMIN) - TEMP_NEWFACEAREA(I1MIN)) .OR. RMIN < 1./9.) THEN
            FLAG = .TRUE.
            B = .TRUE.

            CALL EDGE_COLLAPSING_PROCESS_ONE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, TEMP_NEWONINTERFACE, &
            TEMP_NEWLOCATION, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_ABLATION_FLAG, TEMP_CONNECTION, TEMP_CONNECTION_NUM, IMIN, KMIN, DIVIDED_REGION_ARRAY = DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY = DIVIDED_BOUNDARY_ARRAY, POINT_NEW1 = POINT_NEW1, POINT_NEW2 = POINT_NEW2, POINT_NEW3 = POINT_NEW3)

            FLIP_START = POINT_NEW2

            WRITE(*,*) 'COLLAPSING ON REGION NUMBER ', ITER
        END IF

        END IF

        IF(B) THEN
            CALL MAKE_LOCAL_REGION(TEMP_POINT_NUM, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, ITER, FLIP_START, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES)
            CALL LOCAL_REGION_FLIPPING(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY)

            TEMPTIME = TEMPTIME + 1
            !CALL TEST_SAVINGDATA_TECPLOT(TEMPTIME, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, LOCAL_REGION_FACES)
        END IF

        END DO
    END DO

    IF(FLAG) THEN
        CALL RESET_DIVIDED_REGION_BOUNDARY(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM)
    END IF


    !! 3-2. Remove small region !!

    DO ITER=1,DIVIDED_REGION_NUM

    B = .FALSE.

    REGION_FACE_NUM = 0

    DO I=1,TEMP_FACE_NUM
        IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
            REGION_FACE_NUM = REGION_FACE_NUM + 1
        END IF
    END DO

    IF(REGION_FACE_NUM <= 8) THEN
        B = .TRUE.
    END IF

    IF(B) THEN

    ONE_REGION_AREA = 0.
    ONE_REGION_INITIAL_AREA = 0.
    REGION_FACE_NUM = 0

    REGION1 = 0
    !REGION2 = 0
    !REGION3 = 0

    DO I=1,TEMP_FACE_NUM
        IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
            REGION_FACE_NUM = REGION_FACE_NUM + 1

            V1 = TEMPPOINT(:,TEMPFACE(2,I)) - TEMPPOINT(:,TEMPFACE(1,I))
            V2 = TEMPPOINT(:,TEMPFACE(3,I)) - TEMPPOINT(:,TEMPFACE(1,I))

            CALL VEC_CURL1(V1,V2, N)

            AREA = SQRT(DOT_PRODUCT(N,N))/2

            ONE_REGION_AREA = ONE_REGION_AREA + AREA
            ONE_REGION_INITIAL_AREA = ONE_REGION_INITIAL_AREA + TEMP_NEWFACEAREA(I)

            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)

                IF(DIVIDED_REGION_ARRAY(I1).NE.ITER) THEN
                    IF(TEMP_NEWONINTERFACE(I)==TEMP_NEWONINTERFACE(I1)) THEN
                        REGION1 = DIVIDED_REGION_ARRAY(I1)
                    END IF
                END IF
            END DO
        END IF
    END DO

    IF(REGION1 .NE. 0 .AND. (REGION_FACE_NUM <= 8 .OR. ONE_REGION_AREA < ONE_REGION_INITIAL_AREA/3.)) THEN
        DO I=1,TEMP_FACE_NUM
            IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
            
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)
                DO J=1,3
                    IF(TEMPFACE(J,I1)==TEMPFACE(K,I)) THEN
                        EXIT
                    END IF
                END DO
                IF(DIVIDED_REGION_ARRAY(I1)==REGION1) THEN
                    DIVIDED_BOUNDARY_ARRAY(K,I) = 0
                    DIVIDED_BOUNDARY_ARRAY(MOD(J+3-2,3)+1,I1) = 0
                END IF
            END DO
            END IF
        END DO
        
        DO I=1,TEMP_FACE_NUM
            IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
                DO K=1,3
                    C = .TRUE.
                    J1 = TEMPFACE(K,I)
                    DO L=1,TEMP_CONNECTION_NUM(J1)
                        I1 = TEMP_CONNECTION(L,J1)
                        DO J=1,3
                            IF(TEMPFACE(J,I1)==J1) THEN
                                EXIT
                            END IF
                        END DO
                        IF(DIVIDED_BOUNDARY_ARRAY(J,I1).NE.0) THEN
                            C = .FALSE.
                            EXIT
                        END IF
                    END DO

                    IF(C) THEN
                        TEMPINITIALPOINT_TYPE(J1) = 1
                        TEMPPOINT_TYPE(J1) = 1
                    END IF
                END DO
            END IF
        END DO

        WRITE(*,*) 'REGION CHANGED'

        FLAG = .TRUE.
    END IF
    END IF
    END DO

    IF(FLAG) THEN  
        CALL RESET_DIVIDED_REGION_BOUNDARY(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM)
    END IF


    !! 4. Flipping bad triangles !!

    DO ITER=1,DIVIDED_REGION_NUM
        
        BB = .FALSE.
        
        DO I=1,TEMP_FACE_NUM
            IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
                CALL MESH_QUALITY_TRIANGLE_ONE_ORIENTATION(TEMPPOINT, TEMPFACE, I, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, DIVIDED_BOUNDARY_ARRAY, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
                !CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,I)), TEMPPOINT(:,TEMPFACE(2,I)), TEMPPOINT(:,TEMPFACE(3,I)), TEMP_NEWFACEAREA(I), F_SIZE_SHAPE, F_SIZE, F_SHAPE)

                IF(F_SHAPE < 0.5) THEN
                    DO K=1,3
                        CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)
                        
                        CALL FLIPPING_AVAILABLE_QUALITY(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    B, QUALITY_AFTER)
                        IF(B) THEN
                            BB = .TRUE.
                            EXIT
                        END IF
                    END DO
                    
                    IF(BB) EXIT
                END IF
            END IF
        END DO
        
        IF(BB) THEN
        
        DO I=1,TEMP_FACE_NUM
            IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
                CALL MESH_QUALITY_TRIANGLE_ONE_ORIENTATION(TEMPPOINT, TEMPFACE, I, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, DIVIDED_BOUNDARY_ARRAY, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
                !CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,I)), TEMPPOINT(:,TEMPFACE(2,I)), TEMPPOINT(:,TEMPFACE(3,I)), TEMP_NEWFACEAREA(I), F_SIZE_SHAPE, F_SIZE, F_SHAPE)

                IF(F_SHAPE < 0.6) THEN
                    
                    R = 1000.
                    KMIN = 0
                    
                    DO K=1,3
                        CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)
                        
                        CALL FLIPPING_AVAILABLE_QUALITY(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    B, QUALITY_AFTER)
                        IF(B .AND. QUALITY_AFTER < R) THEN
                            R = QUALITY_AFTER
                            KMIN = K
                        END IF
                    END DO
                    
                    IF(R < 1000.) THEN
                        WRITE(*,*) 'FLIPPING ON REGION NUMBER ', ITER
                        
                        FLAG = .TRUE.
                        CALL EDGE_FLIPPING_PROCESS_ONE(TEMPFACE, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_CONNECTION, TEMP_CONNECTION_NUM, I, KMIN, DIVIDED_BOUNDARY_ARRAY = DIVIDED_BOUNDARY_ARRAY)
                        TEMPTIME = TEMPTIME + 1
                        !CALL TEST_SAVINGDATA_TECPLOT(TEMPTIME, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, LOCAL_REGION_FACES)
                    END IF
                END IF
            END IF
        END DO
        
        END IF
        
    END DO

    DO ITER=1,DIVIDED_REGION_NUM
        B = .TRUE.
        !L = 0

        DO WHILE(B)! .AND. L < 30)

        B = .FALSE.

        DO I=1,TEMP_FACE_NUM
            IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
                CALL MESH_QUALITY_TRIANGLE_ONE_ORIENTATION(TEMPPOINT, TEMPFACE, I, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, DIVIDED_BOUNDARY_ARRAY, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
                !CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,I)), TEMPPOINT(:,TEMPFACE(2,I)), TEMPPOINT(:,TEMPFACE(3,I)), TEMP_NEWFACEAREA(I), F_SIZE_SHAPE, F_SIZE, F_SHAPE)

                IF(F_SHAPE < 0.4) THEN
                    
                    R = 1000.
                    KMIN = 0
                    
                    DO K=1,3
                        CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)
                        
                        CALL COLLAPSING_AVAILABLE_QUALITY(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    C, QUALITY_AFTER)
                        IF(C .AND. QUALITY_AFTER < R) THEN
                            R = QUALITY_AFTER
                            KMIN = K
                        END IF
                    END DO
                    
                    IF(R < 1000.) THEN
                        FLAG = .TRUE.
                        B = .TRUE.
                        IF(DIVIDED_BOUNDARY_ARRAY(KMIN,I) == 0) THEN
                            WRITE(*,*) 'COLLAPSING ON REGION NUMBER ', ITER
                        ELSE
                            WRITE(*,*) 'COLLAPSING ON BOUNDARY NUMBER ', DIVIDED_BOUNDARY_ARRAY(KMIN,I)
                        END IF
                        
                        CALL EDGE_COLLAPSING_PROCESS_ONE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, TEMP_NEWONINTERFACE, &
                        TEMP_NEWLOCATION, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_ABLATION_FLAG, TEMP_CONNECTION, TEMP_CONNECTION_NUM, I, KMIN, DIVIDED_REGION_ARRAY = DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY = DIVIDED_BOUNDARY_ARRAY, POINT_NEW1 = POINT_NEW1, POINT_NEW2 = POINT_NEW2, POINT_NEW3 = POINT_NEW3)
                        
                        FLIP_START = POINT_NEW2
                        FLIP_REGION1= ITER
                        
                        IF(DIVIDED_REGION_ARRAY(I) .NE. ITER) THEN
                            FLIP_REGION2 = DIVIDED_REGION_ARRAY(I)
                        ELSE
                            FLIP_REGION2 = 0
                        END IF
                    END IF
                    
                    IF(.FALSE.) THEN!IF(.NOT. B) THEN
                    
                    R = 1000.
                    KMIN = 0
                    
                    DO K=1,3
                        CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)
                        
                        CALL SPLITTING_AVAILABLE_QUALITY(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, I, K, I1,    C, QUALITY_AFTER)
                        IF(C .AND. QUALITY_AFTER < R) THEN
                            R = QUALITY_AFTER
                            KMIN = K
                        END IF
                    END DO
                    
                    IF(R < 1000.) THEN
                        FLAG = .TRUE.
                        B = .TRUE.
                        IF(DIVIDED_BOUNDARY_ARRAY(KMIN,I) == 0) THEN
                            WRITE(*,*) 'SPLITTING ON REGION NUMBER ', ITER
                        ELSE
                            WRITE(*,*) 'SPLITTING ON BOUNDARY NUMBER ', DIVIDED_BOUNDARY_ARRAY(KMIN,I)
                        END IF
                        
                        CALL EDGE_SPLITTING_PROCESS_ONE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, TEMP_NEWONINTERFACE, &
                        TEMP_NEWLOCATION, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_ABLATION_FLAG, TEMP_CONNECTION, TEMP_CONNECTION_NUM, I, KMIN, DIVIDED_REGION_ARRAY = DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY = DIVIDED_BOUNDARY_ARRAY, POINT_NEW1 = POINT_NEW1, POINT_NEW2 = POINT_NEW2, POINT_NEW3 = POINT_NEW3, POINT_NEW4 = POINT_NEW4, POINT_NEW5 = POINT_NEW5)
                        
                        FLIP_START = POINT_NEW5
                        FLIP_REGION1= ITER
                        
                        IF(DIVIDED_REGION_ARRAY(I) .NE. ITER) THEN
                            FLIP_REGION2 = DIVIDED_REGION_ARRAY(I)
                        ELSE
                            FLIP_REGION2 = 0
                        END IF
                    END IF
                    
                    END IF
                END IF
            END IF
            
            IF(B) THEN
                EXIT
            END IF
        END DO

        IF(B) THEN
            IF(FLIP_REGION2 .NE. 0) THEN
            CALL FLUID_SMOOTHING_REMESH(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, TEMP_NEWEDGELENGTH, TEMPINITIALPOINT_TYPE,  DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_NUM, DIVIDED_BOUNDARY_ARRAY)
            END IF
            
            CALL MAKE_LOCAL_REGION(TEMP_POINT_NUM, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, FLIP_REGION1, FLIP_START, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES)
            CALL LOCAL_REGION_FLIPPING(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY)
            
            TEMPTIME = TEMPTIME + 1
            !CALL TEST_SAVINGDATA_TECPLOT(TEMPTIME, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, LOCAL_REGION_FACES)
            
            IF(FLIP_REGION2 .NE. 0) THEN
            
            CALL MAKE_LOCAL_REGION(TEMP_POINT_NUM, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, FLIP_REGION2, FLIP_START, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES)
            CALL LOCAL_REGION_FLIPPING(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY)
            
            TEMPTIME = TEMPTIME + 1
            !CALL TEST_SAVINGDATA_TECPLOT(TEMPTIME, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, LOCAL_REGION_FACES)
            
            END IF
            
        END IF

        !L = L + 1
        END DO
    END DO
    
    IF(FLAG) THEN
        CALL RESET_DIVIDED_REGION_BOUNDARY(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM)
    END IF

    DO ITER=1,DIVIDED_BOUNDARY_NUM
        B = .TRUE.
        !L = 0

        DO WHILE(B) !.AND. L < 30)

        B = .FALSE.

        DO I=1,TEMP_FACE_NUM
            DO K=1,3
                IF(DIVIDED_BOUNDARY_ARRAY(K,I)==ITER .AND. DIVIDED_BOUNDARY_ARRAY(MOD(K,3)+1,I)==0 .AND. DIVIDED_BOUNDARY_ARRAY(MOD(K+3-2,3)+1,I)==0) THEN
                    CALL MESH_QUALITY_TRIANGLE_ONE_ORIENTATION(TEMPPOINT, TEMPFACE, I, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, DIVIDED_BOUNDARY_ARRAY, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
                    !CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,I)), TEMPPOINT(:,TEMPFACE(2,I)), TEMPPOINT(:,TEMPFACE(3,I)), TEMP_NEWFACEAREA(I), F_SIZE_SHAPE, F_SIZE, F_SHAPE)

                    IF(F_SHAPE < 0.4) THEN

                    CALL FACE_NEIGHBOR_FACE(TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION,I,K, I1)

                    CALL SPL_COL_AVAILABLE(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, I, K, I1, C)
                    IF(C) THEN
                        !FLIP_START = TEMPFACE(1,I)
                        FLAG = .TRUE.
                        B = .TRUE.

                        FLIP_REGION1 = DIVIDED_REGION_ARRAY(I)

                        CALL EDGE_SPLITTING_PROCESS_ONE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, TEMP_NEWONINTERFACE, &
                        TEMP_NEWLOCATION, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_ABLATION_FLAG, TEMP_CONNECTION, TEMP_CONNECTION_NUM, I, K, DIVIDED_REGION_ARRAY = DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY = DIVIDED_BOUNDARY_ARRAY)
                        CALL EDGE_COLLAPSING_PROCESS_ONE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMPINITIALPOINT_TYPE, TEMPPOINT_TYPE, TEMP_NEWONINTERFACE, &
                        TEMP_NEWLOCATION, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, TEMP_ABLATION_FLAG, TEMP_CONNECTION, TEMP_CONNECTION_NUM, I, 1, DIVIDED_REGION_ARRAY = DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY = DIVIDED_BOUNDARY_ARRAY, POINT_NEW1 = POINT_NEW1, POINT_NEW2 = POINT_NEW2, POINT_NEW3 = POINT_NEW3)

                        FLIP_START1 = POINT_NEW2

                        EXIT
                    END IF
                    END IF
                END IF
            END DO

            IF(B) THEN
                EXIT
            END IF
        END DO        
        
        IF(B) THEN
            WRITE(*,*) 'FLIPPING ON BOUNDARY NUMBER ', ITER
            CALL FLUID_SMOOTHING_REMESH(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, TEMP_NEWEDGELENGTH, TEMPINITIALPOINT_TYPE,  DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_NUM, DIVIDED_BOUNDARY_ARRAY)

            CALL MAKE_LOCAL_REGION(TEMP_POINT_NUM, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, DIVIDED_REGION_ARRAY, FLIP_REGION1, FLIP_START1, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES)
            CALL LOCAL_REGION_FLIPPING(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, TEMP_NEWEDGELENGTH, TEMP_NEWFACEAREA, LOCAL_REGION_ARRAY, LOCAL_REGION_NUM, IS_INTERIOR_POINT, LOCAL_REGION_FACES, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY)

            TEMPTIME = TEMPTIME + 1
            !CALL TEST_SAVINGDATA_TECPLOT(TEMPTIME, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, LOCAL_REGION_FACES)
        END IF

        !L = L + 1
        END DO
    END DO
    
    IF(FLAG) THEN
        CALL RESET_DIVIDED_REGION_BOUNDARY(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM)
    END IF
    
    DO ITER=1,DIVIDED_REGION_NUM

        DO I=1,TEMP_FACE_NUM
            IF(DIVIDED_REGION_ARRAY(I)==ITER) THEN
                CALL MESH_QUALITY_TRIANGLE_ONE_ORIENTATION(TEMPPOINT, TEMPFACE, I, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, DIVIDED_BOUNDARY_ARRAY, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
                !CALL MESH_QUALITY_TRIANGLE_ONE(TEMPPOINT(:,TEMPFACE(1,I)), TEMPPOINT(:,TEMPFACE(2,I)), TEMPPOINT(:,TEMPFACE(3,I)), TEMP_NEWFACEAREA(I), F_SIZE_SHAPE, F_SIZE, F_SHAPE)

                IF(F_SHAPE < 0.3) THEN
                    R = 1000.
                    KMIN = 0
                    
                    DO K=1,3
                        CALL SMOOTHING_AVAILABLE_QUALITY(TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, TEMPFACE(K,I),    B, QUALITY_AFTER, V1)
                        IF(B .AND. QUALITY_AFTER < R) THEN
                            V2 = V1
                            R = QUALITY_AFTER
                            KMIN = K
                        END IF
                    END DO
                    
                    IF(R < 1000.) THEN
                        FLAG = .TRUE.
                        WRITE(*,*) 'SMOOTHING ON REGION NUMBER ', ITER
                        
                        TEMPPOINT(:,TEMPFACE(KMIN,I)) = V2(:)
                        
                        !CALL RECONSTRUCTING_HIGH_ORDER_SURFACE(TEMP_POINT_NUM, TEMPPOINT, TEMPFACE, I, V2, 3, 2, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPPOINT_TYPE, TEMPPOINT(:,TEMPFACE(K,I)))
                        
                        !CALL TEST_SAVINGDATA_TECPLOT(TEMPTIME, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, LOCAL_REGION_FACES)
                    END IF
                    
                END IF
            END IF
        END DO
        
    END DO
    CALL QUALITY_PRINT(TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, DIVIDED_BOUNDARY_ARRAY)
    CALL TEST_SAVINGDATA_TECPLOT(10000, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, LOCAL_REGION_FACES)
    
    DEALLOCATE(LOCAL_REGION_ARRAY)
    DEALLOCATE(IS_INTERIOR_POINT)
    DEALLOCATE(LOCAL_REGION_FACES)

    IF(FLAG) THEN
        IF(TYP==0 .OR. TYP==1) THEN
            CALL RESET_SURFACE(TYP, .TRUE., TEMP_POINT_NUM, TEMP_FACE_NUM, SURFACE_POINTS = TEMPPOINT, SURFACE_FACES = TEMPFACE, &
            SURFACE_INITIAL_FACE_AREA = TEMP_NEWFACEAREA, SURFACE_INITIAL_EDGE_LENGTH = TEMP_NEWEDGELENGTH, POINT_FACE_CONNECTION = TEMP_CONNECTION, POINT_FACE_CONNECTION_NUM = TEMP_CONNECTION_NUM, &
            INITIAL_POINT_TYPE = TEMPINITIALPOINT_TYPE, POINT_TYPE = TEMPPOINT_TYPE, FACE_ONINTERFACE = TEMP_NEWONINTERFACE, &
            FACE_LOCATION = TEMP_NEWLOCATION, FACE_ABLATION_FLAG = TEMP_ABLATION_FLAG, FACE_DIVIDED_REGION_NUM = DIVIDED_REGION_NUM, FACE_DIVIDED_REGION_ARRAY = DIVIDED_REGION_ARRAY, FACE_DIVIDED_BOUNDARY_NUM = DIVIDED_BOUNDARY_NUM, FACE_DIVIDED_BOUNDARY_ARRAY = DIVIDED_BOUNDARY_ARRAY)
        ELSE
            CALL RESET_SURFACE(TYP, .TRUE., TEMP_POINT_NUM, TEMP_FACE_NUM, SURFACE_POINTS = TEMPPOINT, SURFACE_FACES = TEMPFACE, &
            SURFACE_INITIAL_FACE_AREA = TEMP_NEWFACEAREA, SURFACE_INITIAL_EDGE_LENGTH = TEMP_NEWEDGELENGTH, POINT_FACE_CONNECTION = TEMP_CONNECTION, POINT_FACE_CONNECTION_NUM = TEMP_CONNECTION_NUM, &
            INITIAL_POINT_TYPE = TEMPINITIALPOINT_TYPE, POINT_TYPE = TEMPPOINT_TYPE, FACE_ONINTERFACE = TEMP_NEWONINTERFACE, &
            FACE_DIVIDED_REGION_NUM = DIVIDED_REGION_NUM, FACE_DIVIDED_REGION_ARRAY = DIVIDED_REGION_ARRAY, FACE_DIVIDED_BOUNDARY_NUM = DIVIDED_BOUNDARY_NUM, FACE_DIVIDED_BOUNDARY_ARRAY = DIVIDED_BOUNDARY_ARRAY)
        END IF
    END IF

    CALL FIND_RIDGE_GROUP_TYPE(TYP)

    DEALLOCATE(TEMPPOINT)
    DEALLOCATE(TEMPFACE)
    DEALLOCATE(TEMPINITIALPOINT_TYPE)
    DEALLOCATE(TEMPPOINT_TYPE)

    DEALLOCATE(TEMP_NEWONINTERFACE)

    DEALLOCATE(TEMP_NEWLOCATION)
    DEALLOCATE(TEMP_NEWFACEAREA)
    DEALLOCATE(TEMP_NEWEDGELENGTH)
    DEALLOCATE(TEMP_ABLATION_FLAG)
    DEALLOCATE(TEMP_CONNECTION)
    DEALLOCATE(TEMP_CONNECTION_NUM)

    !CALL MESH_QUALITY_TRIANGLE(SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA, QUALITY_ARRAY, 0, 0)
    
    !DEALLOCATE(QUALITY_ARRAY)

    DEALLOCATE(DIVIDED_REGION_ARRAY)
    DEALLOCATE(DIVIDED_BOUNDARY_ARRAY)

    END SUBROUTINE REMESHING_PROCESS

    
    
    SUBROUTINE TEST_SAVINGDATA_TECPLOT(FILE_NUM, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, LOCAL_REGION_FACES)
    IMPLICIT NONE
    INTEGER :: FILE_NUM
    INTEGER :: TEMP_POINT_NUM
    REAL(8) :: TEMPPOINT(:,:)
    INTEGER :: TEMP_FACE_NUM
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: DIVIDED_REGION_ARRAY(:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    LOGICAL, OPTIONAL :: LOCAL_REGION_FACES(:)
    INTEGER :: I
    CHARACTER(500) :: STR, STR2, STR3, STR4, STR5, STR6
    INTEGER :: L, L2, L3, L4, L5, L6

    STR = ''
    WRITE(STR, '(A)') './output/surface/tec_data_3d/surface_test_0000000.plt'
    L = LEN_TRIM(STR)

    STR2 = ''
    WRITE(STR2, '(I)') FILE_NUM
    STR2 = TRIM(ADJUSTL(STR2))
    L2 = LEN_TRIM(STR2)

    WRITE(STR(L-4-L2+1:L-4),'(A)') STR2(1:L2)

    OPEN(UNIT=21, FILE = STR, ACTION = "WRITE", STATUS = "REPLACE")
    WRITE(*,*) TRIM(STR)

    WRITE(21,'(A)') 'TITLE="surface_data"'
    WRITE(21,'(A)') 'VARIABLES= "x", "y", "z", "divided_region", "divided_boundary", "local_region", "divided_boundary1", "divided_boundary2", "divided_boundary3"'

    STR3 = ''
    WRITE(STR3, '(I)') FILE_NUM
    STR3 = TRIM(ADJUSTL(STR3))
    L3 = LEN_TRIM(STR3)

    STR4 = ''
    WRITE(STR4, '(I)') TEMP_POINT_NUM
    STR4 = TRIM(ADJUSTL(STR4))
    L4 = LEN_TRIM(STR4)

    STR5 = ''
    WRITE(STR5, '(I)') TEMP_FACE_NUM
    STR5 = TRIM(ADJUSTL(STR5))
    L5 = LEN_TRIM(STR5)

    STR6 = ', DATAPACKING = BLOCK, ZONETYPE = FETRIANGLE, VARLOCATION = ([1,2,3]=NODAL, [4,5,6,7,8,9]=CELLCENTERED)'
    STR6 = TRIM(ADJUSTL(STR6))
    L6 = LEN_TRIM(STR6)

    WRITE(21,'(A,A,A,A,A,A,A)') 'ZONE SolutionTime = ', STR3(1:L3),', T = "surface_fluid", NODES = ', STR4(1:L4),', ELEMENTS =  ', STR5(1:L5), STR6(1:L6)

    DO I = 1, TEMP_POINT_NUM
        WRITE(21,'(F)') TEMPPOINT(1,I)
    END DO
    DO I = 1, TEMP_POINT_NUM
        WRITE(21,'(F)') TEMPPOINT(2,I)
    END DO
    DO I = 1, TEMP_POINT_NUM
        WRITE(21,'(F)') TEMPPOINT(3,I)
    END DO

    DO I = 1, TEMP_FACE_NUM
        WRITE(21,'(I)') DIVIDED_REGION_ARRAY(I)
    END DO

    DO I = 1, TEMP_FACE_NUM
        WRITE(21,'(I)') MAX(DIVIDED_BOUNDARY_ARRAY(1,I), DIVIDED_BOUNDARY_ARRAY(2,I), DIVIDED_BOUNDARY_ARRAY(3,I))
    END DO

    DO I=1,TEMP_FACE_NUM
        IF(PRESENT(LOCAL_REGION_FACES)) THEN
            IF(LOCAL_REGION_FACES(I)) THEN
                WRITE(21,'(A)') '1'
            ELSE
                WRITE(21,'(A)') '0'
            END IF
        ELSE
            WRITE(21,'(A)') '0'
        END IF
    END DO

    DO I = 1, TEMP_FACE_NUM
        WRITE(21,'(I)') DIVIDED_BOUNDARY_ARRAY(1,I)
    END DO

    DO I = 1, TEMP_FACE_NUM
        WRITE(21,'(I)') DIVIDED_BOUNDARY_ARRAY(2,I)
    END DO

    DO I = 1, TEMP_FACE_NUM
        WRITE(21,'(I)') DIVIDED_BOUNDARY_ARRAY(3,I)
    END DO

    DO I = 1, TEMP_FACE_NUM
        WRITE(21,'(I,I,I)') TEMPFACE(1,I), TEMPFACE(2,I), TEMPFACE(3,I)
    END DO

    CLOSE(21)
    END SUBROUTINE TEST_SAVINGDATA_TECPLOT

    

    SUBROUTINE AREA_BASED_NULLSPACE_SMOOTHING(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, TEMP_NEWFACEAREA, IS_INTERIOR_POINT)
    IMPLICIT NONE
    INTEGER :: TEMP_POINT_NUM
    REAL(8) :: TEMPPOINT(:,:)
    INTEGER :: TEMP_FACE_NUM
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    INTEGER :: TEMPINITIALPOINT_TYPE(:)
    REAL(8) :: TEMP_NEWFACEAREA(:)
    LOGICAL :: IS_INTERIOR_POINT(:)
    REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
    INTEGER :: I,J,K,L
    INTEGER :: I1,I2,I3, CON_NUM
    REAL(8) :: V1(3),V2(3)
    REAL(8), ALLOCATABLE :: NORMAL(:,:)
    !! MODIFIED
    INTEGER :: LOCAL_SHAPE, TEMP_I, JMIN
    REAL(8) :: THETA_A, PHI_R, PHI_C, CHI_R, CHI_C
    !! END MODIFIED
    REAL(8), ALLOCATABLE :: N(:,:), W(:), ORIGIN_W(:), C(:,:), FACE_CENTER(:,:), FACE_AREA(:), T(:,:)
    REAL(8) :: W_SUM, ORIGIN_W_SUM
    REAL(8) :: R
    REAL(8) :: E_VALUE(3)
    REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
    REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
    REAL(8) :: TT(3,3)
    REAL(8), ALLOCATABLE :: MU_I(:), X_I(:), Y_I(:), DX_I(:), DY_I(:), C_I(:)
    REAL(8) :: TEMPVEC(3), U(3), V(3), MU_SUM, AREA, FINAL_A, FINAL_B, FINAL_C, FINAL_D, FINAL_E, FINAL_X, FINAL_Y, CC(3), INITIAL_X, INITIAL_Y, INITIAL_Z

    
    ALLOCATE(DISPLACEMENT(3,TEMP_POINT_NUM))
    ALLOCATE(FACE_AREA(TEMP_FACE_NUM))        
    ALLOCATE(FACE_CENTER(3,TEMP_FACE_NUM))
    ALLOCATE(NORMAL(3,TEMP_FACE_NUM))

    DISPLACEMENT(:,:) = 0.

    DO I=1,TEMP_FACE_NUM           
        I1 = TEMPFACE(1,I)
        I2 = TEMPFACE(2,I)
        I3 = TEMPFACE(3,I)

        V1 = TEMPPOINT(:,I2) - TEMPPOINT(:,I1)
        V2 = TEMPPOINT(:,I3) - TEMPPOINT(:,I1)    

        FACE_CENTER(:,I) = (TEMPPOINT(:,I1) + TEMPPOINT(:,I2) + TEMPPOINT(:,I3))/3.

        CALL VEC_CURL1(V1,V2, NORMAL(:,I))

        R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
        FACE_AREA(I) = R/2.
        NORMAL(:,I) = NORMAL(:,I) / R
    END DO

    DO I=1,TEMP_POINT_NUM
        IF(IS_INTERIOR_POINT(I)) THEN
            CON_NUM = TEMP_CONNECTION_NUM(I)

            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(W(CON_NUM))
            ALLOCATE(ORIGIN_W(CON_NUM))
            ALLOCATE(C(3,CON_NUM))

            W_SUM = 0.           
            ORIGIN_W_SUM = 0.
            THETA_A = 0.

            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(TEMP_CONNECTION(J,I))
                ORIGIN_W_SUM = ORIGIN_W_SUM + 1./TEMP_NEWFACEAREA(TEMP_CONNECTION(J,I))
                I1 = TEMPFACE(1,TEMP_CONNECTION(J,I))
                I2 = TEMPFACE(2,TEMP_CONNECTION(J,I))
                I3 = TEMPFACE(3,TEMP_CONNECTION(J,I))

                IF(I==I1) THEN
                ELSE IF(I==I2) THEN
                    TEMP_I = I1
                    I1 = I2
                    I2 = I3
                    I3 = TEMP_I
                ELSE
                    TEMP_I = I1
                    I1 = I3
                    I3 = I2
                    I2 = TEMP_I
                END IF

                V1 = TEMPPOINT(:,I2) - TEMPPOINT(:,I1)
                V2 = TEMPPOINT(:,I3) - TEMPPOINT(:,I1)
                THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            END DO

            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,TEMP_CONNECTION(J,I))
                W(J) = FACE_AREA(TEMP_CONNECTION(J,I)) / W_SUM
                ORIGIN_W(J) = (1./TEMP_NEWFACEAREA(TEMP_CONNECTION(J,I)))/ORIGIN_W_SUM
                C(:,J) = FACE_CENTER(:,TEMP_CONNECTION(J,I)) - TEMPPOINT(:,I)
            END DO

            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
            END DO

            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX

            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)

            DO J=1,3-1
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO

                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)

                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)

                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO

            THETA_A = THETA_A - 2.*PI

            PHI_R = 10. * PI/180.
            PHI_C = 45. * PI/180.

            CHI_R = 2.*(TAN(PHI_R/2.))**2
            CHI_C = 2.*(TAN(PHI_C/2.))**2

            IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
                LOCAL_SHAPE = 3
            ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF

            LOCAL_SHAPE = TEMPINITIALPOINT_TYPE(I)



            ALLOCATE(MU_I(CON_NUM))
            ALLOCATE(X_I(CON_NUM))
            ALLOCATE(Y_I(CON_NUM))
            ALLOCATE(DX_I(CON_NUM))
            ALLOCATE(DY_I(CON_NUM))
            ALLOCATE(C_I(CON_NUM))

            CALL VEC_CURL1(E_VECTOR(:,2), E_VECTOR(:,3), TEMPVEC)
            IF(DOT_PRODUCT(TEMPVEC, E_VECTOR(:,1)) > 0) THEN
                U = E_VECTOR(:,2)
                V = E_VECTOR(:,3)
            ELSE
                U = E_VECTOR(:,3)
                V = E_VECTOR(:,2)
            END IF

            MU_SUM = 0.

            DO J = 1,CON_NUM
                MU_SUM = MU_SUM + TEMP_NEWFACEAREA(TEMP_CONNECTION(J,I))
            END DO

            DO J = 1,CON_NUM
                MU_I(J) = TEMP_NEWFACEAREA(TEMP_CONNECTION(J,I)) / MU_SUM
                CALL POINT_NEIGHBOR_POINT(TEMPFACE, TEMP_CONNECTION, I, J,      I1)
                X_I(J) = DOT_PRODUCT(TEMPPOINT(:,I1), U)
                Y_I(J) = DOT_PRODUCT(TEMPPOINT(:,I1), V)
            END DO

            AREA = 0.
            DO J = 1,CON_NUM
                DX_I(J) = X_I(MOD(J,CON_NUM)+1) - X_I(J)
                DY_I(J) = Y_I(MOD(J,CON_NUM)+1) - Y_I(J)
                C_I(J) = 1./2. * X_I(J) * Y_I(MOD(J,CON_NUM)+1) - 1./2. * X_I(MOD(J,CON_NUM)+1) * Y_I(J)
                AREA = AREA + C_I(J)
            END DO

            FINAL_A = 0.
            FINAL_B = 0.
            FINAL_C = 0.
            FINAL_D = 0.
            FINAL_E = 0.

            DO J = 1,CON_NUM
                FINAL_A = FINAL_A + DX_I(J)**2
                FINAL_B = FINAL_B + DY_I(J)**2
                FINAL_C = FINAL_C + DX_I(J)*DY_I(J)
                FINAL_D = FINAL_D + 2.*DY_I(J)*(C_I(J)-MU_I(J)*AREA)
                FINAL_E = FINAL_E + 2.*DX_I(J)*(C_I(J)-MU_I(J)*AREA)
            END DO

            IF(FINAL_A*FINAL_B-FINAL_C**2 ==0) THEN
                J = 1
            END IF

            FINAL_X = 1./(FINAL_A*FINAL_B-FINAL_C**2) * (FINAL_A*FINAL_D-FINAL_C*FINAL_E)
            FINAL_Y = 1./(FINAL_A*FINAL_B-FINAL_C**2) * (FINAL_C*FINAL_D-FINAL_B*FINAL_E)

            INITIAL_X = DOT_PRODUCT(TEMPPOINT(:,I), U)
            INITIAL_Y = DOT_PRODUCT(TEMPPOINT(:,I), V)
            INITIAL_Z = DOT_PRODUCT(TEMPPOINT(:,I), E_VECTOR(:,1))

            CC = FINAL_X*U+FINAL_Y*V+INITIAL_Z*E_VECTOR(:,1) - TEMPPOINT(:,I)

            DEALLOCATE(MU_I)
            DEALLOCATE(X_I)
            DEALLOCATE(Y_I)
            DEALLOCATE(DX_I)
            DEALLOCATE(DY_I)
            DEALLOCATE(C_I)



            IF(LOCAL_SHAPE < 3) THEN

            ALLOCATE(T(3,3-LOCAL_SHAPE))

            DO J = LOCAL_SHAPE+1, 3
                T(:,J-LOCAL_SHAPE) = E_VECTOR(:,J)
            END DO

            DO K=1,3
                DO L=1,3
                    TT(K,L) = 0.
                    DO J=1,3-LOCAL_SHAPE
                        TT(K,L) = TT(K,L) + T(K,J)*T(L,J)    
                    END DO
                END DO
            END DO

            DISPLACEMENT(:,I) = 0.
            !DO J = 1,CON_NUM
            DO K = 1,3
                DO L = 1,3
                    !IF(LOCAL_SHAPE==1) THEN
                    DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + TT(K,L)*CC(L)/3.
                    !ELSE
                    !DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + W(J)*TT(K,L)*C(L,J)
                    !DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + ORIGIN_W(J)*TT(K,L)*C(L,J)/CON_NUM
                    !END IF
                END DO
            END DO
            !END DO
            DEALLOCATE(T)

            END IF

            DEALLOCATE(N)
            DEALLOCATE(W)
            DEALLOCATE(ORIGIN_W)
            DEALLOCATE(C)
        END IF
    END DO

    DO I = 1,TEMP_POINT_NUM
        TEMPPOINT(:,I) = TEMPPOINT(:,I) + DISPLACEMENT(:,I)
    END DO

    DEALLOCATE(NORMAL)
    DEALLOCATE(FACE_AREA)  
    DEALLOCATE(FACE_CENTER)
    DEALLOCATE(DISPLACEMENT)

    END SUBROUTINE AREA_BASED_NULLSPACE_SMOOTHING

    END MODULE
