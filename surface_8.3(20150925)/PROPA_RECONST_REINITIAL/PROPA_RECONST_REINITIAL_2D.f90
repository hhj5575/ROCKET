MODULE PROPA_RECONST_REINITIAL_2D
    USE SURFACE_MODULE_2D
    USE SURFACES_2D
    USE OPERATORS_2D
    USE EXTRAPOLATION_2D
    USE SRMS_DATATRANS_MOD_2D
    USE SVD
    IMPLICIT NONE

    CONTAINS 
    
    
    SUBROUTINE HC_ALGORITHM(TYP)
	IMPLICIT NONE
        INTEGER :: TYP
        !REAL(8) :: TIME_STEP
        
        INTEGER :: POINT_NUM
        REAL(8), POINTER, DIMENSION(:,:) :: POINT
        INTEGER, POINTER, DIMENSION(:,:) :: EDGE
        
        INTEGER, POINTER, DIMENSION(:,:) :: CONNECTION
        INTEGER, POINTER, DIMENSION(:) :: POINT_TYPE
        REAL(8), POINTER, DIMENSION(:) :: EDGE_LENGTH
        
        REAL(8), ALLOCATABLE :: ORIGINALPOINT(:,:)
        REAL(8), ALLOCATABLE :: BEFOREPOINT(:,:)
        REAL(8), ALLOCATABLE :: DIFFERENCE(:,:)
        
        REAL(8) :: ALPHA, BETA
        
        INTEGER :: I, J
        
        IF (TYP==0) THEN
            POINT_NUM = SURFACE_FLUID%SURFACE_POINTS_NUM
            POINT => SURFACE_FLUID%SURFACE_POINTS
            EDGE => SURFACE_FLUID%SURFACE_EDGES
            
            CONNECTION => SURFACE_FLUID%POINT_EDGE_CONNECTION
            POINT_TYPE => SURFACE_FLUID%POINT_TYPE
            EDGE_LENGTH => SURFACE_FLUID%SURFACE_INITIAL_EDGE_LENGTH
        END IF
        IF (TYP==1) THEN
            POINT_NUM = SURFACE_PROPEL%SURFACE_POINTS_NUM
            POINT => SURFACE_PROPEL%SURFACE_POINTS
            EDGE => SURFACE_PROPEL%SURFACE_EDGES
            
            CONNECTION => SURFACE_PROPEL%POINT_EDGE_CONNECTION
            POINT_TYPE => SURFACE_PROPEL%POINT_TYPE
            EDGE_LENGTH => SURFACE_PROPEL%SURFACE_INITIAL_EDGE_LENGTH
        END IF
        IF (TYP==2) THEN
            POINT_NUM = SURFACE_CASE%SURFACE_POINTS_NUM
            POINT => SURFACE_CASE%SURFACE_POINTS
            EDGE => SURFACE_CASE%SURFACE_EDGES
            
            CONNECTION => SURFACE_CASE%POINT_EDGE_CONNECTION
            POINT_TYPE => SURFACE_CASE%POINT_TYPE
            EDGE_LENGTH => SURFACE_CASE%SURFACE_INITIAL_EDGE_LENGTH
        END IF
        
        ALPHA = 0.1
        BETA = 0.6
        
        ALLOCATE(ORIGINALPOINT(2,POINT_NUM))
        ALLOCATE(BEFOREPOINT(2,POINT_NUM))
        ALLOCATE(DIFFERENCE(2,POINT_NUM))
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,POINT_NUM
            ORIGINALPOINT(:,I) = POINT(:,I)
        END DO
        !$OMP END PARALLEL DO
        
        DO J=1,30
            DO I=1,POINT_NUM
                BEFOREPOINT(:,I) = POINT(:,I)
            END DO
            
            DO I=1,POINT_NUM
                IF(POINT_TYPE(I)==1) THEN
                    POINT(:,I) = ( BEFOREPOINT(:,EDGE(1,CONNECTION(1,I))) + BEFOREPOINT(:,EDGE(2,CONNECTION(2,I))) )/2.
                    DIFFERENCE(:,I) = POINT(:,I) - (ALPHA*ORIGINALPOINT(:,I) + (1.-ALPHA)*BEFOREPOINT(:,I))
                ELSE
                    DIFFERENCE(1,I) = 0.
                    DIFFERENCE(2,I) = 0.
                END IF     
            END DO
            
            DO I=1,POINT_NUM
                IF(POINT_TYPE(I)==1) THEN
                    POINT(:,I) = POINT(:,I) - ( BETA*DIFFERENCE(:,I) + (1.-BETA) * ( DIFFERENCE(:,EDGE(1,CONNECTION(1,I))) + DIFFERENCE(:,EDGE(2,CONNECTION(2,I))) )/2. )
                END IF
            END DO
        END DO
        
        DEALLOCATE(ORIGINALPOINT)
        DEALLOCATE(BEFOREPOINT)
        DEALLOCATE(DIFFERENCE)
        
    END SUBROUTINE HC_ALGORITHM
    
    SUBROUTINE INTERPOLATE_FLUID_DISPLACEMENT(TYP1_POINT_NUM, TYP1_POINT, TYP1_POINTLOC, DATA_DISPLACEMENT)
        
	IMPLICIT NONE
    
        INTEGER :: I
        
        INTEGER :: TYP1_POINT_NUM
        REAL(8) :: TYP1_POINT(:,:)
        INTEGER :: TYP1_POINTLOC(:,:)
        
        INTEGER :: TYP2_POINT_NUM
        REAL(8), POINTER, DIMENSION(:,:) :: TYP2_POINT
        INTEGER, POINTER, DIMENSION(:,:) :: TYP2_POINTLOC
        
        REAL(8) :: DATA_DISPLACEMENT(:,:)
        
        REAL(8), ALLOCATABLE :: CR_SOURCE(:,:), CR_TARGET(:,:)
        
        CALL UPDATE_INTERFACE_CLUSTER(0)
        
        TYP2_POINT_NUM = INTERFACE_FLUID_POINTS_NUM
        TYP2_POINT => INTERFACE_FLUID_POINTS
        TYP2_POINTLOC => INTERFACE_FLUID_POINTS_LOC
        
        ALLOCATE(CR_SOURCE(2,TYP1_POINT_NUM))
        
	!$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP1_POINT_NUM
            CR_SOURCE(:,I) = DATA_DISPLACEMENT(:,TYP1_POINTLOC(1,I))
        END DO
        !$OMP END PARALLEL DO
        
        ALLOCATE(CR_TARGET(2,TYP2_POINT_NUM))
        
        CALL DATA_TRANSFER(TYP1_POINT_NUM, TYP1_POINT, CR_SOURCE(1,:), TYP2_POINT_NUM, TYP2_POINT, CR_TARGET(1,:))
        CALL DATA_TRANSFER(TYP1_POINT_NUM, TYP1_POINT, CR_SOURCE(2,:), TYP2_POINT_NUM, TYP2_POINT, CR_TARGET(2,:))
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP2_POINT_NUM
            SURFACE_FLUID%POINT_DISPLACEMENT(:,TYP2_POINTLOC(1,I)) = CR_TARGET(:,I)
        END DO
        !$OMP END PARALLEL DO
        
        DEALLOCATE(CR_SOURCE)
        DEALLOCATE(CR_TARGET)
        
    END SUBROUTINE INTERPOLATE_FLUID_DISPLACEMENT

    SUBROUTINE FLUID_MOVE(TIME_STEP) ! TYP = 0 or 1, TYP2 = 0
	IMPLICIT NONE
        REAL(8) :: TIME_STEP, ZETA
        INTEGER :: I,J, I1,I2, I3, J1, J2
        LOGICAL :: FLAG
	REAL(8) :: DIST1, DIST2, DIST3
 !      REAL(8) :: ZEROVEC(0)
        
        INTEGER, ALLOCATABLE :: PROPEL_MOVING_TYPE(:,:)
        
        INTEGER :: TYP1_POINT_NUM
        REAL(8), ALLOCATABLE :: TYP1_POINT(:,:)
        INTEGER, ALLOCATABLE :: TYP1_POINTLOC(:,:)
        REAL(8), ALLOCATABLE :: DATA_DISPLACEMENT(:,:)
        
        ALLOCATE(PROPEL_MOVING_TYPE(2,SURFACE_PROPEL%SURFACE_POINTS_NUM))
        PROPEL_MOVING_TYPE(:,:) = 0

        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_PROPEL%SURFACE_POINTS_NUM
	    I1 = SURFACE_PROPEL%POINT_EDGE_CONNECTION(1,I)
	    I2 = SURFACE_PROPEL%POINT_EDGE_CONNECTION(2,I)
                
            IF(SURFACE_PROPEL%EDGE_ONINTERFACE(I1) .NE. 0 .AND. SURFACE_PROPEL%EDGE_ONINTERFACE(I2) .NE. 0) THEN
            ELSE IF(SQRT(DOT_PRODUCT(SURFACE_PROPEL%SURFACE_POINTS(:,I) - SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)), SURFACE_PROPEL%SURFACE_POINTS(:,I) - SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)) )) < MINERROR) THEN
                PROPEL_MOVING_TYPE(1,I) = 1
                PROPEL_MOVING_TYPE(2,I) = SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)
            ELSE IF(SURFACE_PROPEL%POINT_TYPE(I) .EQ. 3)  THEN
                IF(SURFACE_PROPEL%EDGE_ONINTERFACE(I1) .EQ. 0) THEN
                    I3 = I2
                ELSE
                    I3 = I1
                END IF
                
                J = SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)
                DIST1 = SQRT(DOT_PRODUCT(SURFACE_PROPEL%SURFACE_POINTS(:,SURFACE_PROPEL%SURFACE_EDGES(1,I3))-SURFACE_FLUID%SURFACE_POINTS(:,J),SURFACE_PROPEL%SURFACE_POINTS(:,SURFACE_PROPEL%SURFACE_EDGES(1,I3))-SURFACE_FLUID%SURFACE_POINTS(:,J)))
                DIST2 = SQRT(DOT_PRODUCT(SURFACE_PROPEL%SURFACE_POINTS(:,SURFACE_PROPEL%SURFACE_EDGES(2,I3))-SURFACE_FLUID%SURFACE_POINTS(:,J),SURFACE_PROPEL%SURFACE_POINTS(:,SURFACE_PROPEL%SURFACE_EDGES(2,I3))-SURFACE_FLUID%SURFACE_POINTS(:,J)))
                DIST3 = SQRT(DOT_PRODUCT(SURFACE_PROPEL%SURFACE_POINTS(:,SURFACE_PROPEL%SURFACE_EDGES(1,I3))-SURFACE_PROPEL%SURFACE_POINTS(:,SURFACE_PROPEL%SURFACE_EDGES(2,I3)),SURFACE_PROPEL%SURFACE_POINTS(:,SURFACE_PROPEL%SURFACE_EDGES(1,I3))-SURFACE_PROPEL%SURFACE_POINTS(:,SURFACE_PROPEL%SURFACE_EDGES(2,I3))))
                
                IF(DIST1<DIST3 .AND. DIST2<DIST3) THEN
                    PROPEL_MOVING_TYPE(1,I) = 1
                    PROPEL_MOVING_TYPE(2,I) = SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)
                END IF

	    ELSE
                PROPEL_MOVING_TYPE(1,I) = 2
            END IF
        END DO
        !$OMP END PARALLEL DO 
        !$OMP PARALLEL DO PRIVATE(I)
        
 
        CALL FACEOFFSETTING_2D(0,TIME_STEP)
        
        ALLOCATE(TYP1_POINT(2,INTERFACE_FLUID_POINTS_NUM))
        ALLOCATE(TYP1_POINTLOC(2,INTERFACE_FLUID_POINTS_NUM))
        ALLOCATE(DATA_DISPLACEMENT(2,SURFACE_FLUID%SURFACE_POINTS_NUM))
        
        TYP1_POINT_NUM = INTERFACE_FLUID_POINTS_NUM
        TYP1_POINT = INTERFACE_FLUID_POINTS
        TYP1_POINTLOC = INTERFACE_FLUID_POINTS_LOC
        DATA_DISPLACEMENT = SURFACE_FLUID%POINT_DISPLACEMENT
        
        CALL MODIFIED_NULLSPACE_SMOOTHING(0)
        
        CALL INTERPOLATE_FLUID_DISPLACEMENT(TYP1_POINT_NUM, TYP1_POINT, TYP1_POINTLOC, DATA_DISPLACEMENT)
 
        CALL UPDATE_RELATEDEDGE(0,2,.FALSE.)
        ! testtest
        ! testtest
 	CALL UPDATE_RELATEDEDGE(1,0,.FALSE.)
 
	!DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
        !    I1 = SURFACE_FLUID%POINT_EDGE_CONNECTION(1,I)
        !    I2 = SURFACE_FLUID%POINT_EDGE_CONNECTION(2,I)	
	!       IF(SURFACE_FLUID%EDGE_ONINTERFACE(I1)==1 .OR. SURFACE_FLUID%EDGE_ONINTERFACE(I2)==1) THEN
	!           J = SURFACE_FLUID%POINT_RELATEDPT(1+1,I)
	!           R = SQRT(DOT_PRODUCT(SURFACE_FLUID%SURFACE_POINTS(:,I)-SURFACE_PROPEL%SURFACE_POINTS(:,J),SURFACE_FLUID%SURFACE_POINTS(:,I)-SURFACE_PROPEL%SURFACE_POINTS(:,J)))
	!              IF(SURFACE_FLUID%POINT_TYPE(I) .EQ. 3 .AND. R .GT. 2.*SURFACE_FLUID%MESH_SIZE) THEN
	!	         SURFACE_FLUID%POINT_TYPE(I) = 2
	!              END IF
	!       END IF
	!END DO

	!DO I=1,SURFACE_PROPEL%SURFACE_POINTS_NUM
	!   IF(SURFACE_PROPEL%POINT_TYPE(I) .EQ. 3 .AND. SURFACE_PROPEL%POINT_RELATEDPT(0+1,I) .EQ. 0) THEN
	!   !IF(SURFACE_PROPEL%POINT_TYPE(I) .EQ. 3) THEN
	!	   DO J=1,SURFACE_FLUID%SURFACE_POINTS_NUM
	!	      IF(SURFACE_FLUID%POINT_TYPE(J) .EQ. 3) THEN
	!		   DIST = SQRT(DOT_PRODUCT(SURFACE_PROPEL%SURFACE_POINTS(:,I)-SURFACE_FLUID%SURFACE_POINTS(:,J),SURFACE_PROPEL%SURFACE_POINTS(:,I)-SURFACE_FLUID%SURFACE_POINTS(:,J)))
	!		   IF(DIST<SURFACE_FLUID%MESH_SIZE/10.) THEN
	!		      JMIN = J
	!		      SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)= JMIN
	!		      I1 = SURFACE_PROPEL%POINT_EDGE_CONNECTION(1,I)
        !    		      I2 = SURFACE_PROPEL%POINT_EDGE_CONNECTION(2,I)
	!			IF(SURFACE_PROPEL%EDGE_ONINTERFACE(I1) .EQ. -1) THEN
	!			   J1 = SURFACE_PROPEL%POINT_EDGE_CONNECTION(1,SURFACE_PROPEL%SURFACE_EDGES(1,I1))
	!			   SURFACE_PROPEL%EDGE_ONINTERFACE(I1) = SURFACE_PROPEL%EDGE_ONINTERFACE(J1)				
	!			END IF
	!			IF(SURFACE_PROPEL%EDGE_ONINTERFACE(I2) .EQ. -1) THEN
	!			   J2 = SURFACE_PROPEL%POINT_EDGE_CONNECTION(2,SURFACE_PROPEL%SURFACE_EDGES(2,I2))
	!			   SURFACE_PROPEL%EDGE_ONINTERFACE(I2) = SURFACE_PROPEL%EDGE_ONINTERFACE(J2)				
	!			END IF
	!		      EXIT
	!		   END IF
	!	      END IF
	!	   END DO
	!   END IF
	!END DO

        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_PROPEL%SURFACE_POINTS_NUM
            IF(PROPEL_MOVING_TYPE(1,I) == 1) THEN
                SURFACE_PROPEL%SURFACE_POINTS(:,I) = SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_PROPEL%POINT_RELATEDPT(0+1,I))
            ELSE IF(PROPEL_MOVING_TYPE(1,I) == 2) THEN
		J = SURFACE_PROPEL%POINT_RELATEDEDGE(0+1,I)
		J1 = SURFACE_FLUID%SURFACE_EDGES(1,J)
		J2 = SURFACE_FLUID%SURFACE_EDGES(2,J)
                CALL PROJECTION_EDGE_POINT(SURFACE_PROPEL%SURFACE_POINTS(:,I),SURFACE_FLUID%SURFACE_POINTS(:,J1),SURFACE_FLUID%SURFACE_POINTS(:,J2),ZETA)
            END IF
        END DO
        !$OMP END PARALLEL DO

	!! NOZZLE ABLATION	
	CALL UPDATE_RELATEDEDGE(2,0,.TRUE.)


        CALL UPDATE_CASE_INTERFACE(FLAG)
        !IF(FLAG) THEN
            CALL FIND_INTERFACE_CLUSTER(1)
        !END IF
        
        CALL MODIFIED_NULLSPACE_SMOOTHING(1)
        CALL UPDATE_RELATEDEDGE(1,2,.TRUE.)

        CALL UPDATE_IMPACT_ZONE(0,0)
        CALL UPDATE_IMPACT_ZONE(0,2)
        CALL UPDATE_IMPACT_ZONE(1,1)

        
        CALL FIND_POINT_TYPE(2)
         
        CALL MAINTAIN_CASE_CORNER()
 
        DEALLOCATE(TYP1_POINT)
        DEALLOCATE(TYP1_POINTLOC)
        DEALLOCATE(DATA_DISPLACEMENT)
        
        DEALLOCATE(PROPEL_MOVING_TYPE)

    END SUBROUTINE FLUID_MOVE
    
    SUBROUTINE STRUCT_MOVE()
        IMPLICIT NONE
        INTEGER :: I
        REAL(8) :: ZEROVEC(0)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
            SURFACE_FLUID%POINT_VELOCITY(:,I) = 0.
        END DO
        !$OMP END PARALLEL DO
        
        CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_VELOCITY(1,:),SURFACE_CASE%POINT_VELOCITY(1,:),SURFACE_FLUID%POINT_VELOCITY(1,:),ZEROVEC)
        CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_VELOCITY(2,:),SURFACE_CASE%POINT_VELOCITY(2,:),SURFACE_FLUID%POINT_VELOCITY(2,:),ZEROVEC)
        
        DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
            SURFACE_FLUID%POINT_DISPLACEMENT(:,I) = SURFACE_FLUID%POINT_DISPLACEMENT(:,I) + SURFACE_FLUID%POINT_VELOCITY(:,I)
        END DO

        !!$OMP PARALLEL DO PRIVATE(I)
        !DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
        !    IF(SURFACE_FLUID%POINT_RELATEDPT(1+1,I).NE.0 .AND. SURFACE_FLUID%POINT_TYPE(I)==2) THEN
        !        SURFACE_FLUID%POINT_VELOCITY(:,I) = SURFACE_PROPEL%POINT_VELOCITY(:,SURFACE_FLUID%POINT_RELATEDPT(1+1,I))
        !    END IF
        !END DO
        !!$OMP END PARALLEL DO
        
        
!        !$OMP PARALLEL DO PRIVATE(I)
!        DO I=1,SURFACE_PROPEL%SURFACE_POINTS_NUM
!            SURFACE_PROPEL%SURFACE_POINTS(:,I) = SURFACE_PROPEL%SURFACE_POINTS(:,I) + SURFACE_PROPEL%POINT_VELOCITY(:,I)
!        END DO
!        !$OMP END PARALLEL DO      
!        !$OMP PARALLEL DO PRIVATE(I)
!        DO I=1,SURFACE_CASE%SURFACE_POINTS_NUM
!            SURFACE_CASE%SURFACE_POINTS(:,I) = SURFACE_CASE%SURFACE_POINTS(:,I) + SURFACE_CASE%POINT_VELOCITY(:,I)
!        END DO
!        !$OMP END PARALLEL DO
!      
!        !$OMP PARALLEL DO PRIVATE(I)
!        DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
!            SURFACE_FLUID%SURFACE_POINTS(:,I) = SURFACE_FLUID%SURFACE_POINTS(:,I) + SURFACE_FLUID%POINT_VELOCITY(:,I)
!        END DO
!        !$OMP END PARALLEL DO        
        
        
        !CALL UPDATE_RELATEDEDGE(0,2,.FALSE.) 
        !CALL UPDATE_RELATEDEDGE(1,2,.TRUE.)      

        !CALL UPDATE_IMPACT_ZONE(0,0) 
        !CALL UPDATE_IMPACT_ZONE(0,2)
        !CALL UPDATE_IMPACT_ZONE(1,1)
        
    END SUBROUTINE STRUCT_MOVE
    
    SUBROUTINE b_rate_TRANSFER()
        IMPLICIT NONE
        INTEGER :: I
        REAL(8), ALLOCATABLE :: FLUID_POINT_b_rate(:)
        
        INTEGER :: TYP1_POINT_NUM
        REAL(8), ALLOCATABLE :: TYP1_POINT(:,:)
        REAL(8), ALLOCATABLE :: INTERFACE_FLUID_PROPEL_POINTS(:,:)
        REAL(8), ALLOCATABLE :: INTERFACE_PROPEL_FLUID_POINTS(:,:)
        INTEGER, ALLOCATABLE :: FLUID_IND(:), FLUID_ORIGINAL_IND(:)
        INTEGER, ALLOCATABLE :: PROPEL_IND(:)        
        INTEGER :: TYP2_POINT_NUM
        INTEGER :: INTERFACE_FLUID_PROPEL_POINTS_NUM
	INTEGER :: INTERFACE_PROPEL_FLUID_POINTS_NUM
        REAL(8), ALLOCATABLE :: TYP2_POINT(:,:)
        
        REAL(8), ALLOCATABLE :: CR_SOURCE(:), CR_TARGET(:)
        !REAL(8), ALLOCATABLE :: NORMAL(:,:), POINT_FORCE(:,:)
	!REAL(8), ALLOCATABLE :: LENGTH(:)
        !REAL(8) :: V(2), TEMP_FORCE(2)
        
        !SURFACE_FLUID%POINT_FORCE(:,:) = 0.
        SURFACE_PROPEL%edge_b_rate = 0.
        SURFACE_CASE%edge_b_rate = 0.

	INTERFACE_FLUID_PROPEL_POINTS_NUM = 0
!	ALLOCATE(FLUID_IND(SURFACE_FLUID%SURFACE_EDGES_NUM))
!         DO I=1,SURFACE_FLUID%SURFACE_EDGES_NUM
!	IF(SURFACE_FLUID%EDGE_ONINTERFACE(I) .GT. 0 .AND. SURFACE_FLUID%EDGE_ONINTERFACE(I) .LT. 2) THEN
!	INTERFACE_FLUID_PROPEL_POINTS_NUM = INTERFACE_FLUID_PROPEL_POINTS_NUM +1
!	FLUID_IND(INTERFACE_FLUID_PROPEL_POINTS_NUM) = I
!	END IF
!        END DO

	ALLOCATE(FLUID_IND(INTERFACE_FLUID_POINTS_NUM))
	ALLOCATE(FLUID_ORIGINAL_IND(INTERFACE_FLUID_POINTS_NUM))

        DO I=1,INTERFACE_FLUID_POINTS_NUM
	IF(SURFACE_FLUID%EDGE_ONINTERFACE(SURFACE_FLUID%POINT_EDGE_CONNECTION(1,INTERFACE_FLUID_POINTS_LOC(1,I))) .EQ. 1 .OR. SURFACE_FLUID%EDGE_ONINTERFACE(SURFACE_FLUID%POINT_EDGE_CONNECTION(2,INTERFACE_FLUID_POINTS_LOC(1,I))) .EQ. 1) THEN
	INTERFACE_FLUID_PROPEL_POINTS_NUM = INTERFACE_FLUID_PROPEL_POINTS_NUM +1
	FLUID_IND(INTERFACE_FLUID_PROPEL_POINTS_NUM) = I
	FLUID_ORIGINAL_IND(INTERFACE_FLUID_PROPEL_POINTS_NUM) = INTERFACE_FLUID_POINTS_LOC(1,I)
	END IF
        END DO

	ALLOCATE(FLUID_POINT_b_rate(INTERFACE_FLUID_PROPEL_POINTS_NUM))
	ALLOCATE(INTERFACE_FLUID_PROPEL_POINTS(2,INTERFACE_FLUID_PROPEL_POINTS_NUM))
        FLUID_POINT_b_rate(:) = 0.

        DO I=1,INTERFACE_FLUID_PROPEL_POINTS_NUM
	!IF(SURFACE_FLUID%EDGE_ONINTERFACE(FLUID_IND(I)) .GT. 0 .AND. SURFACE_FLUID%EDGE_ONINTERFACE(FLUID_IND(I)) .LT. 2) THEN
	!   FLUID_POINT_b_rate(SURFACE_FLUID%SURFACE_EDGES(1,FLUID_IND(I))) = FLUID_POINT_b_rate(SURFACE_FLUID%SURFACE_EDGES(1,FLUID_IND(I))) + SURFACE_FLUID%EDGE_b_rate(FLUID_IND(I))/2.
        !   FLUID_POINT_b_rate(SURFACE_FLUID%SURFACE_EDGES(2,FLUID_IND(I))) = FLUID_POINT_b_rate(SURFACE_FLUID%SURFACE_EDGES(2,FLUID_IND(I))) + SURFACE_FLUID%EDGE_b_rate(FLUID_IND(I))/2.
	
	!   INTERFACE_FLUID_PROPEL_POINTS(:,I) = SURFACE_FLUID%SURFACE_POINTS(:,INTERFACE_FLUID_POINTS_LOC(1,FLUID_IND(I)))
	!END IF
	
	 IF(SURFACE_FLUID%EDGE_ONINTERFACE(SURFACE_FLUID%POINT_EDGE_CONNECTION(1,FLUID_ORIGINAL_IND(I))) .EQ. 1 .OR. SURFACE_FLUID%EDGE_ONINTERFACE(SURFACE_FLUID%POINT_EDGE_CONNECTION(2,FLUID_ORIGINAL_IND(I))) .EQ. 1) THEN
            FLUID_POINT_B_RATE(I) = FLUID_POINT_B_RATE(I) + SURFACE_FLUID%EDGE_b_rate(SURFACE_FLUID%POINT_EDGE_CONNECTION(1,FLUID_ORIGINAL_IND(I)))/2.
            FLUID_POINT_B_RATE(I) = FLUID_POINT_B_RATE(I) + SURFACE_FLUID%EDGE_b_rate(SURFACE_FLUID%POINT_EDGE_CONNECTION(2,FLUID_ORIGINAL_IND(I)))/2.

	    INTERFACE_FLUID_PROPEL_POINTS(:,I) = SURFACE_FLUID%SURFACE_POINTS(:,FLUID_ORIGINAL_IND(I))
	 END IF
	 END DO
    
        !CALL UPDATE_INTERFACE_CLUSTER(0)
        !CALL UPDATE_INTERFACE_CLUSTER(1)
        
        ALLOCATE(PROPEL_IND(INTERFACE_STRUCT_POINTS_NUM))
	PROPEL_IND = 0
	INTERFACE_propel_fluid_POINTS_NUM = 0
	!$OMP PARALLEL DO PRIVATE(I)
	DO I=1,INTERFACE_STRUCT_POINTS_NUM
	IF(INTERFACE_STRUCT_POINTS_LOC(2,I)==1 .OR. (INTERFACE_STRUCT_POINTS_LOC(2,I)==2 .AND. (SURFACE_CASE%EDGE_ONINTERFACE(SURFACE_CASE%POINT_EDGE_CONNECTION(1,INTERFACE_STRUCT_POINTS_LOC(1,I))) == 1 .OR. SURFACE_CASE%EDGE_ONINTERFACE(SURFACE_CASE%POINT_EDGE_CONNECTION(2,INTERFACE_STRUCT_POINTS_LOC(1,I))) == 1))) THEN
	INTERFACE_propel_fluid_POINTS_NUM =  INTERFACE_propel_fluid_POINTS_NUM +1
	PROPEL_IND(INTERFACE_propel_fluid_POINTS_NUM) = I
	end if
	END DO
	!$OMP END PARALLEL DO

        allocate(INTERFACE_propel_FLUID_POINTS(2,INTERFACE_propel_fluid_POINTS_NUM))
	INTERFACE_propel_FLUID_POINTS = 0
	!$OMP PARALLEL DO PRIVATE(I)
	DO I=1,INTERFACE_propel_fluid_POINTS_NUM
	INTERFACE_propel_FLUID_POINTS(:,I) = SURFACE_PROPEL%SURFACE_POINTS(:,INTERFACE_STRUCT_POINTS_LOC(1,PROPEL_IND(I)))
	END DO
	!$OMP END PARALLEL DO

        TYP1_POINT_NUM = INTERFACE_FLUID_PROPEL_POINTS_NUM * 2 - 1
        ALLOCATE(TYP1_POINT(2,TYP1_POINT_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP1_POINT_NUM
            IF(MOD(I,2)==1) THEN
                TYP1_POINT(:,I) = INTERFACE_FLUID_PROPEL_POINTS(:,(I+1)/2)
            ELSE
                TYP1_POINT(:,I) = (INTERFACE_FLUID_PROPEL_POINTS(:,I/2) + INTERFACE_FLUID_PROPEL_POINTS(:,I/2 + 1))/2.
            END IF
        END DO
        !$OMP END PARALLEL DO
        
        ALLOCATE(CR_SOURCE(TYP1_POINT_NUM))
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP1_POINT_NUM
            IF(MOD(I,2)==1) THEN
                CR_SOURCE(I) = FLUID_POINT_b_rate((I+1)/2)
            ELSE
                CR_SOURCE(I) = SURFACE_FLUID%edge_b_rate(SURFACE_FLUID%POINT_EDGE_CONNECTION(2,FLUID_ORIGINAL_IND(I/2)))
            END IF
        END DO
        !$OMP END PARALLEL DO
        
        TYP2_POINT_NUM = INTERFACE_PROPEL_FLUID_POINTS_NUM * 2 - 1
        ALLOCATE(TYP2_POINT(2,TYP2_POINT_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP2_POINT_NUM
            IF(MOD(I,2)==1) THEN
                TYP2_POINT(:,I) = INTERFACE_PROPEL_FLUID_POINTS(:,(I+1)/2)
            ELSE
                TYP2_POINT(:,I) = (INTERFACE_PROPEL_FLUID_POINTS(:,I/2) + INTERFACE_PROPEL_FLUID_POINTS(:,I/2 + 1))/2.
            END IF
        END DO
        !$OMP END PARALLEL DO
        
        ALLOCATE(CR_TARGET(TYP2_POINT_NUM))
        
        CALL DATA_TRANSFER(TYP1_POINT_NUM, TYP1_POINT, CR_SOURCE, TYP2_POINT_NUM, TYP2_POINT, CR_TARGET)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,INTERFACE_PROPEL_FLUID_POINTS_NUM-1
            SURFACE_PROPEL%edge_b_rate(SURFACE_PROPEL%point_edge_connection(1,INTERFACE_STRUCT_POINTS_LOC(1,PROPEL_IND(I)))) = -CR_TARGET(2*I)
        END DO
        !$OMP END PARALLEL DO
        
	DEALLOCATE(FLUID_IND)
	DEALLOCATE(PROPEL_IND)
        DEALLOCATE(TYP1_POINT)
        DEALLOCATE(TYP2_POINT)
        DEALLOCATE(CR_SOURCE)
        DEALLOCATE(CR_TARGET)
        DEallocate(INTERFACE_propel_FLUID_POINTS)
        DEallocate(INTERFACE_FLUID_PROPEL_POINTS)       
        DEALLOCATE(FLUID_POINT_b_rate)
        
    END SUBROUTINE b_rate_TRANSFER
    
    
    !! MODIFIED
    SUBROUTINE PRESSURE_TRANSFER()
        IMPLICIT NONE
        INTEGER :: I
        REAL(8), ALLOCATABLE :: FLUID_POINT_PRESSURE(:)
        
        INTEGER :: TYP1_POINT_NUM
        REAL(8), ALLOCATABLE :: TYP1_POINT(:,:)
        
        INTEGER :: TYP2_POINT_NUM
        REAL(8), ALLOCATABLE :: TYP2_POINT(:,:)
        
        REAL(8), ALLOCATABLE :: CR_SOURCE(:), CR_TARGET(:)
        REAL(8), ALLOCATABLE :: NORMAL(:,:), LENGTH(:), POINT_FORCE(:,:)
	REAL(8), ALLOCATABLE :: EDGE_LENGTH(:)
        REAL(8) :: V(2), TEMP_FORCE(2)
	CHARACTER(500) :: STR, STR2
	REAL(8) :: FLUID_TOTAL_PRESSURE, STRUCT_TOTAL_PRESSURE
        
        REAL(8) :: POINT_I(2), POINT_I1(2)
        
        SURFACE_FLUID%POINT_FORCE(:,:) = 0.
        SURFACE_PROPEL%POINT_FORCE(:,:) = 0.
        SURFACE_CASE%POINT_FORCE(:,:) = 0.
        
        ALLOCATE(FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_POINTS_NUM))
        FLUID_POINT_PRESSURE(:) = 0.
        DO I=1,SURFACE_FLUID%SURFACE_EDGES_NUM
            FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_EDGES(1,I)) = FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_EDGES(1,I)) + SURFACE_FLUID%EDGE_PRESSURE(I)/2.
            FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_EDGES(2,I)) = FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_EDGES(2,I)) + SURFACE_FLUID%EDGE_PRESSURE(I)/2.
        END DO
        
        CALL UPDATE_INTERFACE_CLUSTER(0)
        CALL UPDATE_INTERFACE_CLUSTER(1)
        
        TYP1_POINT_NUM = INTERFACE_FLUID_POINTS_NUM * 2 - 1
        ALLOCATE(TYP1_POINT(2,TYP1_POINT_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP1_POINT_NUM
            IF(MOD(I,2)==1) THEN
                TYP1_POINT(:,I) = INTERFACE_FLUID_POINTS(:,(I+1)/2)
            ELSE
                TYP1_POINT(:,I) = (INTERFACE_FLUID_POINTS(:,I/2) + INTERFACE_FLUID_POINTS(:,I/2 + 1))/2.
            END IF
        END DO
        !$OMP END PARALLEL DO

	ALLOCATE(EDGE_LENGTH(TYP1_POINT_NUM-1))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP1_POINT_NUM-1
	   EDGE_LENGTH(I) = SQRT(DOT_PRODUCT(TYP1_POINT(:,I+1)-TYP1_POINT(:,I),TYP1_POINT(:,I+1)-TYP1_POINT(:,I)))    
        END DO
        !$OMP END PARALLEL DO
        
        ALLOCATE(CR_SOURCE(TYP1_POINT_NUM))
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP1_POINT_NUM
            IF(MOD(I,2)==1) THEN
                CR_SOURCE(I) = FLUID_POINT_PRESSURE(INTERFACE_FLUID_POINTS_LOC(1,(I+1)/2))
            ELSE
                CR_SOURCE(I) = SURFACE_FLUID%EDGE_PRESSURE(SURFACE_FLUID%POINT_EDGE_CONNECTION(2,INTERFACE_FLUID_POINTS_LOC(1,I/2)))
            END IF
	    
        END DO
        !$OMP END PARALLEL DO

	FLUID_TOTAL_PRESSURE = 0.
        DO I=1,TYP1_POINT_NUM-1
	   FLUID_TOTAL_PRESSURE = FLUID_TOTAL_PRESSURE + (CR_SOURCE(I+1)+CR_SOURCE(I))/2.*EDGE_LENGTH(I)
        END DO
    
        TYP2_POINT_NUM = INTERFACE_STRUCT_POINTS_NUM * 2 - 1
        ALLOCATE(TYP2_POINT(2,TYP2_POINT_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP2_POINT_NUM
            IF(MOD(I,2)==1) THEN
                TYP2_POINT(:,I) = INTERFACE_STRUCT_POINTS(:,(I+1)/2)
            ELSE
                TYP2_POINT(:,I) = (INTERFACE_STRUCT_POINTS(:,I/2) + INTERFACE_STRUCT_POINTS(:,I/2 + 1))/2.
            END IF
        END DO
        !$OMP END PARALLEL DO
        
        ALLOCATE(CR_TARGET(TYP2_POINT_NUM))

!WRITE(STR2, *), surface_pressure_iter
        
!STR = './output/surface/CR_output/source_data'// TRIM(ADJUSTL(STR2)) // '.txt'
!write(*,*) TRIM(STR)
!OPEN(UNIT=21, FILE = STR, ACTION = "WRITE", STATUS = "REPLACE")
        
!DO I = 1, TYP1_POINT_NUM
!WRITE(21,'(F)') CR_SOURCE(I)
!END DO
!CLOSE(21)

        CALL DATA_TRANSFER(TYP1_POINT_NUM, TYP1_POINT, CR_SOURCE, TYP2_POINT_NUM, TYP2_POINT, CR_TARGET)
        
!STR = './output/surface/CR_output/target_data'// TRIM(ADJUSTL(STR2)) // '.txt'
!write(*,*) TRIM(STR)
!OPEN(UNIT=21, FILE = STR, ACTION = "WRITE", STATUS = "REPLACE")
!DO I = 1, TYP2_POINT_NUM
!WRITE(21,'(F,F)') CR_TARGET(I)
!END DO
!CLOSE(21)

        ALLOCATE(NORMAL(2,INTERFACE_STRUCT_POINTS_NUM))
        ALLOCATE(LENGTH(INTERFACE_STRUCT_POINTS_NUM))
        
        DO I=1,INTERFACE_STRUCT_POINTS_NUM - 1
            
            IF(INTERFACE_STRUCT_POINTS_LOC(2,I)==1) THEN
                POINT_I = INTERFACE_STRUCT_POINTS(:,I) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,INTERFACE_STRUCT_POINTS_LOC(1,I))
            ELSE
                POINT_I = INTERFACE_STRUCT_POINTS(:,I) + SURFACE_CASE%POINT_DISPLACEMENT(:,INTERFACE_STRUCT_POINTS_LOC(1,I))
            END IF
            
            IF(INTERFACE_STRUCT_POINTS_LOC(2,I+1)==1) THEN
                POINT_I1 = INTERFACE_STRUCT_POINTS(:,I+1) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,INTERFACE_STRUCT_POINTS_LOC(1,I+1))
            ELSE
                POINT_I1 = INTERFACE_STRUCT_POINTS(:,I+1) + SURFACE_CASE%POINT_DISPLACEMENT(:,INTERFACE_STRUCT_POINTS_LOC(1,I+1))
            END IF
            
            !V = INTERFACE_STRUCT_POINTS(:,I+1) - INTERFACE_STRUCT_POINTS(:,I)
            V = POINT_I1 - POINT_I
            
            NORMAL(1,I) = V(2)
            NORMAL(2,I) = -V(1)
            
            LENGTH(I) = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
            
            NORMAL(:,I) = NORMAL(:,I)/LENGTH(I)            
        END DO
        
        ALLOCATE(POINT_FORCE(2,INTERFACE_STRUCT_POINTS_NUM))
        POINT_FORCE(:,:) = 0.

        DO I=1,INTERFACE_STRUCT_POINTS_NUM - 1
            TEMP_FORCE = CR_TARGET(2*I) * LENGTH(I)/2. * NORMAL(:,I)
		IF(INTERFACE_STRUCT_POINTS_LOC(2,I) == 1) THEN
		    SURFACE_PROPEL%EDGE_PRESSURE(SURFACE_PROPEL%POINT_EDGE_CONNECTION(2,INTERFACE_STRUCT_POINTS_LOC(1,I))) = CR_TARGET(2*I)
		ELSE
		    SURFACE_CASE%EDGE_PRESSURE(SURFACE_CASE%POINT_EDGE_CONNECTION(2,INTERFACE_STRUCT_POINTS_LOC(1,I))) = CR_TARGET(2*I)
		END IF
            POINT_FORCE(:,I) = POINT_FORCE(:,I) + TEMP_FORCE
            POINT_FORCE(:,I+1) = POINT_FORCE(:,I+1) + TEMP_FORCE
        END DO

        STRUCT_TOTAL_PRESSURE = 0.   
     
        DO I=1,TYP2_POINT_NUM-1
            IF(MOD(I,2)==1) THEN
	       STRUCT_TOTAL_PRESSURE = STRUCT_TOTAL_PRESSURE + (CR_TARGET(I+1)+CR_TARGET(I))/2.*LENGTH((I+1)/2)/2.
            ELSE
	       STRUCT_TOTAL_PRESSURE = STRUCT_TOTAL_PRESSURE + (CR_TARGET(I+1)+CR_TARGET(I))/2.*LENGTH(I/2)/2.
            END IF

        END DO

        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,INTERFACE_STRUCT_POINTS_NUM
            IF(INTERFACE_STRUCT_POINTS_LOC(2,I)==1) THEN
                SURFACE_PROPEL%POINT_FORCE(:,INTERFACE_STRUCT_POINTS_LOC(1,I)) = POINT_FORCE(:,I)
            ELSE
                SURFACE_CASE%POINT_FORCE(:,INTERFACE_STRUCT_POINTS_LOC(1,I)) = POINT_FORCE(:,I)
            END IF
        END DO
        !$OMP END PARALLEL DO

        TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,1) = FLUID_TOTAL_PRESSURE
        TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,2) = STRUCT_TOTAL_PRESSURE
	
	IF(FLUID_TOTAL_PRESSURE .NE. 0) THEN
           TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,3) = (STRUCT_TOTAL_PRESSURE-FLUID_TOTAL_PRESSURE)/(FLUID_TOTAL_PRESSURE) 
	END IF
        STR = './output/surface/totalpressure2d.txt'
        
        OPEN(UNIT=21, FILE = STR, ACTION = "WRITE", STATUS = "REPLACE")
        
        DO I = 1, SURFACE_PRESSURE_ITER
            WRITE(21,'(F,F,F)') TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,1), TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,2), TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,3)
        END DO
    
        CLOSE(21)

!STR = './output/surface/CR_output/normal_deformed(target_domain_data)'// TRIM(ADJUSTL(STR2)) // '.txt'
!write(*,*) TRIM(STR)
!OPEN(UNIT=21, FILE = STR, ACTION = "WRITE", STATUS = "REPLACE")
!DO I=1,INTERFACE_STRUCT_POINTS_NUM - 1
!WRITE(21,'(F,F)') NORMAL(1,I), NORMAL(2,I)
!END DO
!CLOSE(21)
        
	DEALLOCATE(EDGE_LENGTH)
        DEALLOCATE(POINT_FORCE)
        DEALLOCATE(NORMAL)
        DEALLOCATE(LENGTH)
        DEALLOCATE(TYP1_POINT)
        DEALLOCATE(TYP2_POINT)
        DEALLOCATE(CR_SOURCE)
        DEALLOCATE(CR_TARGET)
        
        DEALLOCATE(FLUID_POINT_PRESSURE)
        
    END SUBROUTINE PRESSURE_TRANSFER
    !! END MODIFIED
    
    SUBROUTINE WAVEFRONT_DISPLACEMENT(TYP, TIMESTEP, RESULT_TIMESTEP)
        IMPLICIT NONE
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        INTEGER :: TYP
        REAL(8) :: TIMESTEP, RESULT_TIMESTEP
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        REAL(8), ALLOCATABLE :: DISPLACEMENT_THRESHOLD(:)
        INTEGER, ALLOCATABLE :: NEXT_RELATEDEDGE(:)
        INTEGER :: IMIN
        
        REAL(8), ALLOCATABLE :: EDGE_LENGTH(:)
        REAL(8), ALLOCATABLE :: EDGE_CENTER(:,:)
        
        INTEGER :: I,J,K,L
        INTEGER :: I1,I2
        REAL(8) :: V1(2),V2(2)
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        
        INTEGER :: LOCAL_SHAPE
        
        REAL(8) :: N(2,2), A(2), W(2)
        REAL(8) :: W_SUM
        REAL(8) :: B(2)
        
        REAL(8) :: E_VALUE(2)
        REAL(8) :: E_VECTOR(2,2), DUMMY(2,2)
        
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(2)
        
        REAL(8), ALLOCATABLE :: TEMPPOINT(:,:)
        
        REAL(8), ALLOCATABLE :: LENGTH(:)
        REAL(8) :: MU(2), LL(2), COSTHETA(2)
        REAL(8) :: MU_SUM
        LOGICAL :: EXPANDING
        
        REAL(8) :: D(2)
        
        REAL(8) :: THETA_A !CHI_C
        
        REAL(8) :: R
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        ALLOCATE(DISPLACEMENT(2,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        ALLOCATE(DISPLACEMENT_THRESHOLD(SURFACE_CURRENT%SURFACE_POINTS_NUM))
        DISPLACEMENT_THRESHOLD(:) = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2))
        ALLOCATE(NEXT_RELATEDEDGE(SURFACE_CURRENT%SURFACE_POINTS_NUM))
        NEXT_RELATEDEDGE(:) = 0
        
        ALLOCATE(EDGE_LENGTH(SURFACE_CURRENT%SURFACE_EDGES_NUM))
        ALLOCATE(NORMAL(2,SURFACE_CURRENT%SURFACE_EDGES_NUM))
        
        !$OMP PARALLEL DO PRIVATE(I,I1,I2,V1)
        DO I=1,SURFACE_CURRENT%SURFACE_EDGES_NUM
            
            I1 = SURFACE_CURRENT%SURFACE_EDGES(1,I)
            I2 = SURFACE_CURRENT%SURFACE_EDGES(2,I)
            
            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            
            NORMAL(1,I) = V1(2)
            NORMAL(2,I) = -V1(1)
            
            EDGE_LENGTH(I) = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
            
            NORMAL(:,I) = NORMAL(:,I)/EDGE_LENGTH(I)            
        END DO
        !$OMP END PARALLEL DO
    
        !! MODIFIED
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            
            W_SUM = 0.
            DO J = 1,2
                W_SUM = W_SUM + EDGE_LENGTH(SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))
            END DO
            
            DO J = 1,2
                N(J,:) = NORMAL(:,SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))
                W(J) = EDGE_LENGTH(SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I)) / W_SUM
                A(J) = TIMESTEP * SURFACE_CURRENT%EDGE_B_RATE(SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))
            END DO

            DO K=1,2
                DO L=1,2
                    E_VECTOR(K,L) = 0.
                    DO J = 1,2
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
                
                B(K) = 0.
                DO J = 1,2
                    B(K) = B(K) + W(J)*N(J,K)*A(J)
                END DO
            END DO
            

            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP(E_VECTOR,2,2,2,2,E_VALUE,DUMMY)
            
            IF(E_VALUE(2)>E_VALUE(1)) THEN
                TEMP_E_VALUE = E_VALUE(1)
                TEMP_E_VECTOR = E_VECTOR(:,1)
                    
                E_VALUE(1) = E_VALUE(2)
                E_VECTOR(:,1) = E_VECTOR(:,2)
                    
                E_VALUE(2) = TEMP_E_VALUE
                E_VECTOR(:,2) = TEMP_E_VECTOR(:)
            END IF
            

            I1 = SURFACE_CURRENT%SURFACE_EDGES(1,SURFACE_CURRENT%POINT_EDGE_CONNECTION(1,I))
            I2 = SURFACE_CURRENT%SURFACE_EDGES(2,SURFACE_CURRENT%POINT_EDGE_CONNECTION(2,I))
            
            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I1) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I)

            THETA_A = ACOS(MAX(-1.,MIN(1.,DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)))) ) - PI
            !THETA_A = PI/3.
            !CHI_C = 0.003

            IF(E_VALUE(2)/E_VALUE(1) > CHI_C_LOW .OR. ABS(THETA_A) >= PI/2.) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF

            DISPLACEMENT(:,I) = 0.
            DO J = 1,LOCAL_SHAPE
                DISPLACEMENT(:,I) = DISPLACEMENT(:,I) + DOT_PRODUCT(E_VECTOR(:,J),B(:))/E_VALUE(J) * E_VECTOR(:,J)
            END DO

        END DO
        
        CALL NEAR_CASE_DISPLACEMENT(TYP, DISPLACEMENT, DISPLACEMENT_THRESHOLD, NEXT_RELATEDEDGE)

        !! END MODIFIED
        
        ALLOCATE(TEMPPOINT(2,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        !$OMP PARALLEL DO PRIVATE(I)
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            TEMPPOINT(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)
        END DO
        !$OMP END PARALLEL DO
        
        ALLOCATE(LENGTH(SURFACE_CURRENT%SURFACE_POINTS_NUM))
        LENGTH(:) = 0.
        
        ALLOCATE(EDGE_CENTER(2,SURFACE_CURRENT%SURFACE_EDGES_NUM))
        
        !$OMP PARALLEL DO PRIVATE(I,I1,I2)
        DO I=1,SURFACE_CURRENT%SURFACE_EDGES_NUM
            
            I1 = SURFACE_CURRENT%SURFACE_EDGES(1,I)
            I2 = SURFACE_CURRENT%SURFACE_EDGES(2,I)
            
            !! MODIFIED
            !EDGE_CENTER(:,I) = (TEMPPOINT(:,I1) + TEMPPOINT(:,I2))/2.
            EDGE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2))/2.
            !! END MODIFIED
            
        END DO
        !$OMP END PARALLEL DO
        
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))<MINERROR) THEN
                LENGTH(I) = 0.
            ELSE
                MU_SUM = 0.
            
                DO J = 1,2
                    W(J) = EDGE_LENGTH(SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))
                    A(J) = TIMESTEP * SURFACE_CURRENT%EDGE_B_RATE(SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))
                    COSTHETA(J) = DOT_PRODUCT(DISPLACEMENT(:,I), NORMAL(:,SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))) &
                    /SQRT( DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)) * DOT_PRODUCT(NORMAL(:,SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I)),NORMAL(:,SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))) )
                    
                    ! HOW TO EXPANDING?
                    !! MODIFIED
                    !D(:) = EDGE_CENTER(:,SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I)) - TEMPPOINT(:,I)
                    D(:) = EDGE_CENTER(:,SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                    !! END MODIFIED
                
                    IF(DOT_PRODUCT(DISPLACEMENT(:,I),D)<0) THEN
                        EXPANDING = .TRUE.
                    ELSE
                        EXPANDING = .FALSE.
                    END IF
                
                    IF(EXPANDING) THEN
                        MU(J) = W(J)
                        LL(J) = ABS(A(J))
                    ELSE
                        MU(J) = W(J) * ABS(COSTHETA(J))
                    
                        IF(ABS(MU(J))<MINERROR) THEN
                            LL(J) = 0.
                        ELSE
                            LL(J) = ABS(A(J)) / ABS(COSTHETA(J))
                        END IF
                    END IF
                    
                    IF(ABS(LL(J))>=MINERROR) THEN
                        MU_SUM = MU_SUM + MU(J)
                        LENGTH(I) = LENGTH(I) + MU(J)*LL(J)
                    END IF
            
                END DO
                
                IF(MU_SUM >= MINERROR) THEN
                    LENGTH(I) = LENGTH(I) / MU_SUM
                END IF
            END IF
            
        END DO
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))>=MINERROR) DISPLACEMENT(:,I) = LENGTH(I) * DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))
        END DO
        !$OMP END PARALLEL DO
        
        RESULT_TIMESTEP = TIMESTEP
        IMIN = 0
        DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
            R = 0.
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))>=MINERROR) THEN
                R = SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))/TIMESTEP
                IF(RESULT_TIMESTEP > DISPLACEMENT_THRESHOLD(I)/R) THEN
                    RESULT_TIMESTEP = DISPLACEMENT_THRESHOLD(I)/R
                    IMIN = I
                END IF
            END IF
        END DO

        IF(IMIN .NE. 0) THEN
            SURFACE_CURRENT%POINT_RELATEDEDGE(2+1, IMIN) = NEXT_RELATEDEDGE(IMIN)
        END IF
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)/TIMESTEP * RESULT_TIMESTEP
        END DO
        !$OMP END PARALLEL DO

        DEALLOCATE(LENGTH)
        DEALLOCATE(EDGE_CENTER)
        
        DEALLOCATE(TEMPPOINT)
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(EDGE_LENGTH)
        
        DEALLOCATE(NEXT_RELATEDEDGE)
        DEALLOCATE(DISPLACEMENT_THRESHOLD)
        DEALLOCATE(DISPLACEMENT)
        
    END SUBROUTINE WAVEFRONT_DISPLACEMENT
    
    SUBROUTINE NEAR_CASE_DISPLACEMENT(TYP, DISPLACEMENT, DISPLACEMENT_THRESHOLD, NEXT_RELATEDEDGE)
	IMPLICIT NONE
        INTEGER :: TYP
        REAL(8) :: DISPLACEMENT(:,:)
        REAL(8) :: DISPLACEMENT_THRESHOLD(:)
        INTEGER :: NEXT_RELATEDEDGE(:)
        
        INTEGER :: I, I1, I2, J
        REAL(8) :: R, TEMP
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            !! TESTTEST !!
            !IF((SURFACE_CURRENT%EDGE_ONINTERFACE(SURFACE_CURRENT%POINT_EDGE_CONNECTION(1,I))==1 .XOR. SURFACE_CURRENT%EDGE_ONINTERFACE(SURFACE_CURRENT%POINT_EDGE_CONNECTION(2,I))==1) .OR. &
            !  (SURFACE_CURRENT%EDGE_ONINTERFACE(SURFACE_CURRENT%POINT_EDGE_CONNECTION(1,I))==0 .XOR. SURFACE_CURRENT%EDGE_ONINTERFACE(SURFACE_CURRENT%POINT_EDGE_CONNECTION(2,I))==0)) THEN
            IF(SURFACE_CURRENT%EDGE_ONINTERFACE(SURFACE_CURRENT%POINT_EDGE_CONNECTION(1,I))==2 .XOR. SURFACE_CURRENT%EDGE_ONINTERFACE(SURFACE_CURRENT%POINT_EDGE_CONNECTION(2,I))==2) THEN
                
                CALL PROJECTION_SURFACE_POINT_TYPE(SURFACE_FLUID%SURFACE_POINTS(:,I), 2, TEMP)
                
                IF(SURFACE_CURRENT%POINT_RELATEDEDGE(2+1,I) .NE. 0) THEN
                    R = SQRT(DOT_PRODUCT(DISPLACEMENT(:,I), DISPLACEMENT(:,I)))
                    
                    J = SURFACE_CURRENT%POINT_RELATEDEDGE(2+1,I)
                    
                    I1 = SURFACE_CASE%SURFACE_EDGES(1,J)
                    I2 = SURFACE_CASE%SURFACE_EDGES(2,J)
                    
                    IF(TYP==0) THEN
                        IF(SURFACE_CURRENT%EDGE_ONINTERFACE(SURFACE_CURRENT%POINT_EDGE_CONNECTION(1,I))==2) THEN
                            DISPLACEMENT(:,I) = SURFACE_CASE%SURFACE_POINTS(:,I1) - SURFACE_CASE%SURFACE_POINTS(:,I2)
                            DISPLACEMENT_THRESHOLD(I) = SQRT(DOT_PRODUCT(SURFACE_CASE%SURFACE_POINTS(:,I1) - SURFACE_CURRENT%SURFACE_POINTS(:,I), SURFACE_CASE%SURFACE_POINTS(:,I1) - SURFACE_CURRENT%SURFACE_POINTS(:,I)))
                            NEXT_RELATEDEDGE(I) = SURFACE_CASE%POINT_EDGE_CONNECTION(1,SURFACE_CASE%SURFACE_EDGES(1,J))
                        ELSE
                            DISPLACEMENT(:,I) = SURFACE_CASE%SURFACE_POINTS(:,I2) - SURFACE_CASE%SURFACE_POINTS(:,I1)
                            DISPLACEMENT_THRESHOLD(I) = SQRT(DOT_PRODUCT(SURFACE_CASE%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I), SURFACE_CASE%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I)))
                            NEXT_RELATEDEDGE(I) = SURFACE_CASE%POINT_EDGE_CONNECTION(2,SURFACE_CASE%SURFACE_EDGES(2,J))
                        END IF
                    ELSE IF(TYP==1) THEN
                        IF(SURFACE_CURRENT%EDGE_ONINTERFACE(SURFACE_CURRENT%POINT_EDGE_CONNECTION(1,I))==2) THEN
                            DISPLACEMENT(:,I) = SURFACE_CASE%SURFACE_POINTS(:,I2) - SURFACE_CASE%SURFACE_POINTS(:,I1)
                            DISPLACEMENT_THRESHOLD(I) = SQRT(DOT_PRODUCT(SURFACE_CASE%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I), SURFACE_CASE%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I)))
                            NEXT_RELATEDEDGE(I) = SURFACE_CASE%POINT_EDGE_CONNECTION(2,SURFACE_CASE%SURFACE_EDGES(2,J))
                        ELSE
                            DISPLACEMENT(:,I) = SURFACE_CASE%SURFACE_POINTS(:,I1) - SURFACE_CASE%SURFACE_POINTS(:,I2)
                            DISPLACEMENT_THRESHOLD(I) = SQRT(DOT_PRODUCT(SURFACE_CASE%SURFACE_POINTS(:,I1) - SURFACE_CURRENT%SURFACE_POINTS(:,I), SURFACE_CASE%SURFACE_POINTS(:,I1) - SURFACE_CURRENT%SURFACE_POINTS(:,I)))
                            NEXT_RELATEDEDGE(I) = SURFACE_CASE%POINT_EDGE_CONNECTION(1,SURFACE_CASE%SURFACE_EDGES(1,J))
                        END IF
                    END IF
                    
                    DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I), DISPLACEMENT(:,I))) * R
                END IF
                
            END IF
        END DO
        
    END SUBROUTINE NEAR_CASE_DISPLACEMENT
    
    SUBROUTINE NULLSPACE_SMOOTHING(TYP)
        IMPLICIT NONE
        INTEGER :: TYP
        
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        
        REAL(8), ALLOCATABLE :: EDGE_LENGTH(:)
        REAL(8), ALLOCATABLE :: EDGE_CENTER(:,:)
        
        INTEGER :: I,J,K,L
        INTEGER :: I1,I2
        REAL(8) :: V1(2)
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        
        !! MODIFIED
        !INTEGER :: LOCAL_SHAPE
        !! END MODIFIED
        
        REAL(8) :: N(2,2), W(2), C(2,2)
        REAL(8) :: W_SUM
        
        REAL(8) :: E_VALUE(2)
        REAL(8) :: E_VECTOR(2,2), DUMMY(2,2)
        
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(2)
        
        REAL(8) :: T(2), TT(2,2)
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        ALLOCATE(DISPLACEMENT(2,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        
        ALLOCATE(EDGE_LENGTH(SURFACE_CURRENT%SURFACE_EDGES_NUM))
        ALLOCATE(EDGE_CENTER(2,SURFACE_CURRENT%SURFACE_EDGES_NUM))
        ALLOCATE(NORMAL(2,SURFACE_CURRENT%SURFACE_EDGES_NUM))
        
        !$OMP PARALLEL DO PRIVATE(I,I1,I2,V1)
        DO I=1,SURFACE_CURRENT%SURFACE_EDGES_NUM
            
            I1 = SURFACE_CURRENT%SURFACE_EDGES(1,I)
            I2 = SURFACE_CURRENT%SURFACE_EDGES(2,I)
            
            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            
            NORMAL(1,I) = V1(2)
            NORMAL(2,I) = -V1(1)
            
            EDGE_LENGTH(I) = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
            
            NORMAL(:,I) = NORMAL(:,I)/EDGE_LENGTH(I)
            
            EDGE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2))/2.
        END DO
        !$OMP END PARALLEL DO

        !! MODIFIED
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            
            W_SUM = 0.
            DO J = 1,2
                W_SUM = W_SUM + EDGE_LENGTH(SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))
            END DO
            
            DO J = 1,2
                N(J,:) = NORMAL(:,SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))
                W(J) = EDGE_LENGTH(SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I)) / W_SUM
                C(:,J) = EDGE_CENTER(:,SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            END DO
            
            DO K=1,2
                DO L=1,2
                    E_VECTOR(K,L) = 0.
                    DO J = 1,2
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP(E_VECTOR,2,2,2,2,E_VALUE,DUMMY)
            
            IF(E_VALUE(2)>E_VALUE(1)) THEN
                TEMP_E_VALUE = E_VALUE(1)
                TEMP_E_VECTOR = E_VECTOR(:,1)
                    
                E_VALUE(1) = E_VALUE(2)
                E_VECTOR(:,1) = E_VECTOR(:,2)
                    
                E_VALUE(2) = TEMP_E_VALUE
                E_VECTOR(:,2) = TEMP_E_VECTOR(:)
            END IF
            
            T = E_VECTOR(:,2)
            
            DO K=1,2
                DO L=1,2
                    TT(K,L) = T(K)*T(L)   
                END DO
            END DO
            
            DISPLACEMENT(:,I) = 0.
            DO J = 1,2
                DO K = 1,2
                    DO L = 1,2
                        DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + W(J)*TT(K,L)*C(L,J)
                    END DO
                END DO
            END DO
            
        END DO
        
        CALL FIND_POINT_TYPE(TYP)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SURFACE_CURRENT%POINT_TYPE(I) == 2 .OR. SURFACE_CURRENT%POINT_TYPE(I) == 3) THEN
                DISPLACEMENT(:,I) = 0.
            END IF
        END DO
        !$OMP END PARALLEL DO
        
        !! END MODIFIED
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)
        END DO
        !$OMP END PARALLEL DO
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(EDGE_LENGTH)
        DEALLOCATE(EDGE_CENTER)
        
        DEALLOCATE(DISPLACEMENT)
        
    END SUBROUTINE NULLSPACE_SMOOTHING
    
    SUBROUTINE MODIFIED_NULLSPACE_SMOOTHING(TYP)
        IMPLICIT NONE
        INTEGER :: TYP
        
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
        
        REAL(8), ALLOCATABLE :: EDGE_LENGTH(:)
        
        INTEGER :: I,J,K,L
        INTEGER :: I1,I2
        REAL(8) :: V1(2)
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        
        !! MODIFIED
        !INTEGER :: LOCAL_SHAPE
        !! END MODIFIED
        
        REAL(8) :: N(2,2), W(2), C(2,2), ORIGIN_W(2)
        REAL(8) :: W_SUM, ORIGIN_W_SUM
        
        REAL(8) :: E_VALUE(2)
        REAL(8) :: E_VECTOR(2,2), DUMMY(2,2)
        
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(2)
        
        REAL(8) :: T(2), TT(2,2)
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        ALLOCATE(DISPLACEMENT(2,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        
        ALLOCATE(EDGE_LENGTH(SURFACE_CURRENT%SURFACE_EDGES_NUM))
        ALLOCATE(NORMAL(2,SURFACE_CURRENT%SURFACE_EDGES_NUM))
        
        !$OMP PARALLEL DO PRIVATE(I,I1,I2,V1)
        DO I=1,SURFACE_CURRENT%SURFACE_EDGES_NUM
            
            I1 = SURFACE_CURRENT%SURFACE_EDGES(1,I)
            I2 = SURFACE_CURRENT%SURFACE_EDGES(2,I)
            
            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            
            NORMAL(1,I) = V1(2)
            NORMAL(2,I) = -V1(1)
            
            EDGE_LENGTH(I) = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
            
            NORMAL(:,I) = NORMAL(:,I)/EDGE_LENGTH(I)
        END DO
        !$OMP END PARALLEL DO

        !! MODIFIED
        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            
            W_SUM = 0.
            ORIGIN_W_SUM = 0.
            DO J = 1,2
                W_SUM = W_SUM + EDGE_LENGTH(SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))
                ORIGIN_W_SUM = ORIGIN_W_SUM + 1./SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))
            END DO
            
            DO J = 1,2
                N(J,:) = NORMAL(:,SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))
                W(J) = EDGE_LENGTH(SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I)) / W_SUM
                ORIGIN_W(J) = (1./SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))) / ORIGIN_W_SUM
                C(:,J) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_EDGES(J,SURFACE_CURRENT%POINT_EDGE_CONNECTION(J,I))) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            END DO
            
            DO K=1,2
                DO L=1,2
                    E_VECTOR(K,L) = 0.
                    DO J = 1,2
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP(E_VECTOR,2,2,2,2,E_VALUE,DUMMY)
            
            IF(E_VALUE(2)>E_VALUE(1)) THEN
                TEMP_E_VALUE = E_VALUE(1)
                TEMP_E_VECTOR = E_VECTOR(:,1)
                    
                E_VALUE(1) = E_VALUE(2)
                E_VECTOR(:,1) = E_VECTOR(:,2)
                    
                E_VALUE(2) = TEMP_E_VALUE
                E_VECTOR(:,2) = TEMP_E_VECTOR(:)
            END IF
            
            T = E_VECTOR(:,2)
            
            DO K=1,2
                DO L=1,2
                    TT(K,L) = T(K)*T(L)
                END DO
            END DO
            
            DISPLACEMENT(:,I) = 0.
            DO J = 1,2
                DO K = 1,2
                    DO L = 1,2
                        DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + ORIGIN_W(J) * TT(K,L)*C(L,J)/2.
                    END DO
                END DO
            END DO
            
        END DO

        CALL FIND_POINT_TYPE(TYP)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SURFACE_CURRENT%POINT_TYPE(I) == 2 .OR. SURFACE_CURRENT%POINT_TYPE(I) == 3) THEN
                DISPLACEMENT(:,I) = 0.
            END IF
        END DO
        !$OMP END PARALLEL DO
        
        !! END MODIFIED
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)
        END DO
        !$OMP END PARALLEL DO
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(EDGE_LENGTH)
        
        DEALLOCATE(DISPLACEMENT)
        
    END SUBROUTINE MODIFIED_NULLSPACE_SMOOTHING
    
    SUBROUTINE FACEOFFSETTING_2D(TYP, TIMESTEP)
        IMPLICIT NONE
        INTEGER :: TYP
        REAL(8) :: TIMESTEP, LEFT_TIMESTEP, RESULT_TIMESTEP
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        LEFT_TIMESTEP = TIMESTEP
        RESULT_TIMESTEP = 0.
        DO WHILE(LEFT_TIMESTEP .NE. RESULT_TIMESTEP)
            LEFT_TIMESTEP = LEFT_TIMESTEP - RESULT_TIMESTEP
            CALL WAVEFRONT_DISPLACEMENT(TYP, LEFT_TIMESTEP, RESULT_TIMESTEP)
        END DO
    
    END SUBROUTINE FACEOFFSETTING_2D
    
    !! MODIFIED
    SUBROUTINE MAINTAIN_CASE_CORNER()
        IMPLICIT NONE
        INTEGER :: I, J, I1, I2
        INTEGER :: JMIN
        REAL(8) :: R, RMIN
        
        DO I = 1,SURFACE_CASE%SURFACE_POINTS_NUM
            IF(SURFACE_CASE%POINT_TYPE(I)==2) THEN
                I1 = SURFACE_CASE%POINT_EDGE_CONNECTION(1,I)
                I2 = SURFACE_CASE%POINT_EDGE_CONNECTION(2,I)
                IF(SURFACE_CASE%EDGE_ONINTERFACE(I1)==0 .AND. SURFACE_CASE%EDGE_ONINTERFACE(I2)==0) THEN
                    RMIN = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2))
                    JMIN = 0
                    DO J = 1,SURFACE_FLUID%SURFACE_POINTS_NUM
                        IF(SURFACE_FLUID%POINT_RELATEDEDGE(2+1,J)==I1 .OR. SURFACE_FLUID%POINT_RELATEDEDGE(2+1,J)==I2) THEN
                            R = SQRT(DOT_PRODUCT(SURFACE_CASE%SURFACE_POINTS(:,I) - SURFACE_FLUID%SURFACE_POINTS(:,J), SURFACE_CASE%SURFACE_POINTS(:,I) - SURFACE_FLUID%SURFACE_POINTS(:,J) ))
                            IF(R<RMIN) THEN
                                RMIN = R
                                JMIN = J
                            END IF
                        END IF
                    END DO
		    IF(JMIN .NE. 0) THEN
                        IF(SURFACE_FLUID%POINT_TYPE(JMIN).NE.3 .AND. SURFACE_FLUID%EDGE_ABLATION_FLAG(SURFACE_FLUID%POINT_EDGE_CONNECTION(1,JMIN)) .NE. -2 .AND. SURFACE_FLUID%EDGE_ABLATION_FLAG(SURFACE_FLUID%POINT_EDGE_CONNECTION(2,JMIN)) .NE. -2) THEN
                        SURFACE_FLUID%SURFACE_POINTS(:,JMIN) = SURFACE_CASE%SURFACE_POINTS(:,I)
                        END IF
		    END IF
                ELSE IF(SURFACE_CASE%EDGE_ONINTERFACE(I1)==1 .AND. SURFACE_CASE%EDGE_ONINTERFACE(I2)==1) THEN
                    RMIN = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2))
                    JMIN = 0
                    DO J = 1,SURFACE_PROPEL%SURFACE_POINTS_NUM
                        IF(SURFACE_PROPEL%POINT_RELATEDEDGE(2+1,J)==I1 .OR. SURFACE_PROPEL%POINT_RELATEDEDGE(2+1,J)==I2) THEN
                            R = SQRT(DOT_PRODUCT(SURFACE_CASE%SURFACE_POINTS(:,I) - SURFACE_PROPEL%SURFACE_POINTS(:,J), SURFACE_CASE%SURFACE_POINTS(:,I) - SURFACE_PROPEL%SURFACE_POINTS(:,J) ))
                            IF(R<RMIN) THEN
                                RMIN = R
                                JMIN = J
                            END IF
                        END IF
                    END DO
                    IF(JMIN.NE.0 .AND. SURFACE_PROPEL%POINT_TYPE(J).NE.3) THEN
                        SURFACE_PROPEL%SURFACE_POINTS(:,JMIN) = SURFACE_CASE%SURFACE_POINTS(:,I)
                    END IF
                END IF
            END IF
        END DO
    
    END SUBROUTINE MAINTAIN_CASE_CORNER
    !! END MODIFIED
    
    !! MODIFIED
    SUBROUTINE RESET_SURFACE(TYP, FLAG, POINT_NUM, EDGE_NUM, SURFACE_POINTS, SURFACE_EDGES, &
    SURFACE_INITIAL_EDGE_LENGTH, EDGE_B_RATE, POINT_VELOCITY, POINT_DISPLACEMENT, &
    POINT_EDGE_CONNECTION, POINT_TYPE, EDGE_LOCATION, EDGE_ONINTERFACE, POINT_RELATEDPT, POINT_RELATEDEDGE, EDGE_PRESSURE, POINT_FORCE, EDGE_IMPACT_ZONE, EDGE_ABLATION_FLAG)
	IMPLICIT NONE
        INTEGER :: TYP
        LOGICAL :: FLAG
        INTEGER :: POINT_NUM, EDGE_NUM 
        
        REAL(8), OPTIONAL :: SURFACE_POINTS(2,POINT_NUM)
        INTEGER, OPTIONAL :: SURFACE_EDGES(2,EDGE_NUM)
    
        REAL(8), OPTIONAL :: SURFACE_INITIAL_EDGE_LENGTH(EDGE_NUM)
        
        REAL(8), OPTIONAL :: EDGE_B_RATE(EDGE_NUM)
        REAL(8), OPTIONAL :: POINT_VELOCITY(2,POINT_NUM)
        REAL(8), OPTIONAL :: POINT_DISPLACEMENT(2,POINT_NUM)
        INTEGER, OPTIONAL :: POINT_EDGE_CONNECTION(2,POINT_NUM)
        INTEGER, OPTIONAL :: POINT_TYPE(POINT_NUM)
    
        INTEGER, OPTIONAL :: EDGE_LOCATION(EDGE_NUM)
        INTEGER, OPTIONAL :: EDGE_ONINTERFACE(EDGE_NUM)
        
        INTEGER, OPTIONAL :: POINT_RELATEDPT(3,POINT_NUM)
        INTEGER, OPTIONAL :: POINT_RELATEDEDGE(3,POINT_NUM)
        
        REAL(8), OPTIONAL :: EDGE_PRESSURE(EDGE_NUM)
        REAL(8), OPTIONAL :: POINT_FORCE(2,POINT_NUM)
        
        INTEGER, OPTIONAL :: EDGE_IMPACT_ZONE(3,EDGE_NUM)
        !LOGICAL, OPTIONAL :: EDGE_ZIPPER_FLAG(EDGE_NUM)
        INTEGER :: I
        REAL(8) :: R
        INTEGER, OPTIONAL :: EDGE_ABLATION_FLAG(EDGE_NUM)

        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_POINTS)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_POINTS)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_EDGES)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_EDGES)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%EDGE_B_RATE)) THEN
            DEALLOCATE(SURFACE_CURRENT%EDGE_B_RATE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_VELOCITY)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_VELOCITY)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_DISPLACEMENT)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_DISPLACEMENT)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_EDGE_CONNECTION)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_EDGE_CONNECTION)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_TYPE)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_TYPE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%EDGE_LOCATION)) THEN
            DEALLOCATE(SURFACE_CURRENT%EDGE_LOCATION)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%EDGE_ONINTERFACE)) THEN
            DEALLOCATE(SURFACE_CURRENT%EDGE_ONINTERFACE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_RELATEDPT)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_RELATEDPT)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_RELATEDEDGE)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_RELATEDEDGE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%EDGE_PRESSURE)) THEN
            DEALLOCATE(SURFACE_CURRENT%EDGE_PRESSURE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%POINT_FORCE)) THEN
            DEALLOCATE(SURFACE_CURRENT%POINT_FORCE)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%EDGE_IMPACT_ZONE)) THEN
            DEALLOCATE(SURFACE_CURRENT%EDGE_IMPACT_ZONE)
        END IF
        !IF(ALLOCATED(SURFACE_CURRENT%EDGE_ZIPPER_FLAG)) THEN
        !    DEALLOCATE(SURFACE_CURRENT%EDGE_ZIPPER_FLAG)
        !END IF
        IF(ALLOCATED(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP)) THEN
            DEALLOCATE(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP)
        END IF
        IF(ALLOCATED(SURFACE_CURRENT%EDGE_ABLATION_FLAG)) THEN
            DEALLOCATE(SURFACE_CURRENT%EDGE_ABLATION_FLAG)
        END IF

        IF(FLAG) THEN
            
            SURFACE_CURRENT%SURFACE_POINTS_NUM = POINT_NUM
            SURFACE_CURRENT%SURFACE_EDGES_NUM = EDGE_NUM
	
	    !SURFACE_CURRENT%SURFACE_PATCHES_NUM = SURFACE_PATCHES_NUM
            !SURFACE_PATCHES_NUM = SURFACE_CURRENT%SURFACE_PATCHES_NUM
            ALLOCATE(SURFACE_CURRENT%SURFACE_POINTS(2,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%SURFACE_EDGES(2,EDGE_NUM))
            ALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(EDGE_NUM))
            ALLOCATE(SURFACE_CURRENT%EDGE_B_RATE(EDGE_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_VELOCITY(2,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_DISPLACEMENT(2,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_EDGE_CONNECTION(2,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_TYPE(POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%EDGE_LOCATION(EDGE_NUM))
            ALLOCATE(SURFACE_CURRENT%EDGE_ONINTERFACE(EDGE_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_RELATEDPT(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_RELATEDEDGE(3,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%EDGE_PRESSURE(EDGE_NUM))
            ALLOCATE(SURFACE_CURRENT%POINT_FORCE(2,POINT_NUM))
            ALLOCATE(SURFACE_CURRENT%EDGE_IMPACT_ZONE(3,EDGE_NUM))
            !ALLOCATE(SURFACE_CURRENT%EDGE_ZIPPER_FLAG(EDGE_NUM))
	    ALLOCATE(SURFACE_CURRENT%EDGE_ABLATION_FLAG(EDGE_NUM))
         
            IF(PRESENT(SURFACE_POINTS)) THEN
                SURFACE_CURRENT%SURFACE_POINTS(:,:) = SURFACE_POINTS(:,:)
            END IF
            
            IF(PRESENT(SURFACE_EDGES)) THEN
                SURFACE_CURRENT%SURFACE_EDGES(:,:) = SURFACE_EDGES(:,:)
            END IF
            
            IF(PRESENT(SURFACE_INITIAL_EDGE_LENGTH)) THEN
                SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(:) = SURFACE_INITIAL_EDGE_LENGTH(:)
            ELSE
                SURFACE_CURRENT%MESH_SIZE = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2))
                SURFACE_CURRENT%MESH_SIZE_MAX = 0.
                
                !$OMP PARALLEL DO PRIVATE(I,R),REDUCTION(MIN:MESH_SIZE),REDUCTION(MAX:MESH_SIZE_MAX)
                DO I = 1, EDGE_NUM
                    R = SQRT(DOT_PRODUCT(SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_EDGES(1,I))-SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_EDGES(2,I)), &
                    SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_EDGES(1,I))-SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_EDGES(2,I))))
                
                    SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(I) = R
                         
                    IF(SURFACE_CURRENT%MESH_SIZE > R) THEN
                        SURFACE_CURRENT%MESH_SIZE = R
                    END IF
                    IF(SURFACE_CURRENT%MESH_SIZE_MAX < R) THEN
                        SURFACE_CURRENT%MESH_SIZE_MAX = R
                    END IF
                END DO
                !$OMP END PARALLEL DO
            END IF
            
            IF(PRESENT(EDGE_B_RATE)) THEN
                SURFACE_CURRENT%EDGE_B_RATE(:) = EDGE_B_RATE(:)
            ELSE
                SURFACE_CURRENT%EDGE_B_RATE(:) = 0.
            END IF
            
            IF(PRESENT(POINT_VELOCITY)) THEN
                SURFACE_CURRENT%POINT_VELOCITY(:,:) = POINT_VELOCITY(:,:)
            ELSE
                SURFACE_CURRENT%POINT_VELOCITY(:,:) = 0.
            END IF
            
            IF(PRESENT(POINT_DISPLACEMENT)) THEN
                SURFACE_CURRENT%POINT_DISPLACEMENT(:,:) = POINT_DISPLACEMENT(:,:)
            ELSE
                SURFACE_CURRENT%POINT_DISPLACEMENT(:,:) = 0.
            END IF
            
            IF(PRESENT(POINT_EDGE_CONNECTION)) THEN
                SURFACE_CURRENT%POINT_EDGE_CONNECTION(:,:) = POINT_EDGE_CONNECTION(:,:)
            ELSE
                CALL POINT_EDGE_CONNECTING(TYP)
            END IF
            
            IF(PRESENT(EDGE_LOCATION)) THEN
                SURFACE_CURRENT%EDGE_LOCATION(:) = EDGE_LOCATION(:)
	        CALL FIND_PATCH_NUM(TYP)
	        ALLOCATE(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_CURRENT%SURFACE_PATCHES_NUM))
            ELSE
		CALL FIND_PATCH_NUM(TYP)
	        ALLOCATE(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_CURRENT%SURFACE_PATCHES_NUM)) 
                SURFACE_CURRENT%EDGE_LOCATION(:) = -1
            END IF
            
            IF(PRESENT(EDGE_ONINTERFACE)) THEN
                SURFACE_CURRENT%EDGE_ONINTERFACE(:) = EDGE_ONINTERFACE(:)
            ELSE
                SURFACE_CURRENT%EDGE_ONINTERFACE(:) = -1
            END IF
            
            IF(PRESENT(POINT_RELATEDPT)) THEN
                SURFACE_CURRENT%POINT_RELATEDPT(:,:) = POINT_RELATEDPT(:,:)
            ELSE
                SURFACE_CURRENT%POINT_RELATEDPT(:,:) = 0
            END IF
            
            IF(PRESENT(POINT_RELATEDEDGE)) THEN
                SURFACE_CURRENT%POINT_RELATEDEDGE(:,:) = POINT_RELATEDEDGE(:,:)
            ELSE
                SURFACE_CURRENT%POINT_RELATEDEDGE(:,:) = 0
            END IF
            IF(PRESENT(EDGE_PRESSURE)) THEN
                SURFACE_CURRENT%EDGE_PRESSURE(:) = EDGE_PRESSURE(:)
            ELSE
                SURFACE_CURRENT%EDGE_PRESSURE(:) = 0.
            END IF
            IF(PRESENT(POINT_FORCE)) THEN
                SURFACE_CURRENT%POINT_FORCE(:,:) = POINT_FORCE(:,:)
            ELSE
                SURFACE_CURRENT%POINT_FORCE(:,:) = 0.
            END IF
            
            IF(PRESENT(EDGE_IMPACT_ZONE)) THEN
                SURFACE_CURRENT%EDGE_IMPACT_ZONE(:,:) = EDGE_IMPACT_ZONE(:,:)
            ELSE
                SURFACE_CURRENT%EDGE_IMPACT_ZONE(:,:) = 0
            END IF

            !IF(PRESENT(EDGE_ZIPPER_FLAG)) THEN
            !    SURFACE_CURRENT%EDGE_ZIPPER_FLAG(:) = EDGE_ZIPPER_FLAG(:)
            !ELSE
            !    SURFACE_CURRENT%EDGE_ZIPPER_FLAG(:) = .FALSE.
            !END IF
            
            IF(PRESENT(POINT_TYPE)) THEN
                SURFACE_CURRENT%POINT_TYPE(:) = POINT_TYPE(:)
            ELSE
                CALL FIND_POINT_TYPE(TYP)
            END IF

	    IF(TYP == 0 .OR. TYP == 1) THEN
                SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(:) = 0
	    END IF

            IF(PRESENT(EDGE_ABLATION_FLAG)) THEN
                SURFACE_CURRENT%EDGE_ABLATION_FLAG(:) = EDGE_ABLATION_FLAG(:)
            ELSE
                SURFACE_CURRENT%EDGE_ABLATION_FLAG(:) = 0
            END IF
        END IF
    END SUBROUTINE RESET_SURFACE
    !! END MODIFIED
    
END MODULE
