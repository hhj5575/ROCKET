    MODULE PROPA_RECONST_REINITIAL_3D
    USE SURFACE_MODULE_3D
    USE SURFACES_3D
    USE OPERATORS_3D
    USE EXTRAPOLATION_3D
    USE HIGHORDER_3D
    USE SVD
    IMPLICIT NONE
    
    CONTAINS
    SUBROUTINE INTERPOLATE_FLUID_DISPLACEMENT(TYP1_POINT_NUM, TYP1_POINT, TYP1_POINTLOC, TYP1_FACE_NUM, TYP1_FACE, DATA_DISPLACEMENT)
    IMPLICIT NONE
    INTEGER :: I
    INTEGER :: TYP1_POINT_NUM
    REAL(8) :: TYP1_POINT(:,:)
    INTEGER :: TYP1_POINTLOC(:,:)
    INTEGER :: TYP1_FACE_NUM
    INTEGER :: TYP1_FACE(:,:)
    INTEGER :: TYP2_POINT_NUM
    REAL(8), POINTER, DIMENSION(:,:) :: TYP2_POINT
    INTEGER, POINTER, DIMENSION(:,:) :: TYP2_POINTLOC
    INTEGER :: TYP2_FACE_NUM
    INTEGER, POINTER, DIMENSION(:,:) :: TYP2_FACE
    REAL(8) :: DATA_DISPLACEMENT(:,:)
    REAL(8), ALLOCATABLE :: CR_SOURCE(:,:), CR_TARGET(:,:)
    
    CALL UPDATE_INTERFACE_CLUSTER(0)
    
    TYP2_POINT_NUM = INTERFACE_FLUID_POINTS_NUM
    TYP2_POINT => INTERFACE_FLUID_POINTS
    TYP2_POINTLOC => INTERFACE_FLUID_POINTS_LOC
    TYP2_FACE_NUM = INTERFACE_FLUID_FACES_NUM
    TYP2_FACE => INTERFACE_FLUID_FACES

    ALLOCATE(CR_SOURCE(3,TYP1_POINT_NUM))

    !$OMP PARALLEL DO PRIVATE(I)
    DO I=1,TYP1_POINT_NUM
        CR_SOURCE(:,I) = DATA_DISPLACEMENT(:,TYP1_POINTLOC(1,I))
    END DO
    !$OMP END PARALLEL DO

    ALLOCATE(CR_TARGET(3,TYP2_POINT_NUM))

    CALL DATA_TRANSFER_WITHOUT_CR(TYP1_POINT_NUM, TYP1_POINT, TYP1_FACE_NUM, TYP1_FACE, CR_SOURCE(1,:), TYP2_POINT_NUM, TYP2_POINT, CR_TARGET(1,:)) !TYP2_FACE_NUM, TYP2_FACE,
    CALL DATA_TRANSFER_WITHOUT_CR(TYP1_POINT_NUM, TYP1_POINT, TYP1_FACE_NUM, TYP1_FACE, CR_SOURCE(2,:), TYP2_POINT_NUM, TYP2_POINT, CR_TARGET(2,:)) !TYP2_FACE_NUM, TYP2_FACE,
    CALL DATA_TRANSFER_WITHOUT_CR(TYP1_POINT_NUM, TYP1_POINT, TYP1_FACE_NUM, TYP1_FACE, CR_SOURCE(3,:), TYP2_POINT_NUM, TYP2_POINT, CR_TARGET(3,:)) !TYP2_FACE_NUM, TYP2_FACE,

    !$OMP PARALLEL DO PRIVATE(I)
    DO I=1,TYP2_POINT_NUM
        SURFACE_FLUID%POINT_DISPLACEMENT(:,TYP2_POINTLOC(1,I)) = CR_TARGET(:,I)
    END DO
    !$OMP END PARALLEL DO

    DEALLOCATE(CR_SOURCE)
    DEALLOCATE(CR_TARGET)

    END SUBROUTINE INTERPOLATE_FLUID_DISPLACEMENT

    
    
    SUBROUTINE FLUID_SMOOTHING()
    IMPLICIT NONE
    INTEGER :: ITER
    
    CALL MASS_SPRING_TYPE(0, .TRUE.)
    
    !DO ITER=1,SURFACE_FLUID%FACE_DIVIDED_REGION_NUM
    !CALL MASS_SPRING_TYPE(0, .TRUE., ITER)
    !END DO
    !DO ITER=1,SURFACE_FLUID%FACE_DIVIDED_REGION_NUM
    !    CALL GEOMETRIC_FLOW_SMOOTHING_TRIANGLE_TYPE(0, ITER)
    !END DO

    DO ITER=1,SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_NUM
        CALL TEST_BOUNDARY_SMOOTHING2(SURFACE_FLUID%SURFACE_POINTS_NUM, SURFACE_FLUID%SURFACE_POINTS, SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION, SURFACE_FLUID%SURFACE_INITIAL_EDGE_LENGTH, SURFACE_FLUID%FACE_DIVIDED_BOUNDARY_ARRAY, ITER)
    END DO

    END SUBROUTINE

    
    
    SUBROUTINE FLUID_SMOOTHING_REMESH(POINT_NUM, POINT, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, FACE_AREA, EDGE_LENGTH, INITIALPOINT_TYPE, DIVIDED_REGION, DIVIDED_BOUNDARY_NUM, DIVIDED_BOUNDARY)
    IMPLICIT NONE
    INTEGER :: POINT_NUM
    REAL(8) :: POINT(:,:)
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    REAL(8) :: FACE_AREA(:)
    REAL(8) :: EDGE_LENGTH(:,:)
    INTEGER :: INITIALPOINT_TYPE(:)
    INTEGER :: DIVIDED_REGION(:)
    INTEGER :: DIVIDED_BOUNDARY_NUM
    INTEGER :: DIVIDED_BOUNDARY(:,:)

    INTEGER :: ITER, I
    
    CALL MASS_SPRING(.TRUE., POINT_NUM, POINT, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, INITIALPOINT_TYPE, FACE_AREA, DIVIDED_REGION, DIVIDED_BOUNDARY)
    
    !DO ITER=1,SURFACE_FLUID%FACE_DIVIDED_REGION_NUM
    !CALL MASS_SPRING(.TRUE., POINT_NUM, POINT, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, INITIALPOINT_TYPE, FACE_AREA, DIVIDED_REGION, DIVIDED_BOUNDARY, ITER)
    !END DO
    !DO ITER=1,SURFACE_FLUID%FACE_DIVIDED_REGION_NUM
    !    CALL GEOMETRIC_FLOW_SMOOTHING_TRIANGLE(POINT_NUM, POINT, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_REGION, DIVIDED_BOUNDARY, ITER)
    !END DO
    
    DO ITER=1,DIVIDED_BOUNDARY_NUM
        DO I=1,5 
        CALL TEST_BOUNDARY_SMOOTHING2(POINT_NUM, POINT, FACE, CONNECTION_NUM, CONNECTION, EDGE_LENGTH, DIVIDED_BOUNDARY, ITER)
        END DO
    END DO

    END SUBROUTINE

    
    
    SUBROUTINE PROPEL_SMOOTHING()
    IMPLICIT NONE
    INTEGER :: ITER

    DO ITER=1,SURFACE_PROPEL%FACE_DIVIDED_REGION_NUM
        CALL GEOMETRIC_FLOW_SMOOTHING_TYPE(1, ITER)
    END DO

    DO ITER=1,SURFACE_PROPEL%FACE_DIVIDED_BOUNDARY_NUM
        CALL TEST_BOUNDARY_SMOOTHING(SURFACE_PROPEL%SURFACE_POINTS_NUM, SURFACE_PROPEL%SURFACE_POINTS, SURFACE_PROPEL%SURFACE_FACES, SURFACE_PROPEL%POINT_FACE_CONNECTION_NUM, SURFACE_PROPEL%POINT_FACE_CONNECTION, SURFACE_PROPEL%SURFACE_INITIAL_EDGE_LENGTH, SURFACE_PROPEL%FACE_DIVIDED_BOUNDARY_ARRAY, ITER)
    END DO

    END SUBROUTINE

    
    
    SUBROUTINE CASE_SMOOTHING()
    IMPLICIT NONE
    INTEGER :: I, J, ITER
    INTEGER, ALLOCATABLE :: SMOOTHING_REGION(:)
    INTEGER :: SMOOTHING_REGION_NUM
    LOGICAL :: B,C

    ALLOCATE(SMOOTHING_REGION(SURFACE_CASE%FACE_DIVIDED_REGION_NUM))
    SMOOTHING_REGION_NUM = 0

    DO I=1,SURFACE_CASE%SURFACE_FACES_NUM
        IF(SURFACE_CASE%FACE_ONINTERFACE(I) .NE. 1) THEN

        B = .FALSE.
        DO J=1,3
            IF(SURFACE_CASE%POINT_TYPE(SURFACE_CASE%SURFACE_FACES(J,I))==4 .OR. SURFACE_CASE%POINT_TYPE(SURFACE_CASE%SURFACE_FACES(J,I))==6) THEN
                B = .TRUE.
                EXIT
            END IF
        END DO

        IF(B) THEN
            ITER = SURFACE_CASE%FACE_DIVIDED_REGION_ARRAY(I)

            C = .TRUE.
            DO J=1,SMOOTHING_REGION_NUM
                IF(SMOOTHING_REGION(J)==ITER) THEN
                    C = .FALSE.
                    EXIT
                END IF
            END DO

            IF(C) THEN
                SMOOTHING_REGION_NUM = SMOOTHING_REGION_NUM + 1
                SMOOTHING_REGION(SMOOTHING_REGION_NUM) = ITER
            END IF
        END IF

        END IF
    END DO

    DO I=1,SMOOTHING_REGION_NUM
        ITER = SMOOTHING_REGION(I)
        CALL GEOMETRIC_FLOW_SMOOTHING_TYPE(2, ITER)
    END DO

    DEALLOCATE(SMOOTHING_REGION)

    !        DO ITER=1,SURFACE_CASE%FACE_DIVIDED_BOUNDARY_NUM
    !            CALL TEST_BOUNDARY_SMOOTHING(SURFACE_CASE%SURFACE_POINTS_NUM, SURFACE_CASE%SURFACE_POINTS, SURFACE_CASE%SURFACE_FACES, SURFACE_CASE%POINT_FACE_CONNECTION_NUM, SURFACE_CASE%POINT_FACE_CONNECTION, SURFACE_CASE%SURFACE_INITIAL_EDGE_LENGTH, SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY, ITER)
    !        END DO

    END SUBROUTINE
    
    SUBROUTINE TEST_BOUNDARY_SMOOTHING(TEMP_POINT_NUM, TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWEDGELENGTH, DIVIDED_BOUNDARY_ARRAY, BOUNDARY_FLAG)
    IMPLICIT NONE
    INTEGER :: TEMP_POINT_NUM
    REAL(8) :: TEMPPOINT(:,:)
    !INTEGER :: TEMP_FACE_NUM
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    REAL(8) :: TEMP_NEWEDGELENGTH(:,:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER :: BOUNDARY_FLAG
    REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
    INTEGER :: I,J,K,L
    INTEGER :: I1,I2, CON_NUM
    REAL(8) :: ORIGIN_W(2), C(3,2)
    REAL(8) :: T(3), CC(3)
    INTEGER :: RIDGE_EDGE_NUM, RIDGE_EDGE(2,10)
    REAL(8) :: ORIGIN_W_SUM
    REAL(8) :: TT(3,3)

    ALLOCATE(DISPLACEMENT(3,TEMP_POINT_NUM))
    DISPLACEMENT(:,:) = 0.

    DO I=1,TEMP_POINT_NUM

    CON_NUM = TEMP_CONNECTION_NUM(I)

    RIDGE_EDGE_NUM = 0

    DO J=1,CON_NUM
        L = TEMP_CONNECTION(J,I)
        DO K=1,3
            IF(TEMPFACE(K,L)==I) THEN
                EXIT
            END IF
        END DO

        IF(DIVIDED_BOUNDARY_ARRAY(K,L) == BOUNDARY_FLAG) THEN
            RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
            RIDGE_EDGE(1,RIDGE_EDGE_NUM) = K
            RIDGE_EDGE(2,RIDGE_EDGE_NUM) = L
        END IF
    END DO

    IF(RIDGE_EDGE_NUM == 2) THEN
        ORIGIN_W_SUM = 0.

        DO J = 1,2
            ORIGIN_W_SUM = ORIGIN_W_SUM + 1./TEMP_NEWEDGELENGTH(RIDGE_EDGE(1,J), RIDGE_EDGE(2,J))
        END DO

        DO J = 1,2
            ORIGIN_W(J) = (1./TEMP_NEWEDGELENGTH(RIDGE_EDGE(1,J), RIDGE_EDGE(2,J)))/ORIGIN_W_SUM
            I1 = TEMPFACE(RIDGE_EDGE(1,J), RIDGE_EDGE(2,J))
            I2 = TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1, RIDGE_EDGE(2,J))
            C(:,J) = (TEMPPOINT(:,I1)+TEMPPOINT(:,I2))/2. - TEMPPOINT(:,I)
        END DO

        CC(:) = 0.
        DO J = 1,2
            CC(:) = CC(:) + ORIGIN_W(J) * C(:,J)/3.
        END DO

        T(:) = TEMPPOINT(:,TEMPFACE(MOD(RIDGE_EDGE(1,1),3)+1,RIDGE_EDGE(2,1))) - TEMPPOINT(:,TEMPFACE(MOD(RIDGE_EDGE(1,2),3)+1,RIDGE_EDGE(2,2)))
        T(:) = T(:)/SQRT(DOT_PRODUCT(T,T))

        TT(:,:) = 0.

        DO K=1,3
            DO L=1,3
                TT(K,L) = TT(K,L) + T(K)*T(L)
            END DO
        END DO

        DO K = 1,3
            DO L = 1,3
                DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + TT(K,L)*CC(L)
            END DO
        END DO
    END IF

    END DO

    DO I = 1,TEMP_POINT_NUM
        TEMPPOINT(:,I) = TEMPPOINT(:,I) + DISPLACEMENT(:,I)
    END DO

    DEALLOCATE(DISPLACEMENT)
    END SUBROUTINE TEST_BOUNDARY_SMOOTHING
    
    SUBROUTINE TEST_BOUNDARY_SMOOTHING2(TEMP_POINT_NUM, TEMPPOINT, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWEDGELENGTH, DIVIDED_BOUNDARY_ARRAY, BOUNDARY_FLAG)
    IMPLICIT NONE
    INTEGER :: TEMP_POINT_NUM
    REAL(8) :: TEMPPOINT(:,:)
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    REAL(8) :: TEMP_NEWEDGELENGTH(:,:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER :: BOUNDARY_FLAG
    REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
    INTEGER :: I,J,K,L
    REAL(8) :: T(3)
    INTEGER :: RIDGE_EDGE_NUM, RIDGE_EDGE(2,10)
    REAL(8) :: LENGTH, INITIAL_LENGTH
    
    ALLOCATE(DISPLACEMENT(3,TEMP_POINT_NUM))
    DISPLACEMENT(:,:) = 0.

    DO I=1,TEMP_POINT_NUM

    RIDGE_EDGE_NUM = 0

    DO J=1,TEMP_CONNECTION_NUM(I)
        L = TEMP_CONNECTION(J,I)
        DO K=1,3
            IF(TEMPFACE(K,L)==I) THEN
                EXIT
            END IF
        END DO

        IF(DIVIDED_BOUNDARY_ARRAY(K,L) == BOUNDARY_FLAG) THEN
            RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
            RIDGE_EDGE(1,RIDGE_EDGE_NUM) = K
            RIDGE_EDGE(2,RIDGE_EDGE_NUM) = L
        END IF
    END DO

    IF(RIDGE_EDGE_NUM == 2) THEN
        LENGTH = SQRT(DOT_PRODUCT(TEMPPOINT(:,TEMPFACE(MOD(RIDGE_EDGE(1,1),3)+1,RIDGE_EDGE(2,1))) - TEMPPOINT(:,I), TEMPPOINT(:,TEMPFACE(MOD(RIDGE_EDGE(1,1),3)+1,RIDGE_EDGE(2,1))) - TEMPPOINT(:,I) ))
        
        T(:) = TEMPPOINT(:,TEMPFACE(MOD(RIDGE_EDGE(1,1),3)+1,RIDGE_EDGE(2,1))) - TEMPPOINT(:,TEMPFACE(MOD(RIDGE_EDGE(1,2),3)+1,RIDGE_EDGE(2,2)))
        INITIAL_LENGTH = SQRT(DOT_PRODUCT(T,T)) * TEMP_NEWEDGELENGTH(RIDGE_EDGE(1,1), RIDGE_EDGE(2,1)) / (TEMP_NEWEDGELENGTH(RIDGE_EDGE(1,1), RIDGE_EDGE(2,1)) + TEMP_NEWEDGELENGTH(RIDGE_EDGE(1,2), RIDGE_EDGE(2,2)) )
        
        T(:) = T(:)/SQRT(DOT_PRODUCT(T,T))
        
        DISPLACEMENT(:,I) = (LENGTH - INITIAL_LENGTH)/2. * T(:)
    END IF

    END DO

    DO I = 1,TEMP_POINT_NUM
        TEMPPOINT(:,I) = TEMPPOINT(:,I) + DISPLACEMENT(:,I)
    END DO

    DEALLOCATE(DISPLACEMENT)
    END SUBROUTINE TEST_BOUNDARY_SMOOTHING2

    
    
    SUBROUTINE FLUID_MOVE(TIME_STEP) ! TYP = 0 or 1, TYP2 = 0
    IMPLICIT NONE
    REAL(8) :: TIME_STEP
    INTEGER :: I,J,K,J0 !I1,I2,I3
    INTEGER, ALLOCATABLE :: PROPEL_MOVING_TYPE(:)
    LOGICAL :: B, C
    INTEGER :: TYP1_POINT_NUM
    REAL(8), ALLOCATABLE :: TYP1_POINT(:,:)
    INTEGER :: TYP1_FACE_NUM
    INTEGER, ALLOCATABLE :: TYP1_FACE(:,:)
    INTEGER, ALLOCATABLE :: TYP1_POINTLOC(:,:)
    REAL(8), ALLOCATABLE :: DATA_DISPLACEMENT(:,:)
real(8) :: t0,t1


    IF (SURFACE_MOVING_TYPE==1 .OR. SURFACE_MOVING_TYPE==2 .OR. SURFACE_MOVING_TYPE==3) THEN

    ALLOCATE(PROPEL_MOVING_TYPE(SURFACE_PROPEL%SURFACE_POINTS_NUM))
    PROPEL_MOVING_TYPE(:) = 0

    !! DECIDING PROPELLANT MOVING TYPE !!  1 : RELATED_POINT, 2 : RIDGE_PROJECTION, 3 : FACE_PROJECTION 
    DO I=1,SURFACE_PROPEL%SURFACE_POINTS_NUM
        B = .FALSE.
        DO J=1,SURFACE_PROPEL%POINT_FACE_CONNECTION_NUM(I)
            K = SURFACE_PROPEL%POINT_FACE_CONNECTION(J,I)
            IF(SURFACE_PROPEL%FACE_ONINTERFACE(K)==0) THEN
                B = .TRUE.
                EXIT
            END IF
        END DO
        IF(B) THEN
            J0 = SURFACE_PROPEL%POINT_RELATEDPT(0+1,I)
            IF(SURFACE_PROPEL%POINT_TYPE(I)==3 .OR. SURFACE_PROPEL%POINT_TYPE(I)==6) THEN
                IF(SQRT(DOT_PRODUCT(SURFACE_PROPEL%SURFACE_POINTS(:,I)-SURFACE_FLUID%SURFACE_POINTS(:,J0) , SURFACE_PROPEL%SURFACE_POINTS(:,I)-SURFACE_FLUID%SURFACE_POINTS(:,J0) ))< SURFACE_FLUID%MESH_SIZE/100.) THEN
                    PROPEL_MOVING_TYPE(I) = 1
                ELSE
                    PROPEL_MOVING_TYPE(I) = 2
                END IF
            ELSE IF(SURFACE_PROPEL%POINT_TYPE(I)==4 .OR. SURFACE_PROPEL%POINT_TYPE(I)==5) THEN
                IF(SURFACE_PROPEL%INITIAL_POINT_TYPE(I)==3) THEN
                    IF(SQRT(DOT_PRODUCT(SURFACE_PROPEL%SURFACE_POINTS(:,I)-SURFACE_FLUID%SURFACE_POINTS(:,J0) , SURFACE_PROPEL%SURFACE_POINTS(:,I)-SURFACE_FLUID%SURFACE_POINTS(:,J0) ))< SURFACE_FLUID%MESH_SIZE/100.) THEN
                        PROPEL_MOVING_TYPE(I) = 1
                    ELSE
                        PROPEL_MOVING_TYPE(I) = 2
                    END IF
                ELSE
                    PROPEL_MOVING_TYPE(I) = 2
                END IF
            ELSE IF(SURFACE_PROPEL%POINT_TYPE(I)==2) THEN
                PROPEL_MOVING_TYPE(I) = 2 !-1
            ELSE
                PROPEL_MOVING_TYPE(I) = 3
            END IF
        END IF
    END DO

    END IF

    !! 1. FLUID MOVING !!

    CALL FACEOFFSETTING_3D(0,TIME_STEP)

    IF(SURFACE_MOVING_TYPE==2 .OR. SURFACE_MOVING_TYPE==3) THEN

    ALLOCATE(TYP1_POINT(3,INTERFACE_FLUID_POINTS_NUM))
    ALLOCATE(TYP1_POINTLOC(3,INTERFACE_FLUID_POINTS_NUM))
    ALLOCATE(TYP1_FACE(3,INTERFACE_FLUID_FACES_NUM))
    ALLOCATE(DATA_DISPLACEMENT(3,SURFACE_FLUID%SURFACE_POINTS_NUM))

    TYP1_POINT_NUM = INTERFACE_FLUID_POINTS_NUM
    TYP1_POINT = INTERFACE_FLUID_POINTS
    TYP1_POINTLOC = INTERFACE_FLUID_POINTS_LOC
    TYP1_FACE_NUM = INTERFACE_FLUID_FACES_NUM
    TYP1_FACE = INTERFACE_FLUID_FACES
    DATA_DISPLACEMENT = SURFACE_FLUID%POINT_DISPLACEMENT

    END IF

    !CALL NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP(0)
    CALL FLUID_SMOOTHING()

    IF(SURFACE_MOVING_TYPE==2 .OR. SURFACE_MOVING_TYPE==3) THEN

    CALL INTERPOLATE_FLUID_DISPLACEMENT(TYP1_POINT_NUM, TYP1_POINT, TYP1_POINTLOC, TYP1_FACE_NUM, TYP1_FACE, DATA_DISPLACEMENT)

    DEALLOCATE(TYP1_POINT)
    DEALLOCATE(TYP1_POINTLOC)
    DEALLOCATE(TYP1_FACE)
    DEALLOCATE(DATA_DISPLACEMENT)

    END IF


    !! 2. PROPEL MOVING !!

    IF (SURFACE_MOVING_TYPE==1 .OR. SURFACE_MOVING_TYPE==2 .OR. SURFACE_MOVING_TYPE==3) THEN

    DO I=1,SURFACE_PROPEL%SURFACE_POINTS_NUM
        IF(PROPEL_MOVING_TYPE(I) == 1) THEN
            SURFACE_PROPEL%SURFACE_POINTS(:,I) = SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_PROPEL%POINT_RELATEDPT(0+1,I))
        ELSE IF(PROPEL_MOVING_TYPE(I) == 2) THEN
            J = SURFACE_PROPEL%POINT_RELATEDFACE(0+1,I)
            CALL NEIGHBOR_RIDGE_PROJECTION(1,I,0,J)
        ELSE IF(PROPEL_MOVING_TYPE(I) == 3) THEN
            J = SURFACE_PROPEL%POINT_RELATEDFACE(0+1,I)
            !I1 = SURFACE_FLUID%SURFACE_FACES(1,J)
            !I2 = SURFACE_FLUID%SURFACE_FACES(2,J)
            !I3 = SURFACE_FLUID%SURFACE_FACES(3,J)
            
            CALL PROJECTION_FACE_POINT_HIGHORDER(SURFACE_PROPEL%SURFACE_POINTS(:,I), J, SURFACE_FLUID%SURFACE_POINTS_NUM, SURFACE_FLUID%SURFACE_POINTS, SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION, SURFACE_FLUID%POINT_TYPE)
            !CALL PROJECTION_FACE_POINT(SURFACE_PROPEL%SURFACE_POINTS(:,I),SURFACE_FLUID%SURFACE_POINTS(:,I1),SURFACE_FLUID%SURFACE_POINTS(:,I2),SURFACE_FLUID%SURFACE_POINTS(:,I3))
        END IF
    END DO

    !CALL NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP(1)
    CALL PROPEL_SMOOTHING()

    DEALLOCATE(PROPEL_MOVING_TYPE)

    !! 3. CASE MOVING !!

    DO I=1,SURFACE_CASE%SURFACE_POINTS_NUM
        IF(SURFACE_CASE%POINT_RELATEDPT(1+1,I) .NE. 0) THEN
            !IF(SURFACE_CASE%POINT_TYPE(I)==4 .OR. SURFACE_CASE%POINT_TYPE(I)==6) THEN
            SURFACE_CASE%SURFACE_POINTS(:,I) = SURFACE_PROPEL%SURFACE_POINTS(:,SURFACE_CASE%POINT_RELATEDPT(1+1,I))
        END IF
    END DO

    !! NOZZLE ABLATION
    DO I=1,SURFACE_CASE%SURFACE_POINTS_NUM
        B = .FALSE.
        DO J=1,SURFACE_CASE%POINT_FACE_CONNECTION_NUM(I)
            K = SURFACE_CASE%POINT_FACE_CONNECTION(J,I)
            IF(SURFACE_CASE%FACE_ONINTERFACE(K)==0) THEN
                B = .TRUE.
                EXIT
            END IF
        END DO
        IF(B) THEN
            
            J = SURFACE_CASE%POINT_RELATEDFACE(0+1,I)
            IF(J .NE. 0) THEN
                IF(SURFACE_FLUID%FACE_ABLATION_FLAG(J) == -2) THEN
                    !I1 = SURFACE_FLUID%SURFACE_FACES(1,J)
                    !I2 = SURFACE_FLUID%SURFACE_FACES(2,J)
                    !I3 = SURFACE_FLUID%SURFACE_FACES(3,J)
                    
                    CALL PROJECTION_FACE_POINT_HIGHORDER(SURFACE_CASE%SURFACE_POINTS(:,I), J, SURFACE_FLUID%SURFACE_POINTS_NUM, SURFACE_FLUID%SURFACE_POINTS, SURFACE_FLUID%SURFACE_FACES, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM, SURFACE_FLUID%POINT_FACE_CONNECTION, SURFACE_FLUID%POINT_TYPE)
                    !CALL PROJECTION_FACE_POINT(SURFACE_CASE%SURFACE_POINTS(:,I),SURFACE_FLUID%SURFACE_POINTS(:,I1),SURFACE_FLUID%SURFACE_POINTS(:,I2),SURFACE_FLUID%SURFACE_POINTS(:,I3))
                END IF
            END IF
            
        END IF
    END DO

    !CALL NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP(2)
    CALL CASE_SMOOTHING()

    !FLAG = .TRUE.
    !CALL UPDATE_CASE_INTERFACE(FLAG)
    !IF(FLAG) THEN
    !    !CALL FIND_INTERFACE_CLUSTER(0)
    !    CALL FIND_INTERFACE_CLUSTER(1)
    !END IF

    !CALL MAINTAIN_CASE_CORNER()

    CALL UPDATE_RELATEDFACE(1,0,.FALSE.)

    !CALL UPDATE_RELATEDFACE(1,2,.TRUE.)

    CALL UPDATE_RELATEDFACE(2,0,.FALSE.)

    CALL UPDATE_IMPACT_ZONE(1,1)

    END IF
    
    !! PROJECTING FLUID TO CASE
    
    DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
        B = .FALSE.
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            IF(SURFACE_FLUID%FACE_ONINTERFACE(SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)) == 2) THEN
                B = .TRUE.
            END IF
        END DO
        
        IF(B .AND. SURFACE_FLUID%POINT_TYPE(I) .NE. 4) THEN
        C = .TRUE.
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            IF(SURFACE_FLUID%FACE_ABLATION_FLAG(SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)) == -2) THEN
                C = .FALSE.
            END IF
        END DO
        IF(C) THEN
            J = SURFACE_FLUID%POINT_RELATEDFACE(2+1,I)
            IF(J.NE.0) THEN
            
            IF(SURFACE_FLUID%POINT_TYPE(I)==5 .AND. SURFACE_FLUID%INITIAL_POINT_TYPE(I) .NE. 3) THEN
                CALL NEIGHBOR_RIDGE_PROJECTION(0,I,2,J)
            ELSE IF(SURFACE_FLUID%POINT_TYPE(I)==1) THEN
                CALL PROJECTION_FACE_POINT_HIGHORDER(SURFACE_FLUID%SURFACE_POINTS(:,I), J, SURFACE_CASE%SURFACE_POINTS_NUM, SURFACE_CASE%SURFACE_POINTS, SURFACE_CASE%SURFACE_FACES, SURFACE_CASE%POINT_FACE_CONNECTION_NUM, SURFACE_CASE%POINT_FACE_CONNECTION, SURFACE_CASE%POINT_TYPE)
                !CALL PROJECTION_FACE_POINT(SURFACE_FLUID%SURFACE_POINTS(:,I), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,J)), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,J)), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,J)))
            END IF
            
            END IF
            
        END IF
        END IF
    END DO
    
    CALL UPDATE_RELATEDFACE(0,2,.FALSE.)
    CALL UPDATE_IMPACT_ZONE(0,0)
    !CALL UPDATE_IMPACT_ZONE(0,2)
    
    END SUBROUTINE FLUID_MOVE

    
    
    SUBROUTINE STRUCT_MOVE()
    IMPLICIT NONE
    INTEGER :: I
    REAL(8) :: ZEROVEC(0)
    
    !$OMP PARALLEL DO PRIVATE(I)
    DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
        SURFACE_FLUID%POINT_VELOCITY(:,I) = 0.
    END DO
    !$OMP END PARALLEL DO

    !CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_VELOCITY(1,:),SURFACE_CASE%POINT_VELOCITY(1,:),SURFACE_FLUID%POINT_VELOCITY(1,:),ZEROVEC)
    !CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_VELOCITY(2,:),SURFACE_CASE%POINT_VELOCITY(2,:),SURFACE_FLUID%POINT_VELOCITY(2,:),ZEROVEC)
    !CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_VELOCITY(3,:),SURFACE_CASE%POINT_VELOCITY(3,:),SURFACE_FLUID%POINT_VELOCITY(3,:),ZEROVEC)

    !DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
    !    SURFACE_FLUID%POINT_DISPLACEMENT(:,I) = SURFACE_FLUID%POINT_DISPLACEMENT(:,I) + SURFACE_FLUID%POINT_VELOCITY(:,I)
    !END DO

    CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_DISPLACEMENT(1,:),SURFACE_CASE%POINT_DISPLACEMENT(1,:),SURFACE_FLUID%POINT_DISPLACEMENT(1,:),ZEROVEC)
    CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_DISPLACEMENT(2,:),SURFACE_CASE%POINT_DISPLACEMENT(2,:),SURFACE_FLUID%POINT_DISPLACEMENT(2,:),ZEROVEC)
    CALL EXTRAPOLATION_COMMON_REFINEMENT(1,0,SURFACE_PROPEL%POINT_DISPLACEMENT(3,:),SURFACE_CASE%POINT_DISPLACEMENT(3,:),SURFACE_FLUID%POINT_DISPLACEMENT(3,:),ZEROVEC)

    END SUBROUTINE STRUCT_MOVE

    
    
    SUBROUTINE PRESSURE_TRANSFER()
    IMPLICIT NONE
    INTEGER :: I,J,K,I1,I2,I3,I4
    INTEGER :: FACE_NUM
    REAL(8), ALLOCATABLE :: FLUID_POINT_PRESSURE(:), FLUID_FACE_AREA(:), FLUID_NORMAL(:,:), NEIGHBOR_AREA_SUM(:)
    REAL(8), ALLOCATABLE :: TYP1_POINT(:,:)
    INTEGER, ALLOCATABLE :: TYP1_FACE(:,:), FACE(:,:)
    !INTEGER, ALLOCATABLE :: TYP1_CONNECTION_NUM(:)
    !INTEGER, ALLOCATABLE :: TYP1_CONNECTION(:,:)
    !REAL(8), ALLOCATABLE :: TYP1_NORMAL(:,:)
    !REAL(8), ALLOCATABLE :: TYP1_FACE_AREA(:)	
    REAL(8), ALLOCATABLE :: TYP2_POINT(:,:)
    INTEGER, ALLOCATABLE :: TYP2_FACE(:,:)
    INTEGER, ALLOCATABLE :: CONNECTION_NUM(:), CONNECTION(:,:)
    REAL(8), ALLOCATABLE :: NORMAL(:,:), CENTER(:,:), SQUARE_ELEMENT_PRESSURE(:)
    REAL(8), ALLOCATABLE :: AREA(:)
    REAL(8), ALLOCATABLE :: POINT_FORCE(:,:)
    REAL(8), ALLOCATABLE :: CR_SOURCE(:)
    REAL(8), ALLOCATABLE :: CR_TARGET(:)
    REAL(8) :: FLUID_TOTAL_PRESSURE, STRUCT_TOTAL_PRESSURE
    REAL(8) :: V1(3), V2(3),V3(3), POINT_I1(3), POINT_I2(3),POINT_I3(3), POINT_I4(3),TEMP_FORCE(3), TEMP_NORMAL1(3), TEMP_NORMAL2(3)
    INTEGER :: TYP1_POINT_NUM, TYP2_POINT_NUM, TYP1_FACE_NUM, TYP2_FACE_NUM, TEMP_FACE_INDEX
    CHARACTER(500) :: STR

    SURFACE_FLUID%POINT_FORCE(:,:) = 0.
    SURFACE_PROPEL%POINT_FORCE(:,:) = 0.
    SURFACE_CASE%POINT_FORCE(:,:) = 0.

    ALLOCATE(FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_POINTS_NUM))
    ALLOCATE(FLUID_FACE_AREA(SURFACE_FLUID%SURFACE_FACES_NUM))
    ALLOCATE(FLUID_NORMAL(3,SURFACE_FLUID%SURFACE_FACES_NUM))
    FLUID_POINT_PRESSURE(:) = 0.
    FLUID_FACE_AREA(:) = 0.
    FLUID_NORMAL(:,:) = 0.

    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
        V1 = SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_FLUID%SURFACE_FACES(1,I))
        V2 = SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_FLUID%SURFACE_FACES(2,I))
        V3 = SURFACE_FLUID%SURFACE_POINTS(:,SURFACE_FLUID%SURFACE_FACES(3,I))
        CALL VEC_CURL2(V1,V2,V1,V3,FLUID_NORMAL(:,I))
        FLUID_FACE_AREA(I) = SQRT(DOT_PRODUCT(FLUID_NORMAL(:,I),FLUID_NORMAL(:,I)))/2.
        FLUID_NORMAL(:,I) = FLUID_NORMAL(:,I)/SQRT(DOT_PRODUCT(FLUID_NORMAL(:,I),FLUID_NORMAL(:,I)))
    END DO

    ALLOCATE(NEIGHBOR_AREA_SUM(SURFACE_FLUID%SURFACE_POINTS_NUM))
    NEIGHBOR_AREA_SUM(:) = 0.

    DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
        DO J=1,SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
            K = SURFACE_FLUID%POINT_FACE_CONNECTION(J,I)
            NEIGHBOR_AREA_SUM(I) = NEIGHBOR_AREA_SUM(I) + FLUID_FACE_AREA(K)
        END DO
    END DO

    DO I=1,SURFACE_FLUID%SURFACE_FACES_NUM
        !SURFACE_FLUID%POINT_FORCE(:,SURFACE_FLUID%SURFACE_FACES(1,I)) = SURFACE_FLUID%POINT_FORCE(:,SURFACE_FLUID%SURFACE_FACES(1,I)) + SURFACE_FLUID%FACE_PRESSURE(I)*FLUID_FACE_AREA(I)/3.*FLUID_NORMAL(:,I)
        !SURFACE_FLUID%POINT_FORCE(:,SURFACE_FLUID%SURFACE_FACES(2,I)) = SURFACE_FLUID%POINT_FORCE(:,SURFACE_FLUID%SURFACE_FACES(2,I)) + SURFACE_FLUID%FACE_PRESSURE(I)*FLUID_FACE_AREA(I)/3.*FLUID_NORMAL(:,I)
        !SURFACE_FLUID%POINT_FORCE(:,SURFACE_FLUID%SURFACE_FACES(3,I)) = SURFACE_FLUID%POINT_FORCE(:,SURFACE_FLUID%SURFACE_FACES(3,I)) + SURFACE_FLUID%FACE_PRESSURE(I)*FLUID_FACE_AREA(I)/3.*FLUID_NORMAL(:,I)
        FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(1,I)) = FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(1,I)) + SURFACE_FLUID%FACE_PRESSURE(I)/SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(SURFACE_FLUID%SURFACE_FACES(1,I))
        FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(2,I)) = FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(2,I)) + SURFACE_FLUID%FACE_PRESSURE(I)/SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(SURFACE_FLUID%SURFACE_FACES(2,I))
        FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(3,I)) = FLUID_POINT_PRESSURE(SURFACE_FLUID%SURFACE_FACES(3,I)) + SURFACE_FLUID%FACE_PRESSURE(I)/SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(SURFACE_FLUID%SURFACE_FACES(3,I))
    END DO

    !DO I=1,SURFACE_FLUID%SURFACE_POINTS_NUM
    !    FLUID_POINT_PRESSURE(I) = SQRT(DOT_PRODUCT(SURFACE_FLUID%POINT_FORCE(:,I)/(1./3.*NEIGHBOR_AREA_SUM(I)),SURFACE_FLUID%POINT_FORCE(:,I)/(1./3.*NEIGHBOR_AREA_SUM(I))))
    !END DO

    CALL UPDATE_INTERFACE_CLUSTER(0)
    CALL UPDATE_INTERFACE_CLUSTER(1)

    TYP1_POINT_NUM = INTERFACE_FLUID_POINTS_NUM + INTERFACE_FLUID_FACES_NUM
    ALLOCATE(TYP1_POINT(3,TYP1_POINT_NUM))
    !$OMP PARALLEL DO PRIVATE(I)
    DO I=1,INTERFACE_FLUID_POINTS_NUM
        TYP1_POINT(:,I) = INTERFACE_FLUID_POINTS(:,I)
    END DO
    !$OMP END PARALLEL DO

    ALLOCATE(CR_SOURCE(TYP1_POINT_NUM))
    DO I=1,TYP1_POINT_NUM
        IF(I<=INTERFACE_FLUID_POINTS_NUM) THEN
            CR_SOURCE(I) = FLUID_POINT_PRESSURE(INTERFACE_FLUID_POINTS_LOC(1,I))
        ELSE
            TEMP_FACE_INDEX = INTERFACE_FLUID_FACES_LOC(1,I-INTERFACE_FLUID_POINTS_NUM)
            CR_SOURCE(I) = SURFACE_FLUID%FACE_PRESSURE(TEMP_FACE_INDEX)
        END IF

    END DO

    TYP1_FACE_NUM = 3*INTERFACE_FLUID_FACES_NUM
    ALLOCATE(TYP1_FACE(3,TYP1_FACE_NUM))
    !$OMP PARALLEL DO PRIVATE(I)
    DO I=1,INTERFACE_FLUID_FACES_NUM
        I1 = INTERFACE_FLUID_FACES(1,I)
        I2 = INTERFACE_FLUID_FACES(2,I)
        I3 = INTERFACE_FLUID_FACES(3,I)

        TYP1_POINT(:,I+INTERFACE_FLUID_POINTS_NUM) = (INTERFACE_FLUID_POINTS(:,I1) + INTERFACE_FLUID_POINTS(:,I2) + INTERFACE_FLUID_POINTS(:,I3))/3.0

        TYP1_FACE(1,3*I-2) = I1
        TYP1_FACE(2,3*I-2) = I2
        TYP1_FACE(3,3*I-2) = INTERFACE_FLUID_POINTS_NUM + I

        TYP1_FACE(1,3*I-1) = I2
        TYP1_FACE(2,3*I-1) = I3
        TYP1_FACE(3,3*I-1) = INTERFACE_FLUID_POINTS_NUM + I 

        TYP1_FACE(1,3*I-0) = I3
        TYP1_FACE(2,3*I-0) = I1
        TYP1_FACE(3,3*I-0) = INTERFACE_FLUID_POINTS_NUM + I 
    END DO
    !$OMP END PARALLEL DO

    !ALLOCATE(TYP1_CONNECTION_NUM(TYP1_POINT_NUM))
    !ALLOCATE(TYP1_CONNECTION(30,TYP1_POINT_NUM))

    !TYP1_CONNECTION_NUM = 0
    !TYP1_CONNECTION = 0

    !DO I=1,TYP1_FACE_NUM
    !    DO J=1,3
    !        TYP1_CONNECTION_NUM(TYP1_FACE(J,I)) = TYP1_CONNECTION_NUM(TYP1_FACE(J,I)) + 1
    !        TYP1_CONNECTION(TYP1_CONNECTION_NUM(TYP1_FACE(J,I)),TYP1_FACE(J,I)) = I
    !    END DO
    !END DO

    !ALLOCATE(TYP1_NORMAL(3,TYP1_FACE_NUM))
    !ALLOCATE(TYP1_FACE_AREA(TYP1_FACE_NUM))	

    !DO I=1,TYP1_FACE_NUM
    !    V1 = TYP1_POINT(:,TYP1_FACE(1,I))
    !    V2 = TYP1_POINT(:,TYP1_FACE(2,I))
    !    V3 = TYP1_POINT(:,TYP1_FACE(3,I))
    !    CALL VEC_CURL2(V1,V2,V1,V3,V)
    !    TYP1_NORMAL(:,I) = V
    !    TYP1_FACE_AREA(I) = SQRT(DOT_PRODUCT(V,V))/2.
    !END DO

    TYP2_POINT_NUM = INTERFACE_STRUCT_POINTS_NUM + INTERFACE_STRUCT_FACES_NUM
    ALLOCATE(TYP2_POINT(3,TYP2_POINT_NUM))
    !$OMP PARALLEL DO PRIVATE(I)
    DO I=1,TYP2_POINT_NUM
        IF(I<=INTERFACE_STRUCT_POINTS_NUM) THEN
            TYP2_POINT(:,I) = INTERFACE_STRUCT_POINTS(:,I)
        ELSE

        END IF
    END DO
    !$OMP END PARALLEL DO

    TYP2_FACE_NUM = 3*INTERFACE_STRUCT_FACES_NUM
    ALLOCATE(TYP2_FACE(3,TYP2_FACE_NUM))
    !$OMP PARALLEL DO PRIVATE(I)
    DO I=1,INTERFACE_STRUCT_FACES_NUM
        I1 = INTERFACE_STRUCT_FACES(1,I)
        I2 = INTERFACE_STRUCT_FACES(2,I)
        I3 = INTERFACE_STRUCT_FACES(3,I)

        TYP2_POINT(:,I+INTERFACE_STRUCT_POINTS_NUM) = (INTERFACE_STRUCT_POINTS(:,I1) + INTERFACE_STRUCT_POINTS(:,I2) + INTERFACE_STRUCT_POINTS(:,I3))/3.0

        TYP2_FACE(1,3*I-2) = I1
        TYP2_FACE(2,3*I-2) = I2
        TYP2_FACE(3,3*I-2) = INTERFACE_STRUCT_POINTS_NUM + I

        TYP2_FACE(1,3*I-1) = I2
        TYP2_FACE(2,3*I-1) = I3
        TYP2_FACE(3,3*I-1) = INTERFACE_STRUCT_POINTS_NUM + I 

        TYP2_FACE(1,3*I-0) = I3
        TYP2_FACE(2,3*I-0) = I1
        TYP2_FACE(3,3*I-0) = INTERFACE_STRUCT_POINTS_NUM + I 		
    END DO
    !$OMP END PARALLEL DO

    ALLOCATE(CR_TARGET(TYP2_POINT_NUM))
    CR_TARGET(:) = 0.

    CALL DATA_TRANSFER_WITHOUT_CR(TYP1_POINT_NUM, TYP1_POINT, TYP1_FACE_NUM, TYP1_FACE, CR_SOURCE, TYP2_POINT_NUM, TYP2_POINT, CR_TARGET)

    !RECOVER QUAD MESH FROM TRIANGULAR MESH	

    FACE_NUM = INTERFACE_STRUCT_FACES_NUM/2
    ALLOCATE(FACE(4,FACE_NUM))

    DO I=1,FACE_NUM
        FACE(1,I) = INTERFACE_STRUCT_FACES(1,2*I-1)
        FACE(2,I) = INTERFACE_STRUCT_FACES(2,2*I-1)
        FACE(3,I) = INTERFACE_STRUCT_FACES(3,2*I-1)
        FACE(4,I) = INTERFACE_STRUCT_FACES(3,2*I)
    END DO

    ALLOCATE(CONNECTION_NUM(INTERFACE_STRUCT_POINTS_NUM))
    ALLOCATE(CONNECTION(30,INTERFACE_STRUCT_POINTS_NUM))

    CONNECTION = 0
    CONNECTION_NUM = 0

    DO I=1,FACE_NUM
        DO J=1,4
            CONNECTION_NUM(FACE(J,I)) = CONNECTION_NUM(FACE(J,I)) + 1
            CONNECTION(CONNECTION_NUM(FACE(J,I)),FACE(J,I)) = I
        END DO
    END DO

    ALLOCATE(CENTER(3,FACE_NUM))
    ALLOCATE(NORMAL(3,FACE_NUM))
    ALLOCATE(AREA(FACE_NUM))

    DO I=1,FACE_NUM
        IF(INTERFACE_STRUCT_FACES_LOC(2,2*I-1)==1 .AND. INTERFACE_STRUCT_FACES_LOC(2,2*I)==1) THEN
            I1 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(1,I))
            I2 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(2,I))
            I3 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(3,I))
            I4 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(4,I))
            POINT_I1 = INTERFACE_STRUCT_POINTS(:,FACE(1,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I1)
            POINT_I2 = INTERFACE_STRUCT_POINTS(:,FACE(2,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I2)
            POINT_I3 = INTERFACE_STRUCT_POINTS(:,FACE(3,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I3)
            POINT_I4 = INTERFACE_STRUCT_POINTS(:,FACE(4,I)) + SURFACE_PROPEL%POINT_DISPLACEMENT(:,I4)

        ELSE IF(INTERFACE_STRUCT_FACES_LOC(2,2*I-1)==2 .AND. INTERFACE_STRUCT_FACES_LOC(2,2*I)==2) THEN
            I1 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(1,I))
            I2 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(2,I))
            I3 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(3,I))
            I4 = INTERFACE_STRUCT_POINTS_LOC(1,FACE(4,I))
            POINT_I1 = INTERFACE_STRUCT_POINTS(:,FACE(1,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I1)
            POINT_I2 = INTERFACE_STRUCT_POINTS(:,FACE(2,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I2)
            POINT_I3 = INTERFACE_STRUCT_POINTS(:,FACE(3,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I3)
            POINT_I4 = INTERFACE_STRUCT_POINTS(:,FACE(4,I)) + SURFACE_CASE%POINT_DISPLACEMENT(:,I4)
        ELSE
            WRITE(*,*) 'PRESSURE_TRANSFER : INTERFACE FACE INDEX IS WRONG' 
        END IF

        CALL VEC_CURL2(POINT_I1,POINT_I2,POINT_I1,POINT_I3,TEMP_NORMAL1)
        CALL VEC_CURL2(POINT_I1,POINT_I3,POINT_I1,POINT_I4,TEMP_NORMAL2)
        CENTER(:,I) = (POINT_I1+POINT_I2+POINT_I3+POINT_I4)/4.

        AREA(I) = (SQRT(DOT_PRODUCT(TEMP_NORMAL1, TEMP_NORMAL1)) + SQRT(DOT_PRODUCT(TEMP_NORMAL2, TEMP_NORMAL2)))/2.
        NORMAL(:,I) = TEMP_NORMAL1+TEMP_NORMAL2
        NORMAL(:,I) = NORMAL(:,I)/SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I))) 
    END DO

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !CR_TARGET = 1.
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    ALLOCATE(POINT_FORCE(3,INTERFACE_STRUCT_POINTS_NUM))
    POINT_FORCE(:,:) = 0.

    DO I=1,FACE_NUM
        TEMP_FORCE = (CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I-1)+CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I))/2. * AREA(I)/4. * NORMAL(:,I)
        IF(INTERFACE_STRUCT_FACES_LOC(2,2*I-1) == 1 .AND. INTERFACE_STRUCT_FACES_LOC(2,2*I) == 1) THEN
            SURFACE_PROPEL%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I-1)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I-1)
            SURFACE_PROPEL%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I)
        ELSE IF(INTERFACE_STRUCT_FACES_LOC(2,2*I-1) == 2 .AND. INTERFACE_STRUCT_FACES_LOC(2,2*I) == 2) THEN
            SURFACE_CASE%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I-1)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I-1)
            SURFACE_CASE%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I)
        ELSE
            WRITE(*,*) 'PRESSURE_TRANSFER : INTERFACE FACE INDEX IS WRONG' 
        END IF

        DO J = 1, 4
            POINT_FORCE(:,FACE(J,I)) = POINT_FORCE(:,FACE(J,I)) + TEMP_FORCE
        END DO
    END DO

    DO I=1,INTERFACE_STRUCT_POINTS_NUM
        POINT_FORCE(:,I) = POINT_FORCE(:,I)/REAL(CONNECTION_NUM(I))
    END DO
    ALLOCATE(SQUARE_ELEMENT_PRESSURE(FACE_NUM))

    !DO I=1,FACE_NUM
    !    SQUARE_ELEMENT_PRESSURE(I) = (CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I-1)+CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I))/2.
    !    IF(INTERFACE_STRUCT_FACES_LOC(2,2*I-1) == 1 .AND. INTERFACE_STRUCT_FACES_LOC(2,2*I) == 1) THEN
    !	SURFACE_PROPEL%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I-1)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I-1)
    !	SURFACE_PROPEL%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I)
    !    ELSE IF(INTERFACE_STRUCT_FACES_LOC(2,2*I-1) == 2 .AND. INTERFACE_STRUCT_FACES_LOC(2,2*I) == 2) THEN
    !	SURFACE_CASE%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I-1)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I-1)
    !	SURFACE_CASE%FACE_PRESSURE(INTERFACE_STRUCT_FACES_LOC(1,2*I)) = CR_TARGET(INTERFACE_STRUCT_POINTS_NUM + 2*I)
    !    ELSE
    !	WRITE(*,*) 'PRESSURE_TRANSFER : INTERFACE FACE INDEX IS WRONG' 
    !    END IF
    !END DO

    !DO I=1,INTERFACE_STRUCT_POINTS_NUM
    !    DO J=1,CONNECTION_NUM(I)
    !	AREA = 0.
    !	IDX = 0
    !	K = CONNECTION(J,I)
    !	DO L=1,4
    !	    IF(FACE(L,K) == I) THEN
    !		IDX = L
    !		EXIT
    !	    END IF
    !	END DO
    !	I1 = MOD(IDX,4)+1
    !	I2 = MOD(IDX+2,4)+1
    !	CALL VEC_CURL2(INTERFACE_STRUCT_POINTS(:,I),INTERFACE_STRUCT_POINTS(:,I1),INTERFACE_STRUCT_POINTS(:,I),INTERFACE_STRUCT_POINTS(:,I2),TEMPVEC)
    !	AREA = AREA + SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))/2.
    !	CALL VEC_CURL2(INTERFACE_STRUCT_POINTS(:,I1),CENTER(:,K),INTERFACE_STRUCT_POINTS(:,I2),CENTER(:,K),TEMPVEC)
    !	AREA = AREA + SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))/2.
    !	TEMP_FORCE = AREA*SQUARE_ELEMENT_PRESSURE(K)
    !        POINT_FORCE(:,I) = POINT_FORCE(:,I)+ TEMP_FORCE
    !    END DO
    !END DO

    !$OMP PARALLEL DO PRIVATE(I)
    DO I=1,INTERFACE_STRUCT_POINTS_NUM
        IF(INTERFACE_STRUCT_POINTS_LOC(2,I)==1) THEN
            SURFACE_PROPEL%POINT_FORCE(:,INTERFACE_STRUCT_POINTS_LOC(1,I)) = -1.*POINT_FORCE(:,I)
        ELSE
            SURFACE_CASE%POINT_FORCE(:,INTERFACE_STRUCT_POINTS_LOC(1,I)) = -1.*POINT_FORCE(:,I)
        END IF
    END DO
    !$OMP END PARALLEL DO

    IF(.FALSE.) THEN

    FLUID_TOTAL_PRESSURE = 1.
    STRUCT_TOTAL_PRESSURE = 0.
    TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,1) = FLUID_TOTAL_PRESSURE
    TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,2) = STRUCT_TOTAL_PRESSURE

    IF(FLUID_TOTAL_PRESSURE .NE. 0) THEN
        TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,3) = (STRUCT_TOTAL_PRESSURE-FLUID_TOTAL_PRESSURE)/(FLUID_TOTAL_PRESSURE) 
    END IF
    STR = './output/surface/totalpressure2d.txt'

    OPEN(UNIT=21, FILE = STR, ACTION = "WRITE", STATUS = "REPLACE")

    DO I = 1, SURFACE_PRESSURE_ITER
        WRITE(21,'(F,F,F)') TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,1), TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,2), TOTAL_PRESSURE_ARRAY(SURFACE_PRESSURE_ITER,3)
    END DO

    CLOSE(21)
    END IF
    DEALLOCATE(FLUID_POINT_PRESSURE)
    DEALLOCATE(TYP1_POINT)
    DEALLOCATE(TYP1_FACE)
    !DEALLOCATE(TYP1_CONNECTION_NUM)
    !DEALLOCATE(TYP1_CONNECTION)
    !DEALLOCATE(TYP1_NORMAL)
    !DEALLOCATE(TYP1_FACE_AREA)	
    DEALLOCATE(TYP2_POINT)
    DEALLOCATE(TYP2_FACE)
    DEALLOCATE(NORMAL)
    DEALLOCATE(CENTER)
    DEALLOCATE(POINT_FORCE)
    DEALLOCATE(SQUARE_ELEMENT_PRESSURE)
    DEALLOCATE(CR_SOURCE)
    DEALLOCATE(CR_TARGET)
    DEALLOCATE(FACE)
    DEALLOCATE(CONNECTION_NUM)
    DEALLOCATE(CONNECTION)

    END SUBROUTINE PRESSURE_TRANSFER

    
    
    SUBROUTINE NEIGHBOR_RIDGE_PROJECTION(TYP1,J0,TYP2,I0)
    IMPLICIT NONE
    INTEGER :: TYP1, TYP2
    INTEGER :: J0, I0
    
    INTEGER :: K, KMIN
    REAL(8) :: R, RMIN
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT1, SURFACE_CURRENT2

    IF (TYP1==0) THEN
        SURFACE_CURRENT1 => SURFACE_FLUID
    END IF
    IF (TYP1==1) THEN
        SURFACE_CURRENT1 => SURFACE_PROPEL
    END IF
    IF (TYP1==2) THEN
        SURFACE_CURRENT1 => SURFACE_CASE
    END IF        

    IF (TYP2==0) THEN
        SURFACE_CURRENT2 => SURFACE_FLUID
    END IF
    IF (TYP2==1) THEN
        SURFACE_CURRENT2 => SURFACE_PROPEL
    END IF
    IF (TYP2==2) THEN
        SURFACE_CURRENT2 => SURFACE_CASE
    END IF
    
    RMIN = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))
    KMIN = 0
    
    DO K=1,3
        IF(SURFACE_CURRENT2%FACE_DIVIDED_BOUNDARY_ARRAY(K,I0) .NE. 0) THEN
            CALL UNSIGNED_DISTANCE_EDGE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,J0),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(K,I0)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(MOD(K,3)+1,I0)),R)
            IF(R<RMIN) THEN
                RMIN = R
                KMIN = K
            END IF
        END IF
    END DO
    
    CALL PROJECTION_RIDGE_POINT_HIGHORDER(SURFACE_CURRENT1%SURFACE_POINTS(:,J0), I0, KMIN, SURFACE_CURRENT2%SURFACE_POINTS_NUM, SURFACE_CURRENT2%SURFACE_POINTS, SURFACE_CURRENT2%SURFACE_FACES_NUM, SURFACE_CURRENT2%SURFACE_FACES, SURFACE_CURRENT2%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT2%POINT_FACE_CONNECTION, SURFACE_CURRENT2%FACE_DIVIDED_BOUNDARY_ARRAY(KMIN,I0), ALL_RIDGE = SURFACE_CURRENT2%RIDGE, ALL_RIDGE_NUM = SURFACE_CURRENT2%RIDGE_NUM)
    
    END SUBROUTINE NEIGHBOR_RIDGE_PROJECTION

    SUBROUTINE WAVEFRONT_DISPLACEMENT(TYP, TIMESTEP, RESULT_TIMESTEP)
        IMPLICIT NONE
        INTEGER :: TYP
        
        REAL(8) :: TIMESTEP, RESULT_TIMESTEP, DISPLACEMENT_THRESHOLD1, DISPLACEMENT_THRESHOLD2, EDGE_LENGTH
        REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:), DISPLACEMENT_THRESHOLD(:)
        
        REAL(8), ALLOCATABLE :: FACE_AREA(:)
        REAL(8), ALLOCATABLE :: FACE_CENTER(:,:)
        
        INTEGER :: I,J,K,L,M, IDX, POINT_IDX
        INTEGER :: I0,I1,I2,I3, J1,J2,J3,J4,J5,J6,J7, N1,N2,N3, TEMP_I !N4,N5,N6, TEMP_I, TEMP1, TEMP2
        REAL(8) :: V(3), V1(3),V2(3),R,TEMPVEC(3),TEMP_NORMAL(3),L1,L2 !V3(3)
        REAL(8), ALLOCATABLE :: NORMAL(:,:)
        
        INTEGER :: CON_NUM, RELATED_FACE !NEW_RELATED_FACE
        
        INTEGER :: LOCAL_SHAPE
        
        REAL(8), ALLOCATABLE :: N(:,:), A(:), W(:)
        REAL(8) :: W_SUM
        REAL(8) :: B(3)
        
        REAL(8) :: E_VALUE(3)
        REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
        
        INTEGER :: JMIN, TEMP !TEMP_INDEX
        REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3) !TEST_POINT1(3), TEST_POINT2(3)
        
        REAL(8), ALLOCATABLE :: TEMPPOINT(:,:)
        INTEGER :: TEMPFACE(2,10)
        
        REAL(8), ALLOCATABLE :: LENGTH(:)
        REAL(8), ALLOCATABLE :: MU(:), LL(:), COSTHETA(:)
        REAL(8) :: MU_SUM
        LOGICAL :: EXPANDING, FLAG, FLAG1, FLAG2, FLAG3, B0, B1, B5 !B2, B3, B4, B5
        LOGICAL, ALLOCATABLE :: POINT_USED(:)
        REAL(8) :: D(3),DIR(3)
        
        REAL(8) :: THETA_A, PHI_C, PHI_R, CHI_C, CHI_R
	REAL(8) :: DIST1, DIST2 !POINT_DIST, MINDIST, MINDIST1, MINDIST2, DIST3, DISTANCE
	!REAL(8) :: ORIGINAL_MOVE_POINT(3), COPY_POINT(3), PROJ_POINT(3)
    
        INTEGER :: RIDGE_NUM, FACE_IDX, FACE_INDEX, VERTEX, NUM, NEIGHBOR_INDEX, POINT_IDX1, POINT_IDX2, POINT_IDX3 !RIDGE(2)
        REAL(8) :: NEIGHBOR_RIDGE_POINT(3,2), INNER, INNER1, INNER2, CRI, TEMPDIST,A1(3), A2(3),T(3), CENTER1(3), CENTER2(3) ! TEMP_POINT(3)
	REAL(8) :: TEMP_NORMAL2(3),RELATED_NORMAL(3), TEMP_NEIGHBOR_NORMAL(3), NEIGHBOR_NORMAL(3), DIST, DIR1(3), DIR2(3), W1(3), W2(3), TEMP_DIST, POINTDIST
        INTEGER :: RIDGE_EDGE_NUM !SGN1, SGN2
        INTEGER, ALLOCATABLE :: RIDGE_EDGE(:,:)
        
        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF
        
        ALLOCATE(DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
        DISPLACEMENT = 0
        ALLOCATE(FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))
	FACE_AREA = 0
        ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
        NORMAL = 0
	!$OMP PARALLEL DO
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            
            I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
            I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
            I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
            
            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            
            ! Should modify for square case
            
            CALL VEC_CURL1(V1,V2, NORMAL(:,I))
            
            R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
                
            FACE_AREA(I) = R/2.
            

            NORMAL(:,I) = NORMAL(:,I) / R
            
        END DO
	!$OMP END PARALLEL DO
	
	!$OMP PARALLEL DO     
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM

            CON_NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            
            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(A(CON_NUM))
            ALLOCATE(W(CON_NUM))
            
            W_SUM = 0.
            THETA_A = 0.
            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                
                I1 = SURFACE_CURRENT%SURFACE_FACES(1,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I2 = SURFACE_CURRENT%SURFACE_FACES(2,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                I3 = SURFACE_CURRENT%SURFACE_FACES(3,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                
                IF(I==I1) THEN
                ELSE IF(I==I2) THEN
                    TEMP_I = I1
                    I1 = I2
                    I2 = I3
                    I3 = TEMP_I
                ELSE
                    TEMP_I = I1
                    I1 = I3
                    I3 = I2
                    I2 = TEMP_I
                END IF
                
                V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
                THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
            END DO
            
            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                W(J) = FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) / W_SUM
                A(J) = TIMESTEP * SURFACE_CURRENT%FACE_B_RATE(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
            END DO
            
            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
                
                B(K) = 0.
                DO J = 1,CON_NUM
                    B(K) = B(K) + W(J)*N(J,K)*A(J)
                END DO
            END DO
            
            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX
            
            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)
            
            DO J=1,2
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO
                
                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)
                    
                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)
                    
                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO
            
            
            THETA_A = THETA_A - 2.*PI
        
            PHI_R = 14. * PI/180.
            PHI_C = 45. * PI/180.
            
            CHI_R = 2.*(TAN(PHI_R/2.))**2
            CHI_C = 2.*(TAN(PHI_C/2.))**2
            
            IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/4.) THEN
                LOCAL_SHAPE = 3
            ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
                LOCAL_SHAPE = 2
            ELSE
                LOCAL_SHAPE = 1
            END IF
            
            DISPLACEMENT(:,I) = 0.
            
            LOCAL_SHAPE = SURFACE_CURRENT%INITIAL_POINT_TYPE(I)
	    DO J = 1, LOCAL_SHAPE
                DISPLACEMENT(:,I) = DISPLACEMENT(:,I) + DOT_PRODUCT(E_VECTOR(:,J),B(:))/E_VALUE(J) * E_VECTOR(:,J)
	    END DO
            
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))==0) THEN
                DEALLOCATE(N)
                DEALLOCATE(A)
                DEALLOCATE(W)
                CYCLE
	    END IF



IF(SURFACE_CURRENT%POINT_TYPE(I)==2 .OR. SURFACE_CURRENT%POINT_TYPE(I)==5) THEN

        FLAG1 = .FALSE.
	    FLAG2 = .FALSE.
	    FLAG3 = .FALSE.
	    TEMP = 0
		TEMPFACE = 0
	        DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
		    K = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==-1 .AND. .NOT. FLAG1) THEN
			FLAG1 = .TRUE.
           		TEMPFACE(1,1) = K
            	    END IF
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)== 1) THEN
			FLAG2 = .TRUE.
		    END IF
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)== 2) THEN
			FLAG3 = .TRUE.
            		TEMP = TEMP + 1
			TEMPFACE(2,TEMP) = K
		    END IF		
	        END DO

		IF(FLAG1 .AND. FLAG2) THEN
		    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,TEMPFACE(1,1))) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,TEMPFACE(1,1))) 
		    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,TEMPFACE(1,1))) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,TEMPFACE(1,1)))
		    CALL VEC_CURL1(V1,V2,TEMP_NORMAL)
		END IF

		IF(FLAG1 .AND. FLAG3) THEN
		    TEMP_NORMAL = 0.
		    DO J = 1, TEMP
		        V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,TEMPFACE(2,J))) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,TEMPFACE(2,J))) 
		        V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,TEMPFACE(2,J))) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,TEMPFACE(2,J)))
		        CALL VEC_CURL1(V1,V2,TEMPVEC)
			    TEMPVEC = TEMPVEC/SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
			    TEMP_NORMAL = TEMP_NORMAL + TEMPVEC/REAL(TEMP)		
		    END DO
        END IF
        
        TEMP_NORMAL = TEMP_NORMAL/SQRT(DOT_PRODUCT(TEMP_NORMAL,TEMP_NORMAL))
        INNER1 = DOT_PRODUCT(TEMP_NORMAL,MODEL_AXIS_EQN(1:3,1))
        INNER2 = DOT_PRODUCT(TEMP_NORMAL,MODEL_AXIS_EQN(1:3,2))

        IF(INNER1>=INNER2) THEN
            DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),MODEL_AXIS_EQN(1:3,1))*MODEL_AXIS_EQN(1:3,1)
            DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))             
        ELSE
            DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),MODEL_AXIS_EQN(1:3,2))*MODEL_AXIS_EQN(1:3,2)
            DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))                  
        END IF 
ELSE IF(SURFACE_CURRENT%POINT_TYPE(I)==3) THEN
		FLAG = .FALSE.
	        DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
		    K = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==-1) THEN
			FLAG = .TRUE.
			EXIT
		    END IF
	        END DO

		IF(FLAG) THEN
		    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K)) 
		    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
		    CALL VEC_CURL1(V1,V2,TEMPVEC)
		    TEMPVEC = TEMPVEC/SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
            INNER1 = DOT_PRODUCT(TEMPVEC,MODEL_AXIS_EQN(1:3,1))
            INNER2 = DOT_PRODUCT(TEMPVEC,MODEL_AXIS_EQN(1:3,2))
            IF(INNER1>=INNER2) THEN
			    DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),MODEL_AXIS_EQN(1:3,1))*MODEL_AXIS_EQN(1:3,1)
			    DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))                
            ELSE
			    DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),MODEL_AXIS_EQN(1:3,2))*MODEL_AXIS_EQN(1:3,2)
			    DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))                  
            END IF 
		END IF

ELSE IF(SURFACE_CURRENT%POINT_TYPE(I)==4) THEN 

            RIDGE_NUM = 0
            NEIGHBOR_RIDGE_POINT(:,1) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
            NEIGHBOR_RIDGE_POINT(:,2) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
        
            DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
                
                DO K=1,3
                    IF(SURFACE_CURRENT%SURFACE_FACES(K,FACE_IDX)==I) THEN
                        EXIT
                    END IF
                END DO
                
                IF(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K,FACE_IDX) .NE. 0) THEN
                    RIDGE_NUM = RIDGE_NUM + 1
                    NEIGHBOR_RIDGE_POINT(:,RIDGE_NUM) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,FACE_IDX))
                END IF
                
                IF(RIDGE_NUM == 2) THEN
		    EXIT
		END IF
            END DO

            IF(RIDGE_NUM < 2) THEN
                WRITE(*,*) 'END OF THE RIDGE FOUND'
                WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,1)
                WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,2)
                WRITE(*,*) 'INDICES : ', I, J
            END IF

            V1 = NEIGHBOR_RIDGE_POINT(:,1) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
            L1 = SQRT(DOT_PRODUCT(V1,V1))
            V2 = -(NEIGHBOR_RIDGE_POINT(:,2) - SURFACE_CURRENT%SURFACE_POINTS(:,I))
            L2 = SQRT(DOT_PRODUCT(V2,V2))        

            V = L1*V1 + L2*V2
            V = V/SQRT(DOT_PRODUCT(V,V))

            RELATED_FACE = SURFACE_CURRENT%POINT_RELATEDFACE(2+1,I)
            CENTER1 = (SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE))+SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,RELATED_FACE))+SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,RELATED_FACE)))/3.
            V1 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,RELATED_FACE)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE)) 
            V2 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,RELATED_FACE)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE))
            CALL VEC_CURL1(V1,V2,RELATED_NORMAL)
            RELATED_NORMAL = RELATED_NORMAL/SQRT(DOT_PRODUCT(RELATED_NORMAL,RELATED_NORMAL))


            DIST = 100
            B0 = .FALSE.

            DO J = 1, 3
                VERTEX = SURFACE_CASE%SURFACE_FACES(J,RELATED_FACE)
                NUM = SURFACE_CASE%POINT_FACE_CONNECTION_NUM(VERTEX)
                DO L = 1, NUM
                    K = SURFACE_CASE%POINT_FACE_CONNECTION(L,VERTEX)
                    CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CURRENT%SURFACE_POINTS(:,I), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K)), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,K)), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,K)), TEMP_DIST)	

                    W1 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,K)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K))  
                    W2 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,K)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K)) 
                    CALL VEC_CURL1(W1,W2,TEMP_NEIGHBOR_NORMAL)
                    TEMP_NEIGHBOR_NORMAL = TEMP_NEIGHBOR_NORMAL/SQRT(DOT_PRODUCT(TEMP_NEIGHBOR_NORMAL,TEMP_NEIGHBOR_NORMAL))
                    CRI = SQRT(MAX(0.,1.-DOT_PRODUCT(RELATED_NORMAL,TEMP_NEIGHBOR_NORMAL)*DOT_PRODUCT(RELATED_NORMAL,TEMP_NEIGHBOR_NORMAL)))

                    IF(K/=RELATED_FACE .AND. TEMP_DIST<DIST .AND. CRI>0.5 .AND. SURFACE_CASE%FACE_ONINTERFACE(K) .NE. -1 ) THEN
                        B0 = .TRUE.
                        DIST = TEMP_DIST
                        NEIGHBOR_NORMAL = TEMP_NEIGHBOR_NORMAL	
                        NEIGHBOR_INDEX = K

                        CENTER2 = (SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K))+SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,K))+SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,K)))/3.
                    END IF 

                END DO
            END DO

            CALL VEC_CURL1(RELATED_NORMAL,V,DIR1)
            DIR1 = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))

            IF(B0) THEN
                CALL VEC_CURL1(NEIGHBOR_NORMAL,V,DIR2)
                IF(DOT_PRODUCT(DIR2,DIR2)<MINERROR) THEN
                    WRITE(*,*) 'PARALLEL PLANES APPEAR WHEN FLUID PT TYP==4, DIR2'
                    WRITE(*,*) 'INDEX :', I
                    WRITE(*,*) 'NEIGHBOR_INDEX :', NEIGHBOR_INDEX
                END IF
            END IF
            IF(DOT_PRODUCT(DIR1,DIR1)<MINERROR) THEN
                WRITE(*,*) 'PARALLEL PLANES APPEAR WHEN FLUID PT TYP==4, DIR1'
                WRITE(*,*) 'INDEX :', I
                WRITE(*,*) 'NEIGHBOR_INDEX :', NEIGHBOR_INDEX
            ELSE
                IF(B0) THEN
                    IF(DOT_PRODUCT(CENTER1-SURFACE_CURRENT%SURFACE_POINTS(:,I),DIR1)<0) THEN
                        DIR1 = -DIR1
                    END IF
                    DIR2 = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))
                    IF(DOT_PRODUCT(CENTER2-SURFACE_CURRENT%SURFACE_POINTS(:,I),DIR2)<0) THEN
                        DIR2 = -DIR2
                    END IF
                    
                    NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                    DO L = 1, NUM
                        K = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,I)
                        IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==1) THEN
                            W1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                            W2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                            CALL VEC_CURL1(W1,W2,TEMP_NORMAL)  
                            INNER1 = DOT_PRODUCT(TEMP_NORMAL,DIR1)
                            INNER2 = DOT_PRODUCT(TEMP_NORMAL,DIR2)
                            IF(INNER1>0. .AND. INNER1>=INNER2) THEN
                                DIR = DIR1
                                EXIT
                            ELSE IF(INNER2>0. .AND. INNER2>=INNER1) THEN
                                DIR = DIR2
                                EXIT
                            ELSE
                                WRITE(*,*) 'ERROR : UNEXPECTED DIRECTION IN WAVEFRONT PT_TYP==4,5'
                                WRITE(*,*) DIR1
                                WRITE(*,*) DIR2
                                WRITE(*,*) TEMP_NORMAL
                                WRITE(*,*) I, K
                            END IF
                        END IF
                    END DO
                    DISPLACEMENT(:,I) = DIR
                ELSE
                    DIR2 = -DIR1
                    NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                    DO L = 1, NUM
                        K = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,I)
                        IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==1) THEN
                            W1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                            W2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                            CALL VEC_CURL1(W1,W2,TEMP_NORMAL)  
                            INNER1 = DOT_PRODUCT(TEMP_NORMAL,DIR1)
                            INNER2 = DOT_PRODUCT(TEMP_NORMAL,DIR2)
                            IF(INNER1>0. .AND. INNER1>=INNER2) THEN
                                DIR = DIR1
                                EXIT
                            ELSE IF(INNER2>0. .AND. INNER2>=INNER1) THEN
                                DIR = DIR2
                                EXIT
                            ELSE
                                WRITE(*,*) 'ERROR : UNEXPECTED DIRECTION IN WAVEFRONT PT_TYP==4,5'
                                WRITE(*,*) DIR1
                                WRITE(*,*) DIR2
                                WRITE(*,*) TEMP_NORMAL
                                WRITE(*,*) I, K
                            END IF
                        END IF
                    END DO
                    DISPLACEMENT(:,I) = DIR
                END IF         

            END IF

ELSE IF(SURFACE_CURRENT%POINT_TYPE(I)==6) THEN

        RELATED_FACE = SURFACE_CURRENT%POINT_RELATEDFACE(2+1,I)
        B1 = .FALSE.       
        DO L = 1, 3
            POINT_IDX = SURFACE_CASE%SURFACE_FACES(L,RELATED_FACE)
            IF(SQRT(DOT_PRODUCT(SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX)-SURFACE_CURRENT%SURFACE_POINTS(:,I),SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX)-SURFACE_CURRENT%SURFACE_POINTS(:,I)))<SURFACE_FLUID%MESH_SIZE/5.) THEN
                IDX = L
                B1 = .TRUE.
                EXIT
            END IF
        END DO

		J1 = SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE)
		J2 = SURFACE_CASE%SURFACE_FACES(2,RELATED_FACE)
		J3 = SURFACE_CASE%SURFACE_FACES(3,RELATED_FACE)

        RIDGE_NUM = 0
        DO L = 1,3
            IF(SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(L,RELATED_FACE)>0) THEN
                RIDGE_NUM = RIDGE_NUM + 1
            END IF
        END DO
        
		N1 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(1,RELATED_FACE)
		N2 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(2,RELATED_FACE)
		N3 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(3,RELATED_FACE)

	IF(.NOT. B1 .AND. RIDGE_NUM == 1) THEN
            IF(N1 .GE. 1) THEN
                POINT_IDX1 = J1
                POINT_IDX2 = J2
            ELSE IF(N2 .GE. 1) THEN
                POINT_IDX1 = J2
                POINT_IDX2 = J3                
            ELSE
                POINT_IDX1 = J3
                POINT_IDX2 = J1                 
            END IF
            
		        DIR1 = SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX1) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                DIR2 = SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX2) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                
                DIR1 = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))
                DIR2 = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))
                
                NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                TEMP_NORMAL2 = 0.
                DO L = 1, NUM
                    K = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,I)
                    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==1) THEN
                        W1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                        W2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                        CALL VEC_CURL1(W1,W2,TEMP_NORMAL)  
                        TEMP_NORMAL2 = TEMP_NORMAL2 + TEMP_NORMAL                        
                    END IF
                END DO
                TEMP_NORMAL2 = TEMP_NORMAL2/SQRT(DOT_PRODUCT(TEMP_NORMAL2,TEMP_NORMAL2))
                
                INNER1 = DOT_PRODUCT(TEMP_NORMAL2,DIR1)
                INNER2 = DOT_PRODUCT(TEMP_NORMAL2,DIR2)
                
                IF(INNER1>0. .AND. INNER1>=INNER2) THEN
                    DIR = DIR1
                ELSE IF(INNER2>0. .AND. INNER2>=INNER1) THEN
                    DIR = DIR2
                ELSE
                    WRITE(*,*) 'ERROR : UNEXPECTED DIRECTION IN WAVEFRONT PT_TYP==6'
                    WRITE(*,*) DIR1
                    WRITE(*,*) DIR2
                    WRITE(*,*) TEMP_NORMAL2
                    WRITE(*,*) I, K
                END IF
                DISPLACEMENT(:,I) = DIR
                
        ELSEIF(.NOT. B1 .AND. RIDGE_NUM == 2) THEN
            IF(N1 .GE. 1 .AND. N2 .GE. 1) THEN
                POINT_IDX1 = J1
                POINT_IDX2 = J2
                POINT_IDX3 = J3
            ELSE IF(N2 .GE. 1 .AND. N3 .GE. 1) THEN
                POINT_IDX1 = J2
                POINT_IDX2 = J3  
                POINT_IDX3 = J1
            ELSE
                POINT_IDX1 = J3
                POINT_IDX2 = J1  
                POINT_IDX3 = J2 
            END IF
            
		    DIR1 = SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX1) - SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX2)
            DIR2 = SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX3) - SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX2)
            
            DIR1 = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))
            DIR2 = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))
     
            TEMPVEC = SURFACE_CURRENT%SURFACE_POINTS(:,I) - SURFACE_CASE%SURFACE_POINTS(:,POINT_IDX2)
            TEMPVEC = TEMPVEC/SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
            
            INNER1 = DOT_PRODUCT(TEMPVEC, DIR1)
            INNER2 = DOT_PRODUCT(TEMPVEC, DIR2)
                
            IF(INNER1>=INNER2) THEN
                DIR2 = -DIR1
            ELSE
                DIR1 = -DIR2
            END IF

            NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            TEMP_NORMAL2 = 0.
            DO L = 1, NUM
                K = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,I)
                IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==1) THEN
                    W1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                    W2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                    CALL VEC_CURL1(W1,W2,TEMP_NORMAL)  
                    TEMP_NORMAL2 = TEMP_NORMAL2 + TEMP_NORMAL                        
                END IF
            END DO
            TEMP_NORMAL2 = TEMP_NORMAL2/SQRT(DOT_PRODUCT(TEMP_NORMAL2,TEMP_NORMAL2))

            INNER1 = DOT_PRODUCT(TEMP_NORMAL2,DIR1)
            INNER2 = DOT_PRODUCT(TEMP_NORMAL2,DIR2)

            IF(INNER1>0. .AND. INNER1>=INNER2) THEN
                DIR = DIR1
            ELSE IF(INNER2>0. .AND. INNER2>=INNER1) THEN
                DIR = DIR2
            ELSE
                WRITE(*,*) 'ERROR : UNEXPECTED DIRECTION IN WAVEFRONT PT_TYP==6'
                WRITE(*,*) DIR1
                WRITE(*,*) DIR2
                WRITE(*,*) TEMP_NORMAL2
                WRITE(*,*) I, K
            END IF
            DISPLACEMENT(:,I) = DIR

        ELSEIF(B1) THEN
            
            POINT_IDX1 = SURFACE_CASE%SURFACE_FACES(IDX,RELATED_FACE)
            NUM = 0           
            DO J = 1, SURFACE_CASE%POINT_FACE_CONNECTION_NUM(POINT_IDX1)     
                K = SURFACE_CASE%POINT_FACE_CONNECTION(J,POINT_IDX1)
		    IF(SURFACE_CASE%FACE_ONINTERFACE(K) == -1)  THEN
		        B5 = .TRUE.
		        EXIT
		    END IF
	        END DO

	        IF(B5) THEN
                FLAG = .FALSE.
                DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
                    FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)                
                    DO K=1,3
                        IF(SURFACE_CURRENT%SURFACE_FACES(K,FACE_IDX)==I) THEN
                            POINT_IDX2 = SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,FACE_IDX)
                            IF(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K,FACE_IDX) .NE. 0 .AND. SURFACE_CURRENT%POINT_TYPE(POINT_IDX2)==4) THEN
                                FLAG = .TRUE.   
                                EXIT
                            END IF
                        END IF
                    END DO 
                    IF(FLAG) EXIT
                END DO
            END IF
	    
            IF(.NOT. FLAG) THEN
                WRITE(*,*) 'WAVEFRONT : TYP==6 HAS NO NEIGHBOR POINT TYP==4'
            END IF
            
            RIDGE_NUM = 0
            NEIGHBOR_RIDGE_POINT(:,1) = SURFACE_CURRENT%SURFACE_POINTS(:,POINT_IDX2)
            NEIGHBOR_RIDGE_POINT(:,2) = SURFACE_CURRENT%SURFACE_POINTS(:,POINT_IDX2)
        
            DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(POINT_IDX2)
                FACE_IDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,POINT_IDX2)
                
                DO K=1,3
                    IF(SURFACE_CURRENT%SURFACE_FACES(K,FACE_IDX)==POINT_IDX2) THEN
                        EXIT
                    END IF
                END DO
                
                IF(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K,FACE_IDX) .NE. 0) THEN
                    RIDGE_NUM = RIDGE_NUM + 1
                    NEIGHBOR_RIDGE_POINT(:,RIDGE_NUM) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,FACE_IDX))
                END IF
                
                IF(RIDGE_NUM == 2) EXIT
            END DO

            IF(RIDGE_NUM < 2) THEN
                WRITE(*,*) 'END OF THE RIDGE FOUND IN WAVEFRONT TYP==4'
                WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,1)
                WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,2)
                WRITE(*,*) 'INDICES : ', POINT_IDX2
            END IF           

            V1 = NEIGHBOR_RIDGE_POINT(:,1) - SURFACE_CURRENT%SURFACE_POINTS(:,POINT_IDX2)
            L1 = SQRT(DOT_PRODUCT(V1,V1))
            V2 = -(NEIGHBOR_RIDGE_POINT(:,2) - SURFACE_CURRENT%SURFACE_POINTS(:,POINT_IDX2))
            L2 = SQRT(DOT_PRODUCT(V2,V2))        

            V = L1*V1 + L2*V2
            V = V/SQRT(DOT_PRODUCT(V,V))

            RELATED_FACE = SURFACE_CURRENT%POINT_RELATEDFACE(2+1,POINT_IDX2)
            CENTER1 = (SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE))+SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,RELATED_FACE))+SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,RELATED_FACE)))/3.
            V1 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,RELATED_FACE)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE)) 
            V2 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,RELATED_FACE)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,RELATED_FACE))
            CALL VEC_CURL1(V1,V2,RELATED_NORMAL)
            RELATED_NORMAL = RELATED_NORMAL/SQRT(DOT_PRODUCT(RELATED_NORMAL,RELATED_NORMAL))


            DIST = 100
            B0 = .FALSE.

            DO J = 1, 3
                VERTEX = SURFACE_CASE%SURFACE_FACES(J,RELATED_FACE)
                NUM = SURFACE_CASE%POINT_FACE_CONNECTION_NUM(VERTEX)
                DO L = 1, NUM
                    K = SURFACE_CASE%POINT_FACE_CONNECTION(L,VERTEX)
                    CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CURRENT%SURFACE_POINTS(:,POINT_IDX2), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K)), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,K)), SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,K)), TEMP_DIST)	

                    W1 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,K)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K))  
                    W2 = SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,K)) - SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K)) 
                    CALL VEC_CURL1(W1,W2,TEMP_NEIGHBOR_NORMAL)
                    TEMP_NEIGHBOR_NORMAL = TEMP_NEIGHBOR_NORMAL/SQRT(DOT_PRODUCT(TEMP_NEIGHBOR_NORMAL,TEMP_NEIGHBOR_NORMAL))
                    CRI = SQRT(MAX(0.,1.-DOT_PRODUCT(RELATED_NORMAL,TEMP_NEIGHBOR_NORMAL)*DOT_PRODUCT(RELATED_NORMAL,TEMP_NEIGHBOR_NORMAL)))

                    IF(K/=RELATED_FACE .AND. TEMP_DIST<DIST .AND. CRI>0.5 .AND. SURFACE_CASE%FACE_ONINTERFACE(K) .NE. -1 ) THEN
                        B0 = .TRUE.
                        DIST = TEMP_DIST
                        NEIGHBOR_NORMAL = TEMP_NEIGHBOR_NORMAL	
                        NEIGHBOR_INDEX = K

                        CENTER2 = (SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(1,K))+SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(2,K))+SURFACE_CASE%SURFACE_POINTS(:,SURFACE_CASE%SURFACE_FACES(3,K)))/3.
                    END IF 

                END DO
            END DO

            CALL VEC_CURL1(RELATED_NORMAL,V,DIR1)
            DIR1 = DIR1/SQRT(DOT_PRODUCT(DIR1,DIR1))

            IF(B0) THEN
                CALL VEC_CURL1(NEIGHBOR_NORMAL,V,DIR2)
                IF(DOT_PRODUCT(DIR2,DIR2)<MINERROR) THEN
                    WRITE(*,*) 'PARALLEL PLANES APPEAR WHEN FLUID PT TYP==4, DIR2'
                    WRITE(*,*) 'INDEX :', I
                    WRITE(*,*) 'NEIGHBOR_INDEX :', NEIGHBOR_INDEX
                END IF
            END IF
            IF(DOT_PRODUCT(DIR1,DIR1)<MINERROR) THEN
                WRITE(*,*) 'PARALLEL PLANES APPEAR WHEN FLUID PT TYP==4, DIR1'
                WRITE(*,*) 'INDEX :', I
                WRITE(*,*) 'NEIGHBOR_INDEX :', NEIGHBOR_INDEX
            ELSE
                IF(B0) THEN
                    IF(DOT_PRODUCT(CENTER1-SURFACE_CURRENT%SURFACE_POINTS(:,POINT_IDX2),DIR1)<0) THEN
                        DIR1 = -DIR1
                    END IF
                    DIR2 = DIR2/SQRT(DOT_PRODUCT(DIR2,DIR2))
                    IF(DOT_PRODUCT(CENTER2-SURFACE_CURRENT%SURFACE_POINTS(:,POINT_IDX2),DIR2)<0) THEN
                        DIR2 = -DIR2
                    END IF
                    
                    NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(POINT_IDX2)
                    DO L = 1, NUM
                        K = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,POINT_IDX2)
                        IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==1) THEN
                            W1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                            W2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                            CALL VEC_CURL1(W1,W2,TEMP_NORMAL)  
                            INNER1 = DOT_PRODUCT(TEMP_NORMAL,DIR1)
                            INNER2 = DOT_PRODUCT(TEMP_NORMAL,DIR2)
                            IF(INNER1>0. .AND. INNER1>=INNER2) THEN
                                DIR = DIR1
                                EXIT
                            ELSE IF(INNER2>0. .AND. INNER2>=INNER1) THEN
                                DIR = DIR2
                                EXIT
                            ELSE
                                WRITE(*,*) 'ERROR : UNEXPECTED DIRECTION IN WAVEFRONT PT_TYP==6'
                                WRITE(*,*) DIR1
                                WRITE(*,*) DIR2
                                WRITE(*,*) TEMP_NORMAL
                                WRITE(*,*) POINT_IDX2, K
                            END IF
                        END IF
                    END DO
                    DISPLACEMENT(:,POINT_IDX2) = DIR
                ELSE
                    DIR2 = -DIR1
                    NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(POINT_IDX2)
                    DO L = 1, NUM
                        K = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,POINT_IDX2)
                        IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==1) THEN
                            W1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                            W2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
                            CALL VEC_CURL1(W1,W2,TEMP_NORMAL)  
                            INNER1 = DOT_PRODUCT(TEMP_NORMAL,DIR1)
                            INNER2 = DOT_PRODUCT(TEMP_NORMAL,DIR2)
                            IF(INNER1>0. .AND. INNER1>=INNER2) THEN
                                DIR = DIR1
                                EXIT
                            ELSE IF(INNER2>0. .AND. INNER2>=INNER1) THEN
                                DIR = DIR2
                                EXIT
                            ELSE
                                WRITE(*,*) 'ERROR : UNEXPECTED DIRECTION IN WAVEFRONT PT_TYP==6'
                                WRITE(*,*) DIR1
                                WRITE(*,*) DIR2
                                WRITE(*,*) TEMP_NORMAL
                                WRITE(*,*) POINT_IDX2, K
                            END IF
                        END IF
                    END DO
                    DISPLACEMENT(:,POINT_IDX2) = DIR
                END IF         

            END IF
        ELSE
            IF(RIDGE_NUM ==3) THEN
                WRITE(*,*) 'OOPS, RIDGE_NUM ==3 IN WAVEFRONT TYP==5'
            ELSE IF(RIDGE_NUM==0) THEN
  
		        DIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
		        DIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
        
		        J = SURFACE_CURRENT%POINT_RELATEDFACE(2+1,I)       
	            ALLOCATE(RIDGE_EDGE(2,100))  
                ALLOCATE(POINT_USED(SURFACE_CASE%SURFACE_POINTS_NUM))
                POINT_USED = .FALSE.
		        RIDGE_EDGE_NUM = 0
		        DO L= 1,3
		            I0 = SURFACE_CASE%SURFACE_FACES(L,J)
		            NUM = SURFACE_CASE%POINT_FACE_CONNECTION_NUM(I0)
			            DO M= 1,NUM
			    	        FACE_INDEX = SURFACE_CASE%POINT_FACE_CONNECTION(M,I0)
				            J1 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(1,FACE_INDEX)
				            J2 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(2,FACE_INDEX)
				            J3 = SURFACE_CASE%FACE_DIVIDED_BOUNDARY_ARRAY(3,FACE_INDEX)
				        IF(J1>0) THEN
                            IF(POINT_USED(SURFACE_CASE%SURFACE_FACES(1,FACE_INDEX))==.FALSE. .OR.  POINT_USED(SURFACE_CASE%SURFACE_FACES(2,FACE_INDEX))==.FALSE.) THEN
				                RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                                POINT_USED(SURFACE_CASE%SURFACE_FACES(1,FACE_INDEX))=.TRUE.
                                POINT_USED(SURFACE_CASE%SURFACE_FACES(2,FACE_INDEX))=.TRUE.
				                RIDGE_EDGE(1,RIDGE_EDGE_NUM) = SURFACE_CASE%SURFACE_FACES(1,FACE_INDEX)
				                RIDGE_EDGE(2,RIDGE_EDGE_NUM) = SURFACE_CASE%SURFACE_FACES(2,FACE_INDEX)
                            END IF
				        END IF
				        IF(J2>0) THEN
                            IF(POINT_USED(SURFACE_CASE%SURFACE_FACES(2,FACE_INDEX))==.FALSE. .OR.  POINT_USED(SURFACE_CASE%SURFACE_FACES(3,FACE_INDEX))==.FALSE.) THEN
				                RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                                POINT_USED(SURFACE_CASE%SURFACE_FACES(2,FACE_INDEX))=.TRUE.
                                POINT_USED(SURFACE_CASE%SURFACE_FACES(3,FACE_INDEX))=.TRUE.
				                RIDGE_EDGE(1,RIDGE_EDGE_NUM) = SURFACE_CASE%SURFACE_FACES(2,FACE_INDEX)
				                RIDGE_EDGE(2,RIDGE_EDGE_NUM) = SURFACE_CASE%SURFACE_FACES(3,FACE_INDEX)
                            END IF
				        END IF
				        IF(J3>0) THEN
                            IF(POINT_USED(SURFACE_CASE%SURFACE_FACES(3,FACE_INDEX))==.FALSE. .OR.  POINT_USED(SURFACE_CASE%SURFACE_FACES(1,FACE_INDEX))==.FALSE.) THEN
				                RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                                POINT_USED(SURFACE_CASE%SURFACE_FACES(3,FACE_INDEX))=.TRUE.
                                POINT_USED(SURFACE_CASE%SURFACE_FACES(1,FACE_INDEX))=.TRUE.
				                RIDGE_EDGE(1,RIDGE_EDGE_NUM) = SURFACE_CASE%SURFACE_FACES(3,FACE_INDEX)
				                RIDGE_EDGE(2,RIDGE_EDGE_NUM) = SURFACE_CASE%SURFACE_FACES(1,FACE_INDEX)
                            END IF
				        END IF
			            END DO
		            END DO

	                IF(RIDGE_EDGE_NUM==0) THEN
		                WRITE(*,*) 'ERROR : RIDGE_EDGE_NUM == 0, WHEN ATTEMPT TO PROJECTION ONTO RIDGES FOR WAVEFRONT TYP==5'
                    ELSE
                
			        DIST = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))            
            		TEMPDIST = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))
            
			        DO L=1,RIDGE_EDGE_NUM
			            J4 = RIDGE_EDGE(1,L)
			            J5 = RIDGE_EDGE(2,L)
			            CALL UNSIGNED_DISTANCE_EDGE_POINT(SURFACE_CURRENT%SURFACE_POINTS(:,I),SURFACE_CASE%SURFACE_POINTS(:,J4),SURFACE_CASE%SURFACE_POINTS(:,J5),TEMPDIST)
			            IF(TEMPDIST<DIST) THEN
				        DIST = TEMPDIST
				        IDX = L
                        END IF
                        IF(TEMPDIST<MINERROR) THEN
                            RIDGE_EDGE_NUM = 1
                            RIDGE_EDGE = 0
                            RIDGE_EDGE(1,1) = J4
                            RIDGE_EDGE(2,1) = J5
                            EXIT
                        END IF
                    END DO
                    
			        J6 = RIDGE_EDGE(1,IDX)
			        J7 = RIDGE_EDGE(2,IDX)
        
			        DIST1 = SQRT(DOT_PRODUCT(SURFACE_CURRENT%SURFACE_POINTS(:,I)-SURFACE_CASE%SURFACE_POINTS(:,J6),SURFACE_CURRENT%SURFACE_POINTS(:,I)-SURFACE_CASE%SURFACE_POINTS(:,J6)))
			        DIST2 = SQRT(DOT_PRODUCT(SURFACE_CURRENT%SURFACE_POINTS(:,I)-SURFACE_CASE%SURFACE_POINTS(:,J7),SURFACE_CURRENT%SURFACE_POINTS(:,I)-SURFACE_CASE%SURFACE_POINTS(:,J7)))
            
			        IF(DIST1 < DIST2) THEN
			            A1 = SURFACE_CASE%SURFACE_POINTS(:,J6)
			            A2 = SURFACE_CASE%SURFACE_POINTS(:,J7)
			    
			            POINTDIST = DIST1
			        ELSE
			            A1 = SURFACE_CASE%SURFACE_POINTS(:,J7)
			            A2 = SURFACE_CASE%SURFACE_POINTS(:,J6)
			    
			            POINTDIST = DIST2
			        END IF
        
      			        INNER = DOT_PRODUCT(A1-SURFACE_CURRENT%SURFACE_POINTS(:,I),A2-A1)
			        T = A2-A1
			        R = SQRT(DOT_PRODUCT(T,T))
			        T = T/R
			        INNER2 = DOT_PRODUCT(SURFACE_CURRENT%SURFACE_POINTS(:,I)-A1,T)
        
			        DISPLACEMENT(:,I) = A1 + INNER2*T - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                    DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))
                    END IF
                    
		            DEALLOCATE(RIDGE_EDGE) 	
                    DEALLOCATE(POINT_USED)

                ELSE
                    WRITE(*,*) 'UNEXPECTED CASE FOR WAVEFRONT TYP==6'
                END IF

        END IF
            
	ELSE
		DO J = 1,LOCAL_SHAPE
                    DISPLACEMENT(:,I) = DISPLACEMENT(:,I) + DOT_PRODUCT(E_VECTOR(:,J),B(:))/E_VALUE(J) * E_VECTOR(:,J)
		END DO
	END IF

	IF(SURFACE_CURRENT%POINT_TYPE(I) .LE. 4) THEN
		FLAG = .FALSE.
	        DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
		    K = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(K)==-1) THEN
			FLAG = .TRUE.
			EXIT
		    END IF
	        END DO

		IF(FLAG) THEN
		    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K)) 
		    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,K)) - SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,K))
		    CALL VEC_CURL1(V1,V2,TEMPVEC)
		    TEMPVEC = TEMPVEC/SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
            	    INNER1 = DOT_PRODUCT(TEMPVEC,MODEL_AXIS_EQN(1:3,1))
            	    INNER2 = DOT_PRODUCT(TEMPVEC,MODEL_AXIS_EQN(1:3,2))
		    IF(INNER1>=INNER2) THEN
		        DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),MODEL_AXIS_EQN(1:3,1))*MODEL_AXIS_EQN(1:3,1)
		        DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))                
		    ELSE
		        DISPLACEMENT(:,I) = DISPLACEMENT(:,I) - DOT_PRODUCT(DISPLACEMENT(:,I),MODEL_AXIS_EQN(1:3,2))*MODEL_AXIS_EQN(1:3,2)
		        DISPLACEMENT(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))                  
		    END IF 
		END IF
	END IF

            DEALLOCATE(N)
            DEALLOCATE(A)
            DEALLOCATE(W)
            
        END DO
	!$OMP END PARALLEL DO

	!$OMP PARALLEL DO        
        DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))>0) THEN
                SURFACE_CURRENT%POINT_FORCE(:,I) = DISPLACEMENT(:,I)/SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))
            ELSE
                SURFACE_CURRENT%POINT_FORCE(:,I) = 0.
            END IF
        END DO
	!$OMP END PARALLEL DO
        
        ALLOCATE(TEMPPOINT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
	!$OMP PARALLEL DO  
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            TEMPPOINT(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)
        END DO
	!$OMP END PARALLEL DO
        
        ALLOCATE(LENGTH(SURFACE_CURRENT%SURFACE_POINTS_NUM))
        LENGTH(:) = 0.
        
        ALLOCATE(FACE_CENTER(3,SURFACE_CURRENT%SURFACE_FACES_NUM))

	!$OMP PARALLEL DO        
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            
            I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
            I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
            I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)
            
            ! Should modify for square case
            
            !FACE_CENTER(:,I) = (TEMPPOINT(:,I1) + TEMPPOINT(:,I2) + TEMPPOINT(:,I3))/3.
            FACE_CENTER(:,I) = (SURFACE_CURRENT%SURFACE_POINTS(:,I1) + SURFACE_CURRENT%SURFACE_POINTS(:,I2) + SURFACE_CURRENT%SURFACE_POINTS(:,I3))/3.
            
        END DO
	!$OMP END PARALLEL DO

	DISPLACEMENT_THRESHOLD1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
	DISPLACEMENT_THRESHOLD2 = 0.
	ALLOCATE(DISPLACEMENT_THRESHOLD(SURFACE_CURRENT%SURFACE_POINTS_NUM))
	DISPLACEMENT_THRESHOLD = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
	ALLOCATE(POINT_USED(SURFACE_CURRENT%SURFACE_POINTS_NUM))

	!$OMP PARALLEL DO        
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM

	    POINT_USED = .FALSE.
	    EDGE_LENGTH = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))

            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))<MINERROR) THEN
                LENGTH(I) = 0.
            ELSE
                CON_NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)

                ALLOCATE(A(CON_NUM))
                ALLOCATE(W(CON_NUM))
                ALLOCATE(MU(CON_NUM))
                ALLOCATE(LL(CON_NUM))
                ALLOCATE(COSTHETA(CON_NUM))
                
                MU_SUM = 0.
                
                DO J = 1,CON_NUM
                    W(J) = FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                    A(J) = TIMESTEP * SURFACE_CURRENT%FACE_B_RATE(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
                    COSTHETA(J) = DOT_PRODUCT(DISPLACEMENT(:,I), NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))) &
                    /SQRT( DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)) * DOT_PRODUCT(NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)),NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))) )
		    DO K = 1,3
			FACE_INDEX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
			DO L = 1,3
			    IF(SURFACE_CURRENT%SURFACE_FACES(L,FACE_INDEX)==I) EXIT
			END DO
			IF(L==1) THEN
			    I1 = SURFACE_CURRENT%SURFACE_FACES(2,FACE_INDEX)
			    I2 = SURFACE_CURRENT%SURFACE_FACES(3,FACE_INDEX)
			ELSE IF(L==2) THEN
			    I1 = SURFACE_CURRENT%SURFACE_FACES(3,FACE_INDEX)
			    I2 = SURFACE_CURRENT%SURFACE_FACES(1,FACE_INDEX)
			ELSE
			    I1 = SURFACE_CURRENT%SURFACE_FACES(1,FACE_INDEX)
			    I2 = SURFACE_CURRENT%SURFACE_FACES(2,FACE_INDEX)
			END IF
			IF(.NOT. POINT_USED(I1)) THEN
			    POINT_USED(I1) = .TRUE.
                            EDGE_LENGTH = MIN(EDGE_LENGTH,SQRT(DOT_PRODUCT(SURFACE_CURRENT%SURFACE_POINTS(:,I1)-SURFACE_CURRENT%SURFACE_POINTS(:,I),SURFACE_CURRENT%SURFACE_POINTS(:,I1)-SURFACE_CURRENT%SURFACE_POINTS(:,I))))
			END IF
			IF(.NOT. POINT_USED(I2)) THEN
			    POINT_USED(I2) = .TRUE.
                            EDGE_LENGTH = MIN(EDGE_LENGTH,SQRT(DOT_PRODUCT(SURFACE_CURRENT%SURFACE_POINTS(:,I2)-SURFACE_CURRENT%SURFACE_POINTS(:,I),SURFACE_CURRENT%SURFACE_POINTS(:,I2)-SURFACE_CURRENT%SURFACE_POINTS(:,I))))
			END IF
                    END DO                    
                    
                    ! HOW TO EXPANDING?
                    !D(:) = FACE_CENTER(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) - TEMPPOINT(:,I)
                    D(:) = FACE_CENTER(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) - SURFACE_CURRENT%SURFACE_POINTS(:,I)
                    
                    IF(DOT_PRODUCT(DISPLACEMENT(:,I),D)<0) THEN
                        EXPANDING = .TRUE.
                    ELSE
                        EXPANDING = .FALSE.
                    END IF
                    
                    IF(EXPANDING) THEN
                        MU(J) = W(J)
                        LL(J) = A(J)
                    ELSE
                        MU(J) = W(J) * (COSTHETA(J))**2
                        
                        IF(ABS(MU(J))<MINERROR .OR. 1./ABS(COSTHETA(J)) > 20.) THEN
                            LL(J) = 0.
                        ELSE
                            LL(J) = A(J) / ABS(COSTHETA(J))
                        END IF
                    END IF
                    
                    IF(ABS(LL(J))>=MINERROR) THEN
                        MU_SUM = MU_SUM + MU(J)
                        LENGTH(I) = LENGTH(I) + MU(J)*LL(J)
			DISPLACEMENT_THRESHOLD2 = MAX(DISPLACEMENT_THRESHOLD2,LL(J))
                    END IF
                
                END DO
                
		DISPLACEMENT_THRESHOLD1 = EDGE_LENGTH/2.
		DISPLACEMENT_THRESHOLD(I) = MIN(DISPLACEMENT_THRESHOLD1,DISPLACEMENT_THRESHOLD2)                
                IF(ABS(LENGTH(I))>=MINERROR) THEN
                    LENGTH(I) = LENGTH(I) / MU_SUM
                END IF
                
                DEALLOCATE(A)
                DEALLOCATE(W)
                DEALLOCATE(MU)
                DEALLOCATE(LL)
                DEALLOCATE(COSTHETA)
            END IF
        END DO 
	!$OMP END PARALLEL DO
	!$OMP PARALLEL DO
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM 
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))>=MINERROR) DISPLACEMENT(:,I) = LENGTH(I) * DISPLACEMENT(:,I) / SQRT(DOT_PRODUCT(DISPLACEMENT(:,I), DISPLACEMENT(:,I)))  
        END DO
	!$OMP END PARALLEL DO

        RESULT_TIMESTEP = TIMESTEP
	!$OMP PARALLEL DO
        DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
            R = 0.
            IF(SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))>=MINERROR) THEN
                R = SQRT(DOT_PRODUCT(DISPLACEMENT(:,I),DISPLACEMENT(:,I)))/TIMESTEP
                IF(RESULT_TIMESTEP > DISPLACEMENT_THRESHOLD(I)/R + MINERROR) THEN
                    RESULT_TIMESTEP = DISPLACEMENT_THRESHOLD(I)/R
                END IF
            END IF
        END DO
	!$OMP END PARALLEL DO
write(*,*) 'RESULT_TIMESTEP :', result_timestep
	!$OMP PARALLEL DO
        DO I = 1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            SURFACE_CURRENT%SURFACE_POINTS(:,I) = SURFACE_CURRENT%SURFACE_POINTS(:,I) + DISPLACEMENT(:,I)/TIMESTEP * RESULT_TIMESTEP
        END DO
	!$OMP END PARALLEL DO

        DEALLOCATE(LENGTH)
        DEALLOCATE(FACE_CENTER)
        
        DEALLOCATE(TEMPPOINT)
        
        DEALLOCATE(NORMAL)
        DEALLOCATE(FACE_AREA)
        
        DEALLOCATE(DISPLACEMENT)
	DEALLOCATE(DISPLACEMENT_THRESHOLD)
	DEALLOCATE(POINT_USED)
        
    END SUBROUTINE WAVEFRONT_DISPLACEMENT    
    
    SUBROUTINE GEOMETRIC_FLOW_SMOOTHING_TYPE(TYP, REGION_FLAG)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER, OPTIONAL :: REGION_FLAG
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    CALL GEOMETRIC_FLOW_SMOOTHING(SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, REGION_FLAG)

    END SUBROUTINE GEOMETRIC_FLOW_SMOOTHING_TYPE

    
    
    SUBROUTINE GEOMETRIC_FLOW_SMOOTHING(TEMPPOINT_NUM, TEMPPOINT, TEMPFACE_NUM, TEMPFACE, TEMPCONNECTION_NUM, TEMPCONNECTION, TEMPDIVIDED_REGION, TEMPDIVIDED_BOUNDARY, REGION_FLAG)
    IMPLICIT NONE
    INTEGER :: TEMPPOINT_NUM
    REAL(8) :: TEMPPOINT(3,TEMPPOINT_NUM)
    INTEGER :: TEMPFACE_NUM
    INTEGER :: TEMPFACE(3,TEMPFACE_NUM)
    INTEGER :: TEMPCONNECTION_NUM(TEMPPOINT_NUM)
    INTEGER :: TEMPCONNECTION(30,TEMPFACE_NUM)
    INTEGER :: TEMPDIVIDED_REGION(TEMPFACE_NUM)
    INTEGER :: TEMPDIVIDED_BOUNDARY(3,TEMPFACE_NUM)

    INTEGER :: FACE_NUM, TEMP
    INTEGER :: I,J,K,L, I1,I2,I3, J0, J1, FACE_INDEX, IDX
    INTEGER, ALLOCATABLE :: CONNECTION(:,:), CONNECTION_NUM(:), FACE(:,:), POINT_IDX(:,:), FACE_IDX(:), POINT_INDEX(:), NUM(:)
    REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:), FACE_AREA(:), POINT_NORMAL(:,:,:), POINT_NEIGHBOR(:,:)
    REAL(8) :: U, V, Q
    REAL(8) :: POINT(3,4), TEMPPOINT0(3)
    REAL(8) :: V1(3), V2(3), V3(3), W1(3), W2(3), Q1(4), Q2(4)
    REAL(8) :: F, AREA
    REAL(8) :: SU(3), SV(3), TEMPVEC(3)
    REAL(8), ALLOCATABLE :: NORMAL(:,:), ALPHA(:), BETA(:), DELTA(:), ALPHA_21(:), ALPHA_43(:), ALPHA_31(:), ALPHA_42(:), WEIGHT(:,:), H(:,:), R1(:,:), MASS_CENTER(:,:)
    REAL(8) :: AREA_SUM



    INTEGER, OPTIONAL :: REGION_FLAG
    LOGICAL :: B, C

    FACE_NUM = TEMPFACE_NUM/2

    ALLOCATE(DISPLACEMENT(3,TEMPPOINT_NUM))
    ALLOCATE(FACE_AREA(FACE_NUM))        
    ALLOCATE(FACE(4,FACE_NUM))

    DISPLACEMENT = 0.
    FACE_AREA = 0.
    FACE = 0

    !RECOVER QUAD MESH FROM TRIANGULAR MESH	
    DO I=1,FACE_NUM
        FACE(1,I) = TEMPFACE(1,2*I-1)
        FACE(2,I) = TEMPFACE(2,2*I-1)
        FACE(3,I) = TEMPFACE(3,2*I-1)
        FACE(4,I) = TEMPFACE(3,2*I)
    END DO

    ALLOCATE(CONNECTION(30,TEMPPOINT_NUM))
    ALLOCATE(CONNECTION_NUM(TEMPPOINT_NUM))
    CONNECTION = 0
    CONNECTION_NUM = 0

    DO I=1,FACE_NUM
        DO J=1,4
            CONNECTION_NUM(FACE(J,I)) = CONNECTION_NUM(FACE(J,I)) + 1
            CONNECTION(CONNECTION_NUM(FACE(J,I)),FACE(J,I)) = I
        END DO
    END DO

    DO I=1,TEMPPOINT_NUM      
        ALLOCATE(POINT_INDEX(CONNECTION_NUM(I)))
        POINT_INDEX = 0
        DO J=1,CONNECTION_NUM(I)
            J0 = CONNECTION(J,I)
            DO K=1,4
                IF(FACE(K,J0)==I) THEN
                    POINT_INDEX(J) = K
                    EXIT
                END IF
            END DO
        END DO

        DO J=1,CONNECTION_NUM(I)
            J0 = CONNECTION(J,I)
            I1 = FACE(MOD(POINT_INDEX(J)+2,4)+1, J0)
            DO K=J+1,CONNECTION_NUM(I)
                J1 = CONNECTION(K,I)
                I2 = FACE(MOD(POINT_INDEX(K),4)+1, J1)
                IF(I1==I2) THEN
                    TEMP = CONNECTION(J+1,I)
                    CONNECTION(J+1,I) = CONNECTION(K,I)
                    CONNECTION(K,I) = TEMP

                    TEMP = POINT_INDEX(J+1)
                    POINT_INDEX(J+1) = POINT_INDEX(K)
                    POINT_INDEX(K) = TEMP

                    EXIT
                END IF
            END DO
        END DO
        DEALLOCATE(POINT_INDEX)
    END DO



    !DEFINING QUADRATURE POINTS

    Q1 = (/-1.0, 1.0, -1.0, 1.0/)
    Q2 = (/-1.0, -1.0, 1.0, 1.0/)
    Q  = SQRT(3.0)/6.0

    POINT = 0.

    !COMPUTING AREA OF QUAD ELEMENT(INCLUDING NON-COPLANAR CASE)
    DO I = 1, FACE_NUM
        POINT(:,1) = TEMPPOINT(:,FACE(1,I))
        POINT(:,2) = TEMPPOINT(:,FACE(2,I))
        POINT(:,4) = TEMPPOINT(:,FACE(3,I))
        POINT(:,3) = TEMPPOINT(:,FACE(4,I))
        DO K = 1, 4
            U = 0.5 + Q1(K)*Q
            V = 0.5 + Q2(K)*Q
            SU = (1-V)*(POINT(:,2)-POINT(:,1)) + V*(POINT(:,4)-POINT(:,3))
            SV = (1-U)*(POINT(:,3)-POINT(:,1)) + U*(POINT(:,4)-POINT(:,2))
            CALL VEC_CURL1(SU,SV,TEMPVEC)
            F = SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
            FACE_AREA(I) = FACE_AREA(I) + F/4.
        END DO
    END DO

    ALLOCATE(NORMAL(3,TEMPPOINT_NUM))
    NORMAL = 0.
    !COMPUTING NORMALS
    DO I = 1, TEMPPOINT_NUM
        AREA_SUM = 0.
        DO J = 1, CONNECTION_NUM(I)
            IDX = CONNECTION(J,I)
            AREA_SUM = AREA_SUM + FACE_AREA(IDX)
            DO K = 1, 4
                V1 = TEMPPOINT(:,FACE(K,IDX))
                V2 = TEMPPOINT(:,FACE(MOD(K,4)+1,IDX))
                V3 = TEMPPOINT(:,FACE(MOD(K+1,4)+1,IDX))
                W1 = V2 - V1
                W2 = V3 - V1
                CALL VEC_CURL1(W1,W2,TEMPVEC)
                NORMAL(:,I) = NORMAL(:,I) + FACE_AREA(IDX)*TEMPVEC
            END DO
        END DO
        NORMAL(:,I) = NORMAL(:,I)/AREA_SUM
        NORMAL(:,I) = NORMAL(:,I)/SQRT(DOT_PRODUCT(NORMAL(:,I),NORMAL(:,I)))
    END DO

    !APPROXIMATING THE MEAN CURVATURE TERM AND THE TANGENT TERM

    ALLOCATE(H(3,TEMPPOINT_NUM))
    ALLOCATE(R1(3,TEMPPOINT_NUM))
    ALLOCATE(MASS_CENTER(3,TEMPPOINT_NUM))
    ALLOCATE(WEIGHT(30,TEMPPOINT_NUM))
    ALLOCATE(NUM(TEMPPOINT_NUM))
    ALLOCATE(POINT_IDX(30,TEMPPOINT_NUM))
    ALLOCATE(POINT_NORMAL(3,30,TEMPPOINT_NUM))	
    H = 0.
    R1 = 0.
    MASS_CENTER = 0.
    WEIGHT = 0.
    NUM = 0
    POINT_IDX = 0
    POINT_NORMAL = 0.    

    DO I = 1, TEMPPOINT_NUM

    B = .TRUE.
    IF(PRESENT(REGION_FLAG)) THEN
        DO J=1,TEMPCONNECTION_NUM(I)
            IF(TEMPDIVIDED_REGION(TEMPCONNECTION(J,I)).NE.REGION_FLAG) THEN
                B = .FALSE.
            END IF
        END DO
    END IF

    C = .TRUE.
    DO J=1,TEMPCONNECTION_NUM(I)
        DO K=1,3
            IF(TEMPFACE(K,TEMPCONNECTION(J,I))==I) THEN
                EXIT
            END IF
        END DO

        IF(TEMPDIVIDED_BOUNDARY(K,TEMPCONNECTION(J,I)).NE. 0) THEN
            C = .FALSE.
            EXIT
        END IF
    END DO

    IF(B .AND. C) THEN


    !        IF(SURFACE_CURRENT%POINT_TYPE(I)==1 .OR. SURFACE_CURRENT%POINT_TYPE(I)==2 .OR. SURFACE_CURRENT%POINT_TYPE(I)==4 .OR. SURFACE_CURRENT%POINT_TYPE(I) == 5) THEN
    NUM(I) = CONNECTION_NUM(I)
    ALLOCATE(POINT_NEIGHBOR(3,2*NUM(I)))
    ALLOCATE(ALPHA_21(NUM(I)))
    ALLOCATE(ALPHA_43(NUM(I)))
    ALLOCATE(ALPHA_31(NUM(I)))
    ALLOCATE(ALPHA_42(NUM(I)))
    ALLOCATE(ALPHA(NUM(I)))
    ALLOCATE(BETA(NUM(I)))
    ALLOCATE(DELTA(NUM(I)))
    ALLOCATE(FACE_IDX(2*NUM(I)))
    ALPHA_21 = 0.
    ALPHA_43 = 0.
    ALPHA_31 = 0.
    ALPHA_42 = 0.
    ALPHA = 0.
    BETA = 0.
    DELTA = 0.
    AREA_SUM = 0.
    POINT_NEIGHBOR = 0.

    DO J = 1, NUM(I)
        FACE_INDEX = CONNECTION(J,I)
        AREA = FACE_AREA(FACE_INDEX)
        AREA_SUM = AREA_SUM + FACE_AREA(FACE_INDEX)

        DO K = 1, 4
            TEMP = FACE(K,FACE_INDEX)
            IF(TEMP==I) THEN
                IDX = K
                EXIT
            END IF
        END DO

        IF(IDX==1) THEN
            I1 = 2
            I2 = 3
            I3 = 4
        ELSEIF(IDX==2) THEN
            I1 = 3
            I2 = 4
            I3 = 1
        ELSEIF(IDX==3) THEN
            I1 = 4
            I2 = 1
            I3 = 2
        ELSE
            I1 = 1
            I2 = 2
            I3 = 3
        END IF

        TEMPPOINT0 = TEMPPOINT(:,FACE(IDX,FACE_INDEX))
        IF(I .NE. FACE(IDX,FACE_INDEX)) THEN
            WRITE(*,*) 'ERROR IN GEOMETRIC_SMOOTHING, CHECK INDEXES'
        END IF

        POINT_NEIGHBOR(:,2*J-1) = TEMPPOINT(:,FACE(I1,FACE_INDEX))
        POINT_NORMAL(:,2*J-1,I) = NORMAL(:,FACE(I1,FACE_INDEX))
        POINT_IDX(2*J-1,I) = FACE(I1,FACE_INDEX)

        POINT_NEIGHBOR(:,2*J) = TEMPPOINT(:,FACE(I2,FACE_INDEX))
        POINT_NORMAL(:,2*J,I) = NORMAL(:,FACE(I2,FACE_INDEX))
        POINT_IDX(2*J,I) = FACE(I2,FACE_INDEX)

        POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I))) = TEMPPOINT(:,FACE(I3,FACE_INDEX))
        POINT_NORMAL(:,MOD(2*J+1,2*NUM(I)),I) = NORMAL(:,FACE(I3,FACE_INDEX))
        POINT_IDX(MOD(2*J+1,2*NUM(I)),I) = FACE(I3,FACE_INDEX)  

        !COMPUTING ALPHA_21, ALPHA_43, ALPHA_31, ALPHA_42 FOR EACH FACE ADJACENT TO ITH POINT.
        ALPHA_21 = 0.
        ALPHA_43 = 0.
        ALPHA_31 = 0.
        ALPHA_42 = 0.

        DO K = 1, 4
            U = 0.5 + Q1(K)*Q
            V = 0.5 + Q2(K)*Q                
            SU = (1-V)*(POINT_NEIGHBOR(:,2*J-1)-TEMPPOINT0) + V*(POINT_NEIGHBOR(:,2*J)-POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I))))
            SV = (1-U)*(POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I)))-TEMPPOINT0) + U * (POINT_NEIGHBOR(:,2*J)-POINT_NEIGHBOR(:,2*J-1))
            CALL VEC_CURL1(SU,SV,TEMPVEC)
            F = SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))
            ALPHA_21(J) = ALPHA_21(J) + ((1.- V)*DOT_PRODUCT(SV,(V-1.)*SV-(1.-U)*SU))/(4.*F)
            ALPHA_43(J) = ALPHA_43(J) + (V*DOT_PRODUCT(SV,(V-1.)*SV-(U-1.)*SU))/(4.*F)
            ALPHA_31(J) = ALPHA_31(J) + ((1.-U)*DOT_PRODUCT(SU,(U-1.)*SU-(V-1.)*SV))/(4.*F)
            ALPHA_42(J) = ALPHA_42(J) + (U*DOT_PRODUCT(SU,(U-1.)*SU-(V-1.)*SV))/(4.*F)
        END DO

        ALPHA(J) = ALPHA_21(J) - ALPHA_42(J)
        BETA(J) = ALPHA_31(J) - ALPHA_43(J)
        DELTA(J) = ALPHA_43(J) + ALPHA_42(J)

        H(:,I) = H(:,I) + ALPHA(J)*(POINT_NEIGHBOR(:,2*J-1)-TEMPPOINT0) + BETA(J)*(POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I)))-TEMPPOINT0) + DELTA(J)*(POINT_NEIGHBOR(:,2*J)-TEMPPOINT0) 
        MASS_CENTER(:,I) = MASS_CENTER(:,I) + (TEMPPOINT0+POINT_NEIGHBOR(:,2*J-1)+POINT_NEIGHBOR(:,2*J)+POINT_NEIGHBOR(:,MOD(2*J+1,2*NUM(I))))*AREA/4.

    END DO
    MASS_CENTER(:,I) = MASS_CENTER(:,I)/AREA_SUM

    H(:,I) = H(:,I)/AREA_SUM
    R1(:,I) = R1(:,I) + (MASS_CENTER(:,I)-TEMPPOINT0)-DOT_PRODUCT(NORMAL(:,I),MASS_CENTER(:,I)-TEMPPOINT0)*NORMAL(:,I)

    DO L = 1, NUM(I)
        IF(L==1) THEN
            WEIGHT(2*L-1,I) = ALPHA(L)
            WEIGHT(2*L,I) = DELTA(L)
        ELSEIF(L==NUM(I)) THEN
            WEIGHT(2*L,I) = DELTA(L)            
        ELSE
            WEIGHT(2*L-1,I) = ALPHA(L) + BETA(L-1)
            WEIGHT(2*L,I) = DELTA(L)
            WEIGHT(2*L+1,I) = ALPHA(L+1) + BETA(L)
        END IF
    END DO

    WEIGHT(:,I) = WEIGHT(:,I)/AREA_SUM

    DEALLOCATE(POINT_NEIGHBOR)
    DEALLOCATE(ALPHA_21)
    DEALLOCATE(ALPHA_43)
    DEALLOCATE(ALPHA_31)
    DEALLOCATE(ALPHA_42)
    DEALLOCATE(ALPHA)
    DEALLOCATE(BETA)
    DEALLOCATE(DELTA)
    DEALLOCATE(FACE_IDX)
    !        END IF

    !	IF(SURFACE_CURRENT%POINT_TYPE(I)==2 .OR. SURFACE_CURRENT%POINT_TYPE(I)==4 .OR. SURFACE_CURRENT%POINT_TYPE(I) == 5) THEN        
    !	    RIDGE_NUM = 0
    !	    NEIGHBOR_RIDGE_POINT(:,1) = TEMPPOINT(:,I)
    !	    NEIGHBOR_RIDGE_POINT(:,2) = TEMPPOINT(:,I)
    !
    !	    DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
    !	    FACEIDX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
    !	        DO K = 1, 3
    !		    IF( SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K,FACEIDX)>0 .AND. ((TEMPFACE(K,FACEIDX).EQ.I) .OR. (TEMPFACE(MOD(K,3)+1,FACEIDX).EQ. I))) THEN
    !			IF(TEMPFACE(K,FACEIDX) .EQ. I) THEN
    !			    TEMP_POINT = TEMPPOINT(:,TEMPFACE(MOD(K,3)+1,FACEIDX))
    !			ELSE
    !			    TEMP_POINT = TEMPPOINT(:,TEMPFACE(K,FACEIDX))					
    !			END IF
    !
    !		        IF(DOT_PRODUCT(TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,1),TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,1))>MINERROR .AND. DOT_PRODUCT(TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,2),TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,2))>MINERROR) THEN
    !		            RIDGE_NUM = RIDGE_NUM + 1
    !		            NEIGHBOR_RIDGE_POINT(:,RIDGE_NUM) = TEMP_POINT
    !		            EXIT
    !		        END IF
    !		    END IF
    !	        END DO
    !	        IF(RIDGE_NUM == 2) EXIT
    !	    END DO
    !
    !	    IF(RIDGE_NUM < 2) THEN
    !	        WRITE(*,*) 'END OF THE RIDGE FOUND IN GEOMETRIC SMOOTHING'
    !	        WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,1)
    !	        WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,2)
    !	        WRITE(*,*) 'INDICES : ', I, J
    !	    END IF
    !
    !	    V1 = NEIGHBOR_RIDGE_POINT(:,1) - TEMPPOINT(:,I)
    !	    L1 = SQRT(DOT_PRODUCT(V1,V1))
    !	    V2 = -(NEIGHBOR_RIDGE_POINT(:,2) - TEMPPOINT(:,I))
    !	    L2 = SQRT(DOT_PRODUCT(V2,V2))        
    !
    !	    W = L1*V1 + L2*V2
    !	    W = W/SQRT(DOT_PRODUCT(W,W))
    !		
    !	    IF(DOT_PRODUCT(R1(:,I),W)<0) THEN
    !		W = -1.*W
    !	    END IF
    !	    R1(:,I) = DOT_PRODUCT(R1(:,I),W)*W
    !	END IF


    END IF
    END DO

    !   DO I = 1, TEMPPOINT_NUM
    !       DO L = 1, 2*NUM(I)
    !           TEMP = DOT_PRODUCT(POINT_NORMAL(:,L,I),H(:,POINT_IDX(L,I)))
    !	        R1(:,I) = R1(:,I) + 2*WEIGHT(L,I)*(TEMP*NORMAL(:,I)-H(:,I))
    !       END DO
    !   END DO

    !TIME-INTEGRATION

    DO I = 1, TEMPPOINT_NUM
        TEMPPOINT(:,I) = TEMPPOINT(:,I) + R1(:,I)
    END DO

    DEALLOCATE(DISPLACEMENT)
    DEALLOCATE(FACE_AREA)        
    DEALLOCATE(FACE)
    DEALLOCATE(CONNECTION)
    DEALLOCATE(CONNECTION_NUM)
    DEALLOCATE(H)
    DEALLOCATE(R1)
    DEALLOCATE(MASS_CENTER)
    DEALLOCATE(NORMAL)
    DEALLOCATE(NUM)
    DEALLOCATE(POINT_IDX)
    DEALLOCATE(POINT_NORMAL)
    DEALLOCATE(WEIGHT)

    END SUBROUTINE GEOMETRIC_FLOW_SMOOTHING

    
    
    SUBROUTINE GEOMETRIC_FLOW_SMOOTHING_TRIANGLE_TYPE(TYP, REGION_FLAG)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER, OPTIONAL :: REGION_FLAG
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    CALL GEOMETRIC_FLOW_SMOOTHING_TRIANGLE(SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, REGION_FLAG)

    END SUBROUTINE GEOMETRIC_FLOW_SMOOTHING_TRIANGLE_TYPE

    
    
    SUBROUTINE GEOMETRIC_FLOW_SMOOTHING_TRIANGLE(POINT_NUM, POINT, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_REGION, DIVIDED_BOUNDARY, REGION_FLAG)
    IMPLICIT NONE
    INTEGER :: POINT_NUM
    REAL(8) :: POINT(3,POINT_NUM)
    INTEGER :: FACE_NUM
    INTEGER :: FACE(3,FACE_NUM)
    INTEGER :: CONNECTION_NUM(POINT_NUM)
    INTEGER :: CONNECTION(30,POINT_NUM)
    INTEGER :: DIVIDED_REGION(FACE_NUM)
    INTEGER :: DIVIDED_BOUNDARY(3,FACE_NUM)
    INTEGER :: TEMP
    INTEGER :: I,J,K, I1,I2, FACE_INDEX, IDX
    INTEGER, ALLOCATABLE :: NUM(:)
    REAL(8), ALLOCATABLE :: FACE_AREA(:), POINT_NEIGHBOR(:,:)
    REAL(8) :: TEMPPOINT(3,3), TEMPPOINT0(3)
    REAL(8) :: V1(3), V2(3), V3(3), W1(3), W2(3)
    REAL(8) :: AREA
    REAL(8) :: TEMPVEC(3)
    REAL(8), ALLOCATABLE :: NORMAL(:,:), R1(:,:), MASS_CENTER(:,:)
    REAL(8) :: AREA_SUM
    INTEGER, OPTIONAL :: REGION_FLAG
    LOGICAL :: B, C

    ALLOCATE(FACE_AREA(FACE_NUM))        

    FACE_AREA = 0.

    !COMPUTING AREA OF QUAD ELEMENT(INCLUDING NON-COPLANAR CASE)
    DO I = 1, FACE_NUM
        TEMPPOINT(:,1) = POINT(:,FACE(1,I))
        TEMPPOINT(:,2) = POINT(:,FACE(2,I))
        TEMPPOINT(:,3) = POINT(:,FACE(3,I))

        W1 = TEMPPOINT(:,2) - TEMPPOINT(:,1)
        W2 = TEMPPOINT(:,3) - TEMPPOINT(:,1)
        CALL VEC_CURL1(W1,W2,TEMPVEC)
        FACE_AREA(I) = SQRT(DOT_PRODUCT(TEMPVEC,TEMPVEC))/2.

    END DO



    ALLOCATE(NORMAL(3,POINT_NUM))
    NORMAL = 0.
    !COMPUTING NORMALS
    DO I = 1, POINT_NUM
        AREA_SUM = 0.
        DO J = 1, CONNECTION_NUM(I)
            IDX = CONNECTION(J,I)
            AREA_SUM = AREA_SUM + FACE_AREA(IDX)
            DO K = 1, 3
                V1 = POINT(:,FACE(1,IDX))
                V2 = POINT(:,FACE(2,IDX))
                V3 = POINT(:,FACE(3,IDX))
                W1 = V2 - V1
                W2 = V3 - V1
                CALL VEC_CURL1(W1,W2,TEMPVEC)
                NORMAL(:,I) = NORMAL(:,I) + FACE_AREA(IDX)*TEMPVEC
            END DO
        END DO
        NORMAL(:,I) = NORMAL(:,I)/AREA_SUM
        NORMAL(:,I) = NORMAL(:,I)/SQRT(DOT_PRODUCT(NORMAL(:,I),NORMAL(:,I)))
    END DO

    !APPROXIMATING THE MEAN CURVATURE TERM AND THE TANGENT TERM

    ALLOCATE(R1(3,POINT_NUM))
    ALLOCATE(MASS_CENTER(3,POINT_NUM))
    ALLOCATE(NUM(POINT_NUM))

    R1 = 0.
    MASS_CENTER = 0.
    NUM = 0

    DO I = 1, POINT_NUM

    B = .TRUE.
    IF(PRESENT(REGION_FLAG)) THEN
        DO J=1,CONNECTION_NUM(I)
            IF(DIVIDED_REGION(CONNECTION(J,I)).NE.REGION_FLAG) THEN
                B = .FALSE.
                EXIT
            END IF
        END DO
    END IF

    C = .TRUE.
    DO J=1,CONNECTION_NUM(I)
        DO K=1,3
            IF(FACE(K,CONNECTION(J,I))==I) THEN
                EXIT
            END IF
        END DO

        IF(DIVIDED_BOUNDARY(K,CONNECTION(J,I)).NE. 0) THEN
            C = .FALSE.
            EXIT
        END IF
    END DO

    IF(B .AND. C) THEN


    !        IF(SURFACE_CURRENT%POINT_TYPE(I)==1 .OR. SURFACE_CURRENT%POINT_TYPE(I)==2 .OR. SURFACE_CURRENT%POINT_TYPE(I)==4 .OR. SURFACE_CURRENT%POINT_TYPE(I) == 5) THEN
    NUM(I) = CONNECTION_NUM(I)
    ALLOCATE(POINT_NEIGHBOR(3,NUM(I)))

    AREA_SUM = 0.
    POINT_NEIGHBOR = 0.

    DO J = 1, NUM(I)
        FACE_INDEX = CONNECTION(J,I)
        AREA = FACE_AREA(FACE_INDEX)
        AREA_SUM = AREA_SUM + FACE_AREA(FACE_INDEX)

        DO K = 1, 3
            TEMP = FACE(K,FACE_INDEX)
            IF(TEMP==I) THEN
                IDX = K
                EXIT
            END IF
        END DO

        IF(IDX==1) THEN
            I1 = 2
            I2 = 3
        ELSEIF(IDX==2) THEN
            I1 = 3
            I2 = 1
        ELSE
            I1 = 1
            I2 = 2
        END IF

        TEMPPOINT0 = POINT(:,FACE(IDX,FACE_INDEX))

        POINT_NEIGHBOR(:,J) = POINT(:,FACE(I1,FACE_INDEX))

        POINT_NEIGHBOR(:,MOD(J,NUM(I))+1) = POINT(:,FACE(I2,FACE_INDEX))

        MASS_CENTER(:,I) = MASS_CENTER(:,I) + (TEMPPOINT0+POINT_NEIGHBOR(:,J)+POINT_NEIGHBOR(:,MOD(J,NUM(I))+1))*AREA/3.

    END DO

    MASS_CENTER(:,I) = MASS_CENTER(:,I)/AREA_SUM
    R1(:,I) = R1(:,I) + (MASS_CENTER(:,I)-TEMPPOINT0)-DOT_PRODUCT(NORMAL(:,I),MASS_CENTER(:,I)-TEMPPOINT0)*NORMAL(:,I)     

    DEALLOCATE(POINT_NEIGHBOR)
    !	END IF

    !	IF(SURFACE_CURRENT%POINT_TYPE(I)==2 .OR. SURFACE_CURRENT%POINT_TYPE(I)==4 .OR. SURFACE_CURRENT%POINT_TYPE(I) == 5) THEN        
    !	    RIDGE_NUM = 0
    !	    NEIGHBOR_RIDGE_POINT(:,1) = POINT(:,I)
    !	    NEIGHBOR_RIDGE_POINT(:,2) = POINT(:,I)
    !
    !	    DO J = 1, CONNECTION_NUM(I)
    !	    FACEIDX = CONNECTION(J,I)
    !	        DO K = 1, 3
    !		    IF( SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K,FACEIDX)>0 .AND. ((FACE(K,FACEIDX).EQ.I) .OR. (FACE(MOD(K,3)+1,FACEIDX).EQ. I))) THEN
    !			IF(FACE(K,FACEIDX) .EQ. I) THEN
    !			    TEMP_POINT = POINT(:,FACE(MOD(K,3)+1,FACEIDX))
    !			ELSE
    !			    TEMP_POINT = POINT(:,FACE(K,FACEIDX))					
    !			END IF
    !
    !		        IF(DOT_PRODUCT(TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,1),TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,1))>MINERROR .AND. DOT_PRODUCT(TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,2),TEMP_POINT-NEIGHBOR_RIDGE_POINT(:,2))>MINERROR) THEN
    !		            RIDGE_NUM = RIDGE_NUM + 1
    !		            NEIGHBOR_RIDGE_POINT(:,RIDGE_NUM) = TEMP_POINT
    !		            EXIT
    !		        END IF
    !		    END IF
    !	        END DO
    !	        IF(RIDGE_NUM == 2) EXIT
    !	    END DO
    !
    !	    IF(RIDGE_NUM < 2) THEN
    !	        WRITE(*,*) 'END OF THE RIDGE FOUND IN GEOMETRIC SMOOTHING'
    !	        WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,1)
    !	        WRITE(*,*) 'NEIGHBOR_RIDGE_POINT :', NEIGHBOR_RIDGE_POINT(:,2)
    !	        WRITE(*,*) 'INDICES : ', I, J
    !	    END IF
    !
    !	    V1 = NEIGHBOR_RIDGE_POINT(:,1) - POINT(:,I)
    !	    L1 = SQRT(DOT_PRODUCT(V1,V1))
    !	    V2 = -(NEIGHBOR_RIDGE_POINT(:,2) - POINT(:,I))
    !	    L2 = SQRT(DOT_PRODUCT(V2,V2))        
    !
    !	    W = L1*V1 + L2*V2
    !	    W = W/SQRT(DOT_PRODUCT(W,W))
    !	    IF(DOT_PRODUCT(R1(:,I),W)<0) THEN
    !		W = -1.*W
    !	    END IF
    !	    R1(:,I) = DOT_PRODUCT(R1(:,I),W)*W
    !	END IF


    END IF
    END DO

    DO I = 1, POINT_NUM
        POINT(:,I) = POINT(:,I) + R1(:,I)
    END DO

    DEALLOCATE(FACE_AREA)        
    DEALLOCATE(R1)
    DEALLOCATE(MASS_CENTER)
    DEALLOCATE(NORMAL)
    DEALLOCATE(NUM)

    END SUBROUTINE GEOMETRIC_FLOW_SMOOTHING_TRIANGLE

    

    SUBROUTINE NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP(TYP)
    IMPLICIT NONE
    INTEGER :: TYP

    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF



    !CALL BOUNDARY_DIVIDING(TYP)

    CALL NEW_MODIFIED_NULLSPACE_SMOOTHING(SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA, SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH, SURFACE_CURRENT%POINT_TYPE, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY)

    END SUBROUTINE NEW_MODIFIED_NULLSPACE_SMOOTHING_TYP



    SUBROUTINE NEW_MODIFIED_NULLSPACE_SMOOTHING(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMP_NEWFACEAREA, TEMP_NEWEDGELENGTH, TEMPPOINT_TYPE, DIVIDED_BOUNDARY_ARRAY)
    IMPLICIT NONE
    INTEGER :: TEMP_POINT_NUM
    REAL(8) :: TEMPPOINT(:,:)
    INTEGER :: TEMP_FACE_NUM
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    REAL(8) :: TEMP_NEWFACEAREA(:)
    REAL(8) :: TEMP_NEWEDGELENGTH(:,:)
    INTEGER :: TEMPPOINT_TYPE(:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    REAL(8), ALLOCATABLE :: DISPLACEMENT(:,:)
    INTEGER :: I,J,K,L
    INTEGER :: I1,I2,I3, CON_NUM
    REAL(8) :: V1(3),V2(3)
    REAL(8), ALLOCATABLE :: NORMAL(:,:)
    !! MODIFIED
    INTEGER :: LOCAL_SHAPE, TEMP_I, JMIN
    REAL(8) :: THETA_A, PHI_R, PHI_C, CHI_R, CHI_C
    !! END MODIFIED
    REAL(8), ALLOCATABLE :: N(:,:), W(:), ORIGIN_W(:), C(:,:), FACE_CENTER(:,:), FACE_AREA(:), T(:,:)
    REAL(8) :: CC(3)
    INTEGER :: RIDGE_EDGE_NUM, RIDGE_EDGE(2,10)
    REAL(8) :: W_SUM, ORIGIN_W_SUM
    REAL(8) :: R
    REAL(8) :: E_VALUE(3)
    REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
    REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
    REAL(8) :: TT(3,3)


    ALLOCATE(DISPLACEMENT(3,TEMP_POINT_NUM))
    ALLOCATE(FACE_AREA(TEMP_FACE_NUM))        
    ALLOCATE(FACE_CENTER(3,TEMP_FACE_NUM))
    ALLOCATE(NORMAL(3,TEMP_FACE_NUM))

    DO I=1,TEMP_FACE_NUM           
        I1 = TEMPFACE(1,I)
        I2 = TEMPFACE(2,I)
        I3 = TEMPFACE(3,I)

        V1 = TEMPPOINT(:,I2) - TEMPPOINT(:,I1)
        V2 = TEMPPOINT(:,I3) - TEMPPOINT(:,I1)    

        FACE_CENTER(:,I) = (TEMPPOINT(:,I1) + TEMPPOINT(:,I2) + TEMPPOINT(:,I3))/3.

        CALL VEC_CURL1(V1,V2, NORMAL(:,I))

        R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
        FACE_AREA(I) = R/2.  
        NORMAL(:,I) = NORMAL(:,I) / R       
    END DO

    DO I=1,TEMP_POINT_NUM

    CON_NUM = TEMP_CONNECTION_NUM(I)

    ALLOCATE(N(CON_NUM,3))
    ALLOCATE(W(CON_NUM))
    ALLOCATE(ORIGIN_W(CON_NUM))
    ALLOCATE(C(3,CON_NUM))

    W_SUM = 0.           
    ORIGIN_W_SUM = 0.
    THETA_A = 0.

    DO J = 1,CON_NUM
        W_SUM = W_SUM + FACE_AREA(TEMP_CONNECTION(J,I))             
        I1 = TEMPFACE(1,TEMP_CONNECTION(J,I))
        I2 = TEMPFACE(2,TEMP_CONNECTION(J,I))
        I3 = TEMPFACE(3,TEMP_CONNECTION(J,I))

        IF(I==I1) THEN
        ELSE IF(I==I2) THEN
            TEMP_I = I1
            I1 = I2
            I2 = I3
            I3 = TEMP_I
        ELSE
            TEMP_I = I1
            I1 = I3
            I3 = I2
            I2 = TEMP_I
        END IF

        V1 = TEMPPOINT(:,I2) - TEMPPOINT(:,I1)
        V2 = TEMPPOINT(:,I3) - TEMPPOINT(:,I1)
        THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
    END DO

    DO J = 1,CON_NUM
        N(J,:) = NORMAL(:,TEMP_CONNECTION(J,I))
        W(J) = FACE_AREA(TEMP_CONNECTION(J,I)) / W_SUM
    END DO

    DO K=1,3
        DO L=1,3
            E_VECTOR(K,L) = 0.
            DO J = 1,CON_NUM
                E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
            END DO
        END DO
    END DO

    ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX

    CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)

    DO J=1,3-1
        JMIN = J
        DO K=J+1,3
            IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                JMIN = K
            END IF
        END DO

        IF(J .NE. JMIN) THEN
            TEMP_E_VALUE = E_VALUE(J)
            TEMP_E_VECTOR = E_VECTOR(:,J)

            E_VALUE(J) = E_VALUE(JMIN)
            E_VECTOR(:,J) = E_VECTOR(:,JMIN)

            E_VALUE(JMIN) = TEMP_E_VALUE
            E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
        END IF
    END DO

    THETA_A = THETA_A - 2.*PI

    PHI_R = 14. * PI/180.
    PHI_C = 45. * PI/180.

    CHI_R = 2.*(TAN(PHI_R/2.))**2
    CHI_C = 2.*(TAN(PHI_C/2.))**2

    IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
        LOCAL_SHAPE = 3
    ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
        LOCAL_SHAPE = 2
    ELSE
        LOCAL_SHAPE = 1
    END IF

    LOCAL_SHAPE = TEMPPOINT_TYPE(I)

    RIDGE_EDGE_NUM = 0

    DO J=1,CON_NUM
        L = TEMP_CONNECTION(J,I)
        DO K=1,3
            IF(TEMPFACE(K,L)==I) THEN
                EXIT
            END IF
        END DO

        IF(DIVIDED_BOUNDARY_ARRAY(K,L) .NE. 0) THEN
            RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
            RIDGE_EDGE(1,RIDGE_EDGE_NUM) = K
            RIDGE_EDGE(2,RIDGE_EDGE_NUM) = L
        END IF
    END DO

    IF(RIDGE_EDGE_NUM > 2 .OR. RIDGE_EDGE_NUM == 1) THEN
        CC(:) = 0.
    ELSE IF(RIDGE_EDGE_NUM == 0) THEN
        DO J = 1,CON_NUM
            ORIGIN_W_SUM = ORIGIN_W_SUM + 1./TEMP_NEWFACEAREA(TEMP_CONNECTION(J,I))
        END DO

        DO J = 1,CON_NUM
            ORIGIN_W(J) = (1./TEMP_NEWFACEAREA(TEMP_CONNECTION(J,I)))/ORIGIN_W_SUM
            C(:,J) = FACE_CENTER(:,TEMP_CONNECTION(J,I)) - TEMPPOINT(:,I)
        END DO

        CC(:) = 0.
        DO J = 1,CON_NUM
            CC(:) = CC(:) + W(J) * C(:,J)/3.
        END DO
    ELSE IF(RIDGE_EDGE_NUM == 2 .AND. DIVIDED_BOUNDARY_ARRAY(RIDGE_EDGE(1,1), RIDGE_EDGE(2,1)) == DIVIDED_BOUNDARY_ARRAY(RIDGE_EDGE(1,2) , RIDGE_EDGE(2,2)) ) THEN
        DO J = 1,2
            ORIGIN_W_SUM = ORIGIN_W_SUM + 1./TEMP_NEWEDGELENGTH(RIDGE_EDGE(1,J), RIDGE_EDGE(2,J))
        END DO

        DO J = 1,2
            ORIGIN_W(J) = (1./TEMP_NEWEDGELENGTH(RIDGE_EDGE(1,J), RIDGE_EDGE(2,J)))/ORIGIN_W_SUM
            I1 = TEMPFACE(RIDGE_EDGE(1,J), RIDGE_EDGE(2,J))
            I2 = TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1, RIDGE_EDGE(2,J))
            C(:,J) = (TEMPPOINT(:,I1)+TEMPPOINT(:,I2))/2. - TEMPPOINT(:,I)
        END DO

        CC(:) = 0.
        DO J = 1,2
            CC(:) = CC(:) + ORIGIN_W(J) * C(:,J)/3.
        END DO
    ELSE
        CC(:) = 0.
    END IF

    IF(TEMPPOINT_TYPE(I)==5) THEN
        TT(:,:) = 0.
    ELSE IF(TEMPPOINT_TYPE(I)==4) THEN

    ALLOCATE(T(3,1))

    K = 0
    DO J=1,RIDGE_EDGE_NUM
        IF(TEMPPOINT_TYPE(TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1,RIDGE_EDGE(2,J)))>=4) THEN
            K = K + 1
            IF(K==1) THEN
                I1 = TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1,RIDGE_EDGE(2,J))
            ELSE
                I2 = TEMPFACE(MOD(RIDGE_EDGE(1,J),3)+1,RIDGE_EDGE(2,J))
                EXIT
            END IF
        END IF
    END DO

    T(:,1) = TEMPPOINT(:,I1) - TEMPPOINT(:,I2)

    DO K=1,3
        DO L=1,3
            TT(K,L) = TT(K,L) + T(K,1)*T(L,1)
        END DO
    END DO

    DEALLOCATE(T)

    ELSE IF(LOCAL_SHAPE .NE. 3) THEN

    ALLOCATE(T(3,3-LOCAL_SHAPE))

    DO J = LOCAL_SHAPE+1, 3
        T(:,J-LOCAL_SHAPE) = E_VECTOR(:,J)
    END DO

    DO K=1,3
        DO L=1,3
            TT(K,L) = 0.
            DO J=1,3-LOCAL_SHAPE
                TT(K,L) = TT(K,L) + T(K,J)*T(L,J)    
            END DO
        END DO
    END DO

    DEALLOCATE(T)
    ELSE
        TT(:,:) = 0.
    END IF

    DISPLACEMENT(:,I) = 0.

    DO K = 1,3
        DO L = 1,3
            DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + TT(K,L)*CC(L)
        END DO
    END DO

    DEALLOCATE(N)
    DEALLOCATE(W)
    DEALLOCATE(ORIGIN_W)
    DEALLOCATE(C)

    END DO

    ! CALL FIND_POINT_TYPE(TYP)

    !$OMP PARALLEL DO PRIVATE(I)
    DO I=1,TEMP_POINT_NUM
        IF(TEMPPOINT_TYPE(I) == 3 .OR. TEMPPOINT_TYPE(I)==6) THEN
            DISPLACEMENT(:,I) = 0.
        END IF
    END DO
    !$OMP END PARALLEL DO

    DO I = 1,TEMP_POINT_NUM
        TEMPPOINT(:,I) = TEMPPOINT(:,I) + DISPLACEMENT(:,I)
    END DO

    DEALLOCATE(NORMAL)
    DEALLOCATE(FACE_AREA)  
    DEALLOCATE(FACE_CENTER)

    DEALLOCATE(DISPLACEMENT)


    END SUBROUTINE NEW_MODIFIED_NULLSPACE_SMOOTHING
    
    SUBROUTINE FIND_LOCAL_SHAPE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, LOCAL_SHAPE)
    IMPLICIT NONE
    INTEGER :: TEMP_POINT_NUM
    REAL(8) :: TEMPPOINT(3,TEMP_POINT_NUM)
    INTEGER :: TEMP_FACE_NUM
    INTEGER :: TEMPFACE(3,TEMP_FACE_NUM)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    INTEGER :: LOCAL_SHAPE(:)
    
    INTEGER :: I,J,K,L, CON_NUM, I1, I2, I3, TEMP_I
    REAL(8) :: V1(3),V2(3)
    REAL(8), ALLOCATABLE :: NORMAL(:,:), FACE_AREA(:)
    INTEGER :: JMIN
    
    REAL(8), ALLOCATABLE :: N(:,:), W(:)
    REAL(8) :: W_SUM
    REAL(8) :: R
    REAL(8) :: E_VALUE(3)
    REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
    REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
    
    REAL(8) :: THETA_A, PHI_R, PHI_C, CHI_R, CHI_C

    ALLOCATE(FACE_AREA(TEMP_FACE_NUM))
    ALLOCATE(NORMAL(3,TEMP_FACE_NUM))

    DO I=1,TEMP_FACE_NUM
        V1 = TEMPPOINT(:,TEMPFACE(2,I)) - TEMPPOINT(:,TEMPFACE(1,I))
        V2 = TEMPPOINT(:,TEMPFACE(3,I)) - TEMPPOINT(:,TEMPFACE(1,I))
        
        CALL VEC_CURL1(V1,V2, NORMAL(:,I))

        R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
        FACE_AREA(I) = R/2.
        NORMAL(:,I) = NORMAL(:,I) / R
    END DO

    DO I=1,TEMP_POINT_NUM

    CON_NUM = TEMP_CONNECTION_NUM(I)

    ALLOCATE(N(CON_NUM,3))
    ALLOCATE(W(CON_NUM))

    W_SUM = 0.
    THETA_A = 0.

    DO J = 1,CON_NUM
        W_SUM = W_SUM + FACE_AREA(TEMP_CONNECTION(J,I))             
        I1 = TEMPFACE(1,TEMP_CONNECTION(J,I))
        I2 = TEMPFACE(2,TEMP_CONNECTION(J,I))
        I3 = TEMPFACE(3,TEMP_CONNECTION(J,I))

        IF(I==I1) THEN
        ELSE IF(I==I2) THEN
            TEMP_I = I1
            I1 = I2
            I2 = I3
            I3 = TEMP_I
        ELSE
            TEMP_I = I1
            I1 = I3
            I3 = I2
            I2 = TEMP_I
        END IF

        V1 = TEMPPOINT(:,I2) - TEMPPOINT(:,I1)
        V2 = TEMPPOINT(:,I3) - TEMPPOINT(:,I1)
        THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
    END DO

    DO J = 1,CON_NUM
        N(J,:) = NORMAL(:,TEMP_CONNECTION(J,I))
        W(J) = FACE_AREA(TEMP_CONNECTION(J,I)) / W_SUM
    END DO

    DO K=1,3
        DO L=1,3
            E_VECTOR(K,L) = 0.
            DO J = 1,CON_NUM
                E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
            END DO
        END DO
    END DO

    ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX

    CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)

    DO J=1,3-1
        JMIN = J
        DO K=J+1,3
            IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                JMIN = K
            END IF
        END DO

        IF(J .NE. JMIN) THEN
            TEMP_E_VALUE = E_VALUE(J)
            TEMP_E_VECTOR = E_VECTOR(:,J)

            E_VALUE(J) = E_VALUE(JMIN)
            E_VECTOR(:,J) = E_VECTOR(:,JMIN)

            E_VALUE(JMIN) = TEMP_E_VALUE
            E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
        END IF
    END DO

    THETA_A = THETA_A - 2.*PI

    PHI_R = 30. * PI/180.
    PHI_C = 45. * PI/180.

    CHI_R = 2.*(TAN(PHI_R/2.))**2
    CHI_C = 2.*(TAN(PHI_C/2.))**2

    IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
        LOCAL_SHAPE(I) = 3
    ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
        LOCAL_SHAPE(I) = 2
    ELSE
        LOCAL_SHAPE(I) = 1
    END IF

    DEALLOCATE(N)
    DEALLOCATE(W)

    END DO

    DEALLOCATE(NORMAL)
    DEALLOCATE(FACE_AREA)
    
    END SUBROUTINE
    
    SUBROUTINE MASS_SPRING_TYPE(TYP, IMPLICIT_FLAG, REGION_FLAG)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL :: IMPLICIT_FLAG
    INTEGER, OPTIONAL :: REGION_FLAG
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    IF(PRESENT(REGION_FLAG)) THEN
        CALL MASS_SPRING(IMPLICIT_FLAG, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%INITIAL_POINT_TYPE, SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, REGION_FLAG)
    ELSE
        CALL MASS_SPRING(IMPLICIT_FLAG, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%INITIAL_POINT_TYPE, SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY)
    END IF
    
    END SUBROUTINE MASS_SPRING_TYPE
    
    SUBROUTINE MASS_SPRING(IMPLICIT_FLAG, TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, TEMP_NEWFACEAREA, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY, REGION_FLAG)
    IMPLICIT NONE
    
    LOGICAL :: IMPLICIT_FLAG
    INTEGER :: TEMP_POINT_NUM
    REAL(8) :: TEMPPOINT(3,TEMP_POINT_NUM)
    INTEGER :: TEMP_FACE_NUM
    INTEGER :: TEMPFACE(3,TEMP_FACE_NUM)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    INTEGER :: TEMPINITIALPOINT_TYPE(:)
    REAL(8) :: TEMP_NEWFACEAREA(:)
    INTEGER :: DIVIDED_REGION_ARRAY(:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER, OPTIONAL :: REGION_FLAG
    
    INTEGER :: I,J,K, I1,J1, NUM, IDX
    REAL(8) :: V(3), V1(3), V2(3)
    
    INTEGER :: POINT_INDEX_NUM
    INTEGER, ALLOCATABLE :: POINT_INDEX(:)
    
    REAL(8), ALLOCATABLE :: V_N(:,:), V_N1(:,:), X_N(:,:), X_N1(:,:)
    REAL(8), ALLOCATABLE :: POINT_MASS(:), SPRING_K_E(:,:), SPRING_K_D(:,:), SPRING_L0(:,:)
    
    LOGICAL :: B
    
    REAL(8), ALLOCATABLE :: DT(:)
    INTEGER :: ITER, SMOOTHING_NUM
    
    REAL(8), ALLOCATABLE :: A_CG(:,:), B_CG(:), X_CG(:)
    INTEGER, ALLOCATABLE :: A_INDICES_CG(:,:) !, A_INDICES_FULL_CG(:,:)
    
    INTEGER, ALLOCATABLE :: LOCAL_SHAPE(:)
    
    SMOOTHING_NUM = 10
    
    ALLOCATE(LOCAL_SHAPE(TEMP_POINT_NUM))
    
    CALL FIND_LOCAL_SHAPE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, LOCAL_SHAPE)
    
    POINT_INDEX_NUM = 0
    ALLOCATE(POINT_INDEX(TEMP_POINT_NUM))
    POINT_INDEX(:) = 0
    
    DO I = 1,TEMP_POINT_NUM
        B = .TRUE.
        DO J = 1,TEMP_CONNECTION_NUM(I)
            I1 = TEMP_CONNECTION(J,I)
            DO K=1,3
                IF(TEMPFACE(K,I1)==I) THEN
                    EXIT
                END IF
            END DO
            IF(DIVIDED_BOUNDARY_ARRAY(K,I1) .NE. 0) THEN
                B = .FALSE.
                EXIT
            END IF
        END DO
        
        IF(B .AND. PRESENT(REGION_FLAG)) THEN
            DO J = 1,TEMP_CONNECTION_NUM(I)
                I1 = TEMP_CONNECTION(J,I)
                IF(DIVIDED_REGION_ARRAY(I1) .NE. REGION_FLAG) THEN
                    B = .FALSE.
                    EXIT
                END IF
            END DO
        END IF
        
        IF(TEMPINITIALPOINT_TYPE(I)>=2) THEN
            B = .FALSE.
        END IF
        
        IF(B) THEN
            IF(LOCAL_SHAPE(I)>1) THEN
            
            V = 0.
            DO J=1,TEMP_CONNECTION_NUM(I)
                CALL POINT_NEIGHBOR_POINT(TEMPFACE, TEMP_CONNECTION, I, J, J1)
                V = V + TEMPPOINT(:,J1)/REAL(TEMP_CONNECTION_NUM(I))
            END DO
            TEMPPOINT(:,I) = V
            
            ELSE
            
            POINT_INDEX_NUM = POINT_INDEX_NUM + 1
            POINT_INDEX(I) = POINT_INDEX_NUM
            
            END IF
        END IF
    END DO
    
    IF(POINT_INDEX_NUM > 0) THEN
    
    ALLOCATE(DT(TEMP_POINT_NUM))
    
    DT(:) = 0.
    DO I=1,TEMP_POINT_NUM
        DO J=1,TEMP_CONNECTION_NUM(I)
            I1 = TEMP_CONNECTION(J,I)
            DT(I) = DT(I) + SQRT(SQRT(3.) * TEMP_NEWFACEAREA(I1))/REAL(TEMP_CONNECTION_NUM(I))
        END DO
    END DO
    !DT(:) = SQRT(DT(:))
    
    !DT(:) = 1.
    
    ALLOCATE(V_N(3,TEMP_POINT_NUM), V_N1(3,TEMP_POINT_NUM), X_N(3,TEMP_POINT_NUM), X_N1(3,TEMP_POINT_NUM))
    
    V_N(:,:) = 0.
    V_N1(:,:) = 0.
    
    X_N(:,:) = TEMPPOINT(:,:)
    X_N1(:,:) = 0.
    
    ALLOCATE(A_CG(POINT_INDEX_NUM*3,94), A_INDICES_CG(POINT_INDEX_NUM*3,94), B_CG(POINT_INDEX_NUM*3), X_CG(POINT_INDEX_NUM*3))
    !ALLOCATE(A_CG(POINT_INDEX_NUM*3,94), A_INDICES_CG(POINT_INDEX_NUM*3,94), A_INDICES_FULL_CG(POINT_INDEX_NUM*3,POINT_INDEX_NUM*3), B_CG(POINT_INDEX_NUM*3), X_CG(POINT_INDEX_NUM*3))
    
    IF(IMPLICIT_FLAG) THEN
    
    A_INDICES_CG(:,:) = 0.
    DO I=1,TEMP_POINT_NUM
        IF(POINT_INDEX(I) .NE. 0) THEN
        NUM = 0
        NUM = NUM + 1
        A_INDICES_CG(POINT_INDEX(I), NUM) = POINT_INDEX(I)
        A_INDICES_CG(POINT_INDEX_NUM + POINT_INDEX(I), NUM) = POINT_INDEX(I)
        A_INDICES_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), NUM) = POINT_INDEX(I)
        
        !A_INDICES_FULL_CG(POINT_INDEX(I), POINT_INDEX(I)) = NUM
        !A_INDICES_FULL_CG(POINT_INDEX_NUM + POINT_INDEX(I), POINT_INDEX(I)) = NUM
        !A_INDICES_FULL_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), POINT_INDEX(I)) = NUM
        
        NUM = NUM + 1
        A_INDICES_CG(POINT_INDEX(I), NUM) = POINT_INDEX_NUM + POINT_INDEX(I)
        A_INDICES_CG(POINT_INDEX_NUM + POINT_INDEX(I), NUM) = POINT_INDEX_NUM + POINT_INDEX(I)
        A_INDICES_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), NUM) = POINT_INDEX_NUM + POINT_INDEX(I)
        
        !A_INDICES_FULL_CG(POINT_INDEX(I), POINT_INDEX_NUM + POINT_INDEX(I)) = NUM
        !A_INDICES_FULL_CG(POINT_INDEX_NUM + POINT_INDEX(I), POINT_INDEX_NUM + POINT_INDEX(I)) = NUM
        !A_INDICES_FULL_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), POINT_INDEX_NUM + POINT_INDEX(I)) = NUM
        
        NUM = NUM + 1
        A_INDICES_CG(POINT_INDEX(I), NUM) = 2*POINT_INDEX_NUM + POINT_INDEX(I)
        A_INDICES_CG(POINT_INDEX_NUM + POINT_INDEX(I), NUM) = 2*POINT_INDEX_NUM + POINT_INDEX(I)
        A_INDICES_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), NUM) = 2*POINT_INDEX_NUM + POINT_INDEX(I)
        
        !A_INDICES_FULL_CG(POINT_INDEX(I), 2*POINT_INDEX_NUM + POINT_INDEX(I)) = NUM
        !A_INDICES_FULL_CG(POINT_INDEX_NUM + POINT_INDEX(I), 2*POINT_INDEX_NUM + POINT_INDEX(I)) = NUM
        !A_INDICES_FULL_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), 2*POINT_INDEX_NUM + POINT_INDEX(I)) = NUM
        
        DO J=1,TEMP_CONNECTION_NUM(I)
            CALL POINT_NEIGHBOR_POINT(TEMPFACE, TEMP_CONNECTION, I, J, J1)
            IF(POINT_INDEX(J1) .NE. 0) THEN
                NUM = NUM + 1
                A_INDICES_CG(POINT_INDEX(I), NUM) = POINT_INDEX(J1)
                A_INDICES_CG(POINT_INDEX_NUM + POINT_INDEX(I), NUM) = POINT_INDEX(J1)
                A_INDICES_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), NUM) = POINT_INDEX(J1)
                
                !A_INDICES_FULL_CG(POINT_INDEX(I), POINT_INDEX(J1)) = NUM
                !A_INDICES_FULL_CG(POINT_INDEX_NUM + POINT_INDEX(I), POINT_INDEX(J1)) = NUM
                !A_INDICES_FULL_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), POINT_INDEX(J1)) = NUM
                
                NUM = NUM + 1
                A_INDICES_CG(POINT_INDEX(I), NUM) = POINT_INDEX_NUM + POINT_INDEX(J1)
                A_INDICES_CG(POINT_INDEX_NUM + POINT_INDEX(I), NUM) = POINT_INDEX_NUM + POINT_INDEX(J1)
                A_INDICES_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), NUM) = POINT_INDEX_NUM + POINT_INDEX(J1)
                
                !A_INDICES_FULL_CG(POINT_INDEX(I), POINT_INDEX_NUM + POINT_INDEX(J1)) = NUM
                !A_INDICES_FULL_CG(POINT_INDEX_NUM + POINT_INDEX(I), POINT_INDEX_NUM + POINT_INDEX(J1)) = NUM
                !A_INDICES_FULL_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), POINT_INDEX_NUM + POINT_INDEX(J1)) = NUM
                
                NUM = NUM + 1
                A_INDICES_CG(POINT_INDEX(I), NUM) = 2*POINT_INDEX_NUM + POINT_INDEX(J1)
                A_INDICES_CG(POINT_INDEX_NUM + POINT_INDEX(I), NUM) = 2*POINT_INDEX_NUM + POINT_INDEX(J1)
                A_INDICES_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), NUM) = 2*POINT_INDEX_NUM + POINT_INDEX(J1)
                
                !A_INDICES_FULL_CG(POINT_INDEX(I), 2*POINT_INDEX_NUM + POINT_INDEX(J1)) = NUM
                !A_INDICES_FULL_CG(POINT_INDEX_NUM + POINT_INDEX(I), 2*POINT_INDEX_NUM + POINT_INDEX(J1)) = NUM
                !A_INDICES_FULL_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), 2*POINT_INDEX_NUM + POINT_INDEX(J1)) = NUM
            END IF
        END DO
        END IF
    END DO
    
    END IF
    
    ALLOCATE(POINT_MASS(TEMP_POINT_NUM), SPRING_K_E(3,TEMP_FACE_NUM), SPRING_K_D(3,TEMP_FACE_NUM), SPRING_L0(3,TEMP_FACE_NUM))
    
    POINT_MASS(:) = 0.
    DO I=1,TEMP_POINT_NUM
        DO J=1,TEMP_CONNECTION_NUM(I)
            I1 = TEMP_CONNECTION(J,I)
            POINT_MASS(I) = POINT_MASS(I) + TEMP_NEWFACEAREA(I1)/3.
        END DO
    END DO
    
    DO I=1,TEMP_FACE_NUM
        DO K=1,3
            V1 = TEMPPOINT(:,TEMPFACE(MOD(K,3)+1,I))
            V2 = TEMPPOINT(:,TEMPFACE(MOD(K+1,3)+1,I))
            
            IF(POINT_INDEX(TEMPFACE(MOD(K,3)+1,I)) .NE. 0 .OR. POINT_INDEX(TEMPFACE(MOD(K+1,3)+1,I)) .NE. 0) THEN
                SPRING_L0(K,I) = SQRT(SQRT(3.) * TEMP_NEWFACEAREA(I))
            ELSE
                SPRING_L0(K,I) = 2. * TEMP_NEWFACEAREA(I) / SQRT(DOT_PRODUCT(V1-V2,V1-V2))
            END IF
            
            SPRING_K_E(K,I) = POINT_MASS(TEMPFACE(K,I)) ! / SPRING_L0(K,I)
            SPRING_K_D(K,I) = 0.2 * POINT_MASS(TEMPFACE(K,I)) !* SPRING_L0(K,I)
        END DO
    END DO
    
    
    ITER = 1
    
    DO WHILE(.TRUE.)
    
    !! UPDATE N+1/2 TIME V
    
    A_CG(:,:) = 0.
    B_CG(:) = 0.
    X_CG(:) = 0.
    
    DO I = 1,TEMP_POINT_NUM
        IF(POINT_INDEX(I) .NE. 0) THEN
            B_CG(POINT_INDEX(I)) = V_N(1,I)
            B_CG(POINT_INDEX_NUM + POINT_INDEX(I)) = V_N(2,I)
            B_CG(2*POINT_INDEX_NUM + POINT_INDEX(I)) = V_N(3,I)
            
            IF(IMPLICIT_FLAG) THEN
            CALL INDEX_SPARSE(A_INDICES_CG,POINT_INDEX(I),POINT_INDEX(I), IDX)
            A_CG(POINT_INDEX(I), IDX) = 1.
            !A_CG(POINT_INDEX(I), A_INDICES_FULL_CG(POINT_INDEX(I), POINT_INDEX(I))) = 1.
            CALL INDEX_SPARSE(A_INDICES_CG,POINT_INDEX_NUM + POINT_INDEX(I),POINT_INDEX_NUM + POINT_INDEX(I), IDX)
            A_CG(POINT_INDEX_NUM + POINT_INDEX(I), IDX) = 1.
            !A_CG(POINT_INDEX_NUM + POINT_INDEX(I), A_INDICES_FULL_CG(POINT_INDEX_NUM + POINT_INDEX(I), POINT_INDEX_NUM + POINT_INDEX(I))) = 1.
            CALL INDEX_SPARSE(A_INDICES_CG,2*POINT_INDEX_NUM + POINT_INDEX(I),2*POINT_INDEX_NUM + POINT_INDEX(I), IDX)
            A_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), IDX) = 1.
            !A_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), A_INDICES_FULL_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), 2*POINT_INDEX_NUM + POINT_INDEX(I))) = 1.
            END IF
        END IF
    END DO
    
    IF(IMPLICIT_FLAG) THEN
    
    CALL MASS_SPRING_UPDATE_VELOCITY(X_N, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT/2., A_CG, A_INDICES_CG, B_CG, 1)
    !CALL MASS_SPRING_UPDATE_VELOCITY(X_N, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT/2., A_CG, A_INDICES_CG, A_INDICES_FULL_CG, B_CG, 1)
    CALL CG_SOLVER_SPARSE(A_CG, A_INDICES_CG, B_CG, POINT_INDEX_NUM*3, X_CG)
    
    ELSE
    
    CALL MASS_SPRING_UPDATE_VELOCITY(X_N, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT/2., A_CG, A_INDICES_CG, B_CG, 0, V_N)
    !CALL MASS_SPRING_UPDATE_VELOCITY(X_N, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT/2., A_CG, A_INDICES_CG, A_INDICES_FULL_CG, B_CG, 0, V_N)
    X_CG(:) = B_CG(:)
    
    END IF
    
    DO I = 1,TEMP_POINT_NUM
        IF(POINT_INDEX(I) .NE. 0) THEN
            V_N1(1,I) = X_CG(POINT_INDEX(I))
            V_N1(2,I) = X_CG(POINT_INDEX_NUM + POINT_INDEX(I))
            V_N1(3,I) = X_CG(2*POINT_INDEX_NUM + POINT_INDEX(I))
        END IF
    END DO
    
    CALL PROJECTING_TO_NULLSPACE(TEMP_POINT_NUM, X_N, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, V_N1)
    
    !! UPDATE N+1 TIME X
    
    DO I = 1,TEMP_POINT_NUM
        X_N1(:,I) = X_N(:,I) + DT(I) * V_N1(:,I)
    END DO
    
    
    !! EXIT CRITERION
    
    IF(ITER==SMOOTHING_NUM) EXIT
    
    
    !! UPDATE N+1 TIME V
    
    A_CG(:,:) = 0.
    B_CG(:) = 0.
    X_CG(:) = 0.
    
    DO I = 1,TEMP_POINT_NUM
        IF(POINT_INDEX(I) .NE. 0) THEN
            B_CG(POINT_INDEX(I)) = V_N(1,I)
            B_CG(POINT_INDEX_NUM + POINT_INDEX(I)) = V_N(2,I)
            B_CG(2*POINT_INDEX_NUM + POINT_INDEX(I)) = V_N(3,I)
            
            IF(IMPLICIT_FLAG) THEN
            CALL INDEX_SPARSE(A_INDICES_CG,POINT_INDEX(I),POINT_INDEX(I), IDX)
            A_CG(POINT_INDEX(I), IDX) = 1.
            !A_CG(POINT_INDEX(I), A_INDICES_FULL_CG(POINT_INDEX(I), POINT_INDEX(I))) = 1.
            CALL INDEX_SPARSE(A_INDICES_CG,POINT_INDEX_NUM + POINT_INDEX(I),POINT_INDEX_NUM + POINT_INDEX(I), IDX)
            A_CG(POINT_INDEX_NUM + POINT_INDEX(I), IDX) = 1.
            !A_CG(POINT_INDEX_NUM + POINT_INDEX(I), A_INDICES_FULL_CG(POINT_INDEX_NUM + POINT_INDEX(I), POINT_INDEX_NUM + POINT_INDEX(I))) = 1.
            CALL INDEX_SPARSE(A_INDICES_CG,2*POINT_INDEX_NUM + POINT_INDEX(I),2*POINT_INDEX_NUM + POINT_INDEX(I), IDX)
            A_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), IDX) = 1.
            !A_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), A_INDICES_FULL_CG(2*POINT_INDEX_NUM + POINT_INDEX(I), 2*POINT_INDEX_NUM + POINT_INDEX(I))) = 1.
            END IF
        END IF
    END DO
    
    IF(IMPLICIT_FLAG) THEN
    
    CALL MASS_SPRING_UPDATE_VELOCITY(X_N, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT/2., A_CG, A_INDICES_CG, B_CG, 0, V_N)
    !CALL MASS_SPRING_UPDATE_VELOCITY(X_N, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT/2., A_CG, A_INDICES_CG, A_INDICES_FULL_CG, B_CG, 0, V_N)
    CALL MASS_SPRING_UPDATE_VELOCITY(X_N1, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT/2., A_CG, A_INDICES_CG, B_CG, 1)
    !CALL MASS_SPRING_UPDATE_VELOCITY(X_N1, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT/2., A_CG, A_INDICES_CG, A_INDICES_FULL_CG, B_CG, 1)
    CALL CG_SOLVER_SPARSE(A_CG, A_INDICES_CG, B_CG, POINT_INDEX_NUM*3, X_CG)
    
    ELSE
    
    CALL MASS_SPRING_UPDATE_VELOCITY(X_N, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT/2., A_CG, A_INDICES_CG, B_CG, 0, V_N)
    !CALL MASS_SPRING_UPDATE_VELOCITY(X_N, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT/2., A_CG, A_INDICES_CG, A_INDICES_FULL_CG, B_CG, 0, V_N)
    CALL MASS_SPRING_UPDATE_VELOCITY(X_N1, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT/2., A_CG, A_INDICES_CG, B_CG, 0, V_N)
    !CALL MASS_SPRING_UPDATE_VELOCITY(X_N1, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT/2., A_CG, A_INDICES_CG, A_INDICES_FULL_CG, B_CG, 0, V_N)
    X_CG(:) = B_CG(:)
    
    END IF
    
    DO I = 1,TEMP_POINT_NUM
        IF(POINT_INDEX(I) .NE. 0) THEN
            V_N(1,I) = X_CG(POINT_INDEX(I))
            V_N(2,I) = X_CG(POINT_INDEX_NUM + POINT_INDEX(I))
            V_N(3,I) = X_CG(2*POINT_INDEX_NUM + POINT_INDEX(I))
        END IF
    END DO
    
    CALL PROJECTING_TO_NULLSPACE(TEMP_POINT_NUM, X_N, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, V_N)
    
    X_N(:,:) = X_N1(:,:)
    
    ITER = ITER + 1
    
    END DO
    
    TEMPPOINT(:,:) = X_N1(:,:)
    
    DEALLOCATE(POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0)
    
    DEALLOCATE(A_CG, A_INDICES_CG, B_CG, X_CG)
    !DEALLOCATE(A_CG, A_INDICES_CG, A_INDICES_FULL_CG, B_CG, X_CG)
    
    DEALLOCATE(V_N, V_N1, X_N, X_N1)
    
    DEALLOCATE(DT)
    
    END IF
    
    DEALLOCATE(LOCAL_SHAPE)
    
    DEALLOCATE(POINT_INDEX)
    
    END SUBROUTINE
    

    SUBROUTINE MASS_SPRING_UPDATE_VELOCITY(TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT, A_CG, A_INDICES_CG, B_CG, TYP, VELOCITY)
    !SUBROUTINE MASS_SPRING_UPDATE_VELOCITY(TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, POINT_INDEX, POINT_INDEX_NUM, POINT_MASS, SPRING_K_E, SPRING_K_D, SPRING_L0, DT, A_CG, A_INDICES_CG, A_INDICES_FULL_CG, B_CG, TYP, VELOCITY)
    IMPLICIT NONE
    
    REAL(8) :: TEMPPOINT(:,:)
    INTEGER :: TEMP_FACE_NUM
    INTEGER :: TEMPFACE(:,:)
    INTEGER :: POINT_INDEX(:)
    INTEGER :: POINT_INDEX_NUM
    REAL(8) :: POINT_MASS(:), SPRING_K_E(:,:), SPRING_K_D(:,:), SPRING_L0(:,:)
    REAL(8) :: DT(:)
    REAL(8), OPTIONAL :: VELOCITY(:,:)
    
    REAL(8) :: A_CG(:,:), B_CG(:)
    INTEGER :: A_INDICES_CG(:,:)!, A_INDICES_FULL_CG(:,:)
    
    INTEGER :: TYP ! 0 : EXPLICIT, 1 : IMPLICIT
    
    INTEGER :: I,J,K,L,M, J1,J2
    REAL(8) :: LENGTH, ELASTIC_FORCE(3), DAMPING_FORCE(3), N(3)
    REAL(8) :: V(3), V1(3), V2(3), V_INT(3), W1, W2, VEL(3), VEL1(3), VEL2(3), VEL_INT(3)
    
    INTEGER :: INDICES(9), IDX
    REAL(8) :: UPDATES(9,1), UPDATES_ARRAY(9,9)
    
    
    DO I=1,TEMP_FACE_NUM
        IF(POINT_INDEX(TEMPFACE(1,I)) .NE. 0 .OR. POINT_INDEX(TEMPFACE(2,I)) .NE. 0 .OR. POINT_INDEX(TEMPFACE(3,I)) .NE. 0) THEN
        DO K=1,3
            J = TEMPFACE(K,I)
            J1 = TEMPFACE(MOD(K,3)+1,I)
            J2 = TEMPFACE(MOD(K+1,3)+1,I)
            
            INDICES(:) = 0
            
            INDICES(1) = POINT_INDEX(J)
            IF(INDICES(1) .NE. 0) THEN
                INDICES(2) = POINT_INDEX_NUM + POINT_INDEX(J)
                INDICES(3) = 2*POINT_INDEX_NUM + POINT_INDEX(J)
            END IF
            INDICES(4) = POINT_INDEX(J1)
            IF(INDICES(4) .NE. 0) THEN
                INDICES(5) = POINT_INDEX_NUM + POINT_INDEX(J1)
                INDICES(6) = 2*POINT_INDEX_NUM + POINT_INDEX(J1)
            END IF
            INDICES(7) = POINT_INDEX(J2)
            IF(INDICES(7) .NE. 0) THEN
                INDICES(8) = POINT_INDEX_NUM + POINT_INDEX(J2)
                INDICES(9) = 2*POINT_INDEX_NUM + POINT_INDEX(J2)
            END IF
            
            V = TEMPPOINT(:,J)
            V1 = TEMPPOINT(:,J1)
            V2 = TEMPPOINT(:,J2)
            
            IF(TYP==0) THEN
                VEL = VELOCITY(:,J)
                VEL1 = VELOCITY(:,J1)
                VEL2 = VELOCITY(:,J2)
            END IF
            
            W1 = DOT_PRODUCT(V-V2,V1-V2)/DOT_PRODUCT(V1-V2,V1-V2)
            W2 = DOT_PRODUCT(V-V1,V2-V1)/DOT_PRODUCT(V2-V1,V2-V1)
            
            V_INT = W1*V1+W2*V2
            VEL_INT = W1*VEL1+W2*VEL2
            
            LENGTH = SQRT(DOT_PRODUCT(V-V_INT, V-V_INT))
            N = (V-V_INT)/LENGTH
            
            ELASTIC_FORCE = SPRING_K_E(K,I)/SPRING_L0(K,I) * (LENGTH - SPRING_L0(K,I)) * N
            
            UPDATES(1:3,1) = DT(J)/POINT_MASS(J) * (-1.) * ELASTIC_FORCE
            UPDATES(4:6,1) = DT(J1)/POINT_MASS(J1) * W1 * ELASTIC_FORCE
            UPDATES(7:9,1) = DT(J2)/POINT_MASS(J2) * W2 * ELASTIC_FORCE
            
            DO L=1,9
                IF(INDICES(L) .NE. 0) THEN
                    B_CG(INDICES(L)) = B_CG(INDICES(L)) + UPDATES(L,1)
                END IF
            END DO
            
            IF(TYP==0) THEN
                DAMPING_FORCE = SPRING_K_D(K,I)/SPRING_L0(K,I) * DOT_PRODUCT(VEL-VEL_INT, N) * N
                
                UPDATES(1:3,1) = DT(J)/POINT_MASS(J) * (-1.) * DAMPING_FORCE
                UPDATES(4:6,1) = DT(J1)/POINT_MASS(J1) * W1 * DAMPING_FORCE
                UPDATES(7:9,1) = DT(J2)/POINT_MASS(J2) * W2 * DAMPING_FORCE
                
                DO L=1,9
                    IF(INDICES(L) .NE. 0) THEN
                        B_CG(INDICES(L)) = B_CG(INDICES(L)) + UPDATES(L,1)
                    END IF
                END DO
            ELSE IF(TYP==1) THEN
                UPDATES(1:3,1) = -N
                UPDATES(4:6,1) = W1*N
                UPDATES(7:9,1) = W2*N
                
                UPDATES_ARRAY = - SPRING_K_D(K,I)/SPRING_L0(K,I) * MATMUL(UPDATES, TRANSPOSE(UPDATES))
                
                UPDATES_ARRAY(1:3,:) = DT(J)/POINT_MASS(J) * UPDATES_ARRAY(1:3,:)
                UPDATES_ARRAY(4:6,:) = DT(J1)/POINT_MASS(J1) * UPDATES_ARRAY(4:6,:)
                UPDATES_ARRAY(7:9,:) = DT(J2)/POINT_MASS(J2) * UPDATES_ARRAY(7:9,:)
                
                DO L=1,9
                    DO M=1,9
                        IF(INDICES(L) .NE. 0 .AND. INDICES(M) .NE. 0) THEN
                            CALL INDEX_SPARSE(A_INDICES_CG,INDICES(L),INDICES(M), IDX)
                            A_CG(INDICES(L), IDX) = A_CG(INDICES(L), IDX) - UPDATES_ARRAY(L,M)
                            !A_CG(INDICES(L), A_INDICES_FULL_CG(INDICES(L), INDICES(M))) = A_CG(INDICES(L), A_INDICES_FULL_CG(INDICES(L), INDICES(M))) - UPDATES_ARRAY(L,M)
                        END IF
                    END DO
                END DO
            END IF
        END DO
        END IF
    END DO
    
    END SUBROUTINE


    SUBROUTINE PROJECTING_TO_NULLSPACE(TEMP_POINT_NUM, TEMPPOINT, TEMP_FACE_NUM, TEMPFACE, TEMP_CONNECTION_NUM, TEMP_CONNECTION, TEMPINITIALPOINT_TYPE, DISPLACEMENT)
    IMPLICIT NONE
    INTEGER :: TEMP_POINT_NUM
    REAL(8) :: TEMPPOINT(3,TEMP_POINT_NUM)
    INTEGER :: TEMP_FACE_NUM
    INTEGER :: TEMPFACE(3,TEMP_FACE_NUM)
    INTEGER :: TEMP_CONNECTION(:,:)
    INTEGER :: TEMP_CONNECTION_NUM(:)
    INTEGER :: TEMPINITIALPOINT_TYPE(:)
    REAL(8) :: DISPLACEMENT(3,TEMP_POINT_NUM)
    
    REAL(8), ALLOCATABLE :: BEFORE_DISPLACEMENT(:,:)
    INTEGER :: I,J,K,L, CON_NUM
    REAL(8) :: V1(3),V2(3)
    REAL(8), ALLOCATABLE :: NORMAL(:,:), FACE_AREA(:)
    INTEGER :: LOCAL_SHAPE, JMIN
    
    REAL(8), ALLOCATABLE :: N(:,:), W(:), T(:,:)
    REAL(8) :: W_SUM
    REAL(8) :: R
    REAL(8) :: E_VALUE(3)
    REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
    REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
    REAL(8) :: TT(3,3)

    
    ALLOCATE(BEFORE_DISPLACEMENT(3,TEMP_POINT_NUM))
    ALLOCATE(FACE_AREA(TEMP_FACE_NUM))
    ALLOCATE(NORMAL(3,TEMP_FACE_NUM))
    
    BEFORE_DISPLACEMENT(:,:) = DISPLACEMENT(:,:)
    
    DISPLACEMENT(:,:) = 0.

    DO I=1,TEMP_FACE_NUM
        V1 = TEMPPOINT(:,TEMPFACE(2,I)) - TEMPPOINT(:,TEMPFACE(1,I))
        V2 = TEMPPOINT(:,TEMPFACE(3,I)) - TEMPPOINT(:,TEMPFACE(1,I))
        
        CALL VEC_CURL1(V1,V2, NORMAL(:,I))

        R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))
        FACE_AREA(I) = R/2.
        NORMAL(:,I) = NORMAL(:,I) / R
    END DO

    DO I=1,TEMP_POINT_NUM
        IF(SQRT(DOT_PRODUCT(BEFORE_DISPLACEMENT(:,I), BEFORE_DISPLACEMENT(:,I))) > MINERROR) THEN
            CON_NUM = TEMP_CONNECTION_NUM(I)

            ALLOCATE(N(CON_NUM,3))
            ALLOCATE(W(CON_NUM))

            W_SUM = 0.

            DO J = 1,CON_NUM
                W_SUM = W_SUM + FACE_AREA(TEMP_CONNECTION(J,I))
            END DO

            DO J = 1,CON_NUM
                N(J,:) = NORMAL(:,TEMP_CONNECTION(J,I))
                W(J) = FACE_AREA(TEMP_CONNECTION(J,I)) / W_SUM
            END DO

            DO K=1,3
                DO L=1,3
                    E_VECTOR(K,L) = 0.
                    DO J = 1,CON_NUM
                        E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                    END DO
                END DO
            END DO

            ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX

            CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)

            DO J=1,3-1
                JMIN = J
                DO K=J+1,3
                    IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                        JMIN = K
                    END IF
                END DO

                IF(J .NE. JMIN) THEN
                    TEMP_E_VALUE = E_VALUE(J)
                    TEMP_E_VECTOR = E_VECTOR(:,J)

                    E_VALUE(J) = E_VALUE(JMIN)
                    E_VECTOR(:,J) = E_VECTOR(:,JMIN)

                    E_VALUE(JMIN) = TEMP_E_VALUE
                    E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
                END IF
            END DO

            LOCAL_SHAPE = TEMPINITIALPOINT_TYPE(I)

            IF(LOCAL_SHAPE .NE. 3) THEN

            ALLOCATE(T(3,3-LOCAL_SHAPE))

            DO J = LOCAL_SHAPE+1, 3
                T(:,J-LOCAL_SHAPE) = E_VECTOR(:,J)
            END DO

            DO K=1,3
                DO L=1,3
                    TT(K,L) = 0.
                    DO J=1,3-LOCAL_SHAPE
                        TT(K,L) = TT(K,L) + T(K,J)*T(L,J)    
                    END DO
                END DO
            END DO

            DISPLACEMENT(:,I) = 0.
            DO K = 1,3
                DO L = 1,3
                    DISPLACEMENT(K,I) = DISPLACEMENT(K,I) + TT(K,L)*BEFORE_DISPLACEMENT(L,I)
                END DO
            END DO
            DEALLOCATE(T)

            END IF

            DEALLOCATE(N)
            DEALLOCATE(W)
        END IF
    END DO

    DEALLOCATE(NORMAL)
    DEALLOCATE(FACE_AREA)
    DEALLOCATE(BEFORE_DISPLACEMENT)

    END SUBROUTINE
    
    SUBROUTINE FACEOFFSETTING_3D(TYP, TIMESTEP)
        IMPLICIT NONE
        INTEGER :: TYP
        REAL(8) :: TIMESTEP, LEFT_TIMESTEP, RESULT_TIMESTEP

        TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
        
        IF (TYP==0) THEN
            SURFACE_CURRENT => SURFACE_FLUID
        END IF
        IF (TYP==1) THEN
            SURFACE_CURRENT => SURFACE_PROPEL
        END IF
        IF (TYP==2) THEN
            SURFACE_CURRENT => SURFACE_CASE
        END IF

        LEFT_TIMESTEP = TIMESTEP
        RESULT_TIMESTEP = 0.
        DO WHILE(LEFT_TIMESTEP .NE. RESULT_TIMESTEP)
            LEFT_TIMESTEP = LEFT_TIMESTEP - RESULT_TIMESTEP
            CALL WAVEFRONT_DISPLACEMENT(TYP, LEFT_TIMESTEP, RESULT_TIMESTEP)
        END DO      
 
    END SUBROUTINE FACEOFFSETTING_3D

    
    
    SUBROUTINE ATTACH_TWO_RIDGES(FLUID_RIDGE_FLAG, CASE_RIDGE_FLAG)
    IMPLICIT NONE
    INTEGER :: FLUID_RIDGE_FLAG
    INTEGER :: CASE_RIDGE_FLAG
    INTEGER, ALLOCATABLE :: FLUID_RIDGE(:)
    INTEGER, ALLOCATABLE :: CASE_RIDGE(:)
    INTEGER :: FLUID_RIDGE_NUM
    INTEGER :: CASE_RIDGE_NUM

    ALLOCATE(FLUID_RIDGE(SURFACE_FLUID%SURFACE_POINTS_NUM))
    ALLOCATE(CASE_RIDGE(SURFACE_CASE%SURFACE_POINTS_NUM))

    CALL FIND_RIDGE_ARRAY_TYPE(0, FLUID_RIDGE_FLAG, FLUID_RIDGE, FLUID_RIDGE_NUM)
    CALL FIND_RIDGE_ARRAY_TYPE(2, CASE_RIDGE_FLAG, CASE_RIDGE, CASE_RIDGE_NUM)

    DEALLOCATE(FLUID_RIDGE)
    DEALLOCATE(CASE_RIDGE)

    END SUBROUTINE ATTACH_TWO_RIDGES

    
    
    SUBROUTINE MAINTAIN_CASE_CORNER()
    IMPLICIT NONE
    INTEGER :: I, J, K, I1
    INTEGER :: JMIN
    REAL(8) :: R, RMIN
    LOGICAL :: B, C

    DO I = 1,SURFACE_CASE%SURFACE_POINTS_NUM
        IF(SURFACE_CASE%POINT_TYPE(I)==3 .OR. SURFACE_CASE%POINT_TYPE(I)==6) THEN
            B = .TRUE.
            DO J=1,SURFACE_CASE%POINT_FACE_CONNECTION_NUM(I)
                I1 = SURFACE_CASE%POINT_FACE_CONNECTION(J,I)
                IF(SURFACE_CASE%FACE_ONINTERFACE(I1) .NE. 0) THEN
                    B = .FALSE.
                END IF
            END DO
            IF(B) THEN
                RMIN = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
                JMIN = 0
                DO J = 1,SURFACE_FLUID%SURFACE_POINTS_NUM
                    C = .FALSE.
                    DO K = 1,SURFACE_CASE%POINT_FACE_CONNECTION_NUM(I)
                        IF(SURFACE_FLUID%POINT_RELATEDFACE(2+1,J)==SURFACE_CASE%POINT_FACE_CONNECTION(K,I)) THEN
                            C = .TRUE.
                        END IF
                    END DO
                    IF(SURFACE_FLUID%POINT_TYPE(J) .NE. 4 .AND. C) THEN
                        R = SQRT(DOT_PRODUCT(SURFACE_CASE%SURFACE_POINTS(:,I) - SURFACE_FLUID%SURFACE_POINTS(:,J), SURFACE_CASE%SURFACE_POINTS(:,I) - SURFACE_FLUID%SURFACE_POINTS(:,J) ))
                        IF(R<RMIN) THEN
                            RMIN = R
                            JMIN = J
                        END IF
                    END IF
                END DO
                IF(JMIN.NE.0) THEN
                    SURFACE_FLUID%SURFACE_POINTS(:,JMIN) = SURFACE_CASE%SURFACE_POINTS(:,I)
                END IF
            END IF
        END IF
    END DO

    END SUBROUTINE MAINTAIN_CASE_CORNER

    
    
    SUBROUTINE GENERATE_FACES_CASE(POINT_NUM, POINT, FACE_NUM, FACE, NEW_FACE)
    IMPLICIT NONE
    INTEGER :: POINT_NUM
    REAL(8) :: POINT(3,POINT_NUM)
    INTEGER :: FACE_NUM
    INTEGER :: FACE(4,FACE_NUM)
    INTEGER :: NEW_FACE(3,2*FACE_NUM)
    INTEGER :: I
    REAL(8) :: V1(3),V2(3),V3(3),V4(3), R1, R2
    REAL(8) :: S, F_SIZE_SHAPE, F_SIZE, F_SHAPE, F_SIZE_SHAPE1, F_SIZE1, F_SHAPE1, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW, F_SIZE_SHAPE1_NEW, F_SIZE1_NEW, F_SHAPE1_NEW, QUALITY_BEFORE, QUALITY_AFTER, N(3), N1(3), N_NEW(3), N1_NEW(3)


    DO I=1,FACE_NUM
        V1 = POINT(:,FACE(1,I))
        V2 = POINT(:,FACE(2,I))
        V3 = POINT(:,FACE(3,I))
        V4 = POINT(:,FACE(4,I))

        R1 = SQRT(DOT_PRODUCT(V3-V1,V3-V1))
        R2 = SQRT(DOT_PRODUCT(V4-V2,V4-V2))

        S = 1.

        CALL MESH_QUALITY_TRIANGLE_ONE(V1,V2,V3, S, F_SIZE_SHAPE, F_SIZE, F_SHAPE)
        CALL MESH_QUALITY_TRIANGLE_ONE(V1,V3,V4, S, F_SIZE_SHAPE1, F_SIZE1, F_SHAPE1)

        CALL TRIANGLE_NORMAL(V1,V2,V3, N)
        CALL TRIANGLE_NORMAL(V1,V3,V4, N1)

        CALL MESH_QUALITY_TRIANGLE_ONE(V2,V3,V4, S, F_SIZE_SHAPE_NEW, F_SIZE_NEW, F_SHAPE_NEW)
        CALL MESH_QUALITY_TRIANGLE_ONE(V2,V4,V1, S, F_SIZE_SHAPE1_NEW, F_SIZE1_NEW, F_SHAPE1_NEW)

        CALL TRIANGLE_NORMAL(V2,V3,V4, N_NEW)
        CALL TRIANGLE_NORMAL(V2,V4,V1, N1_NEW)

        IF(DOT_PRODUCT(N,N1)<0) THEN
            F_SHAPE = 0.
            F_SHAPE1 = 0.
        END IF
        IF(DOT_PRODUCT(N_NEW,N1_NEW)<0) THEN
            F_SHAPE_NEW = 0.
            F_SHAPE1_NEW = 0.
        END IF

        QUALITY_BEFORE = 1./(F_SHAPE+MINERROR) + 1./(F_SHAPE1+MINERROR)
        QUALITY_AFTER = 1./(F_SHAPE_NEW+MINERROR) + 1./(F_SHAPE1_NEW+MINERROR)

        IF(QUALITY_BEFORE < QUALITY_AFTER) THEN !IF(R1<R2) THEN
            NEW_FACE(1,2*I-1) = FACE(3,I)
            NEW_FACE(2,2*I-1) = FACE(2,I)
            NEW_FACE(3,2*I-1) = FACE(1,I)

            NEW_FACE(1,2*I) = FACE(3,I)
            NEW_FACE(2,2*I) = FACE(1,I)
            NEW_FACE(3,2*I) = FACE(4,I)

            !NEW_FACE(1,2*I-1) = FACE(1,I)
            !NEW_FACE(2,2*I-1) = FACE(2,I)
            !NEW_FACE(3,2*I-1) = FACE(3,I)

            !NEW_FACE(1,2*I) = FACE(1,I)
            !NEW_FACE(2,2*I) = FACE(3,I)
            !NEW_FACE(3,2*I) = FACE(4,I)
        ELSE
            NEW_FACE(1,2*I-1) = FACE(4,I)
            NEW_FACE(2,2*I-1) = FACE(3,I)
            NEW_FACE(3,2*I-1) = FACE(2,I)

            NEW_FACE(1,2*I) = FACE(4,I)
            NEW_FACE(2,2*I) = FACE(2,I)
            NEW_FACE(3,2*I) = FACE(1,I)

            !NEW_FACE(1,2*I-1) = FACE(2,I)
            !NEW_FACE(2,2*I-1) = FACE(3,I)
            !NEW_FACE(3,2*I-1) = FACE(4,I)

            !NEW_FACE(1,2*I) = FACE(2,I)
            !NEW_FACE(2,2*I) = FACE(4,I)
            !NEW_FACE(3,2*I) = FACE(1,I)
        END IF
    END DO

    END SUBROUTINE GENERATE_FACES_CASE

    
    
    SUBROUTINE GENERATE_LOCATION_CASE(LOC_NUM, OLD_LOC, NEW_LOC)
    IMPLICIT NONE
    INTEGER :: LOC_NUM
    INTEGER :: OLD_LOC(LOC_NUM)
    INTEGER :: NEW_LOC(2*LOC_NUM)
    INTEGER :: I

    DO I=1,LOC_NUM
        NEW_LOC(2*I-1) = OLD_LOC(I)
        NEW_LOC(2*I) = OLD_LOC(I)
    END DO
    END SUBROUTINE GENERATE_LOCATION_CASE
    END MODULE PROPA_RECONST_REINITIAL_3D
