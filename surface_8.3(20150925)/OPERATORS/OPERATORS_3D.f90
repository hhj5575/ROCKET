    MODULE OPERATORS_3D

    USE SURFACE_MODULE_3D
    USE SURFACES_3D
    USE SVD
    USE HASHING_3D

    IMPLICIT NONE

    CONTAINS


    SUBROUTINE DISTANCE_SURFACE_POINT_TYPE(V,TYP,RET)
    IMPLICIT NONE
    REAL(8) :: V(3)
    INTEGER :: TYP
    REAL(8) :: RET
    TYPE(HASH) :: HASH0

    CALL SET_HASH_TYP(TYP, 2, HASH0)

    CALL DISTANCE_SURFACE_POINT_HASH(V,HASH0,RET)

    CALL REMOVE_HASH(HASH0)
    END SUBROUTINE
    
    
    SUBROUTINE DISTANCE_SURFACE_POINT_HASH(V,HASH0,RET)
    IMPLICIT NONE
    REAL(8) :: V(3)
    TYPE(HASH) :: HASH0
    REAL(8) :: RET
    TYPE(HASH_ELEMENT), POINTER :: ELEMENT_CURRENT
    INTEGER :: INDEX1, INDEX2, INDEX3
    INTEGER :: I0
    REAL(8) :: V1(3), V2(3), V3(3), DIST
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (HASH0%TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (HASH0%TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (HASH0%TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    RET = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))

    CALL FIND_HASH_INDEX(HASH0, V, INDEX1, INDEX2, INDEX3)

    ELEMENT_CURRENT => HASH0%ELEMENT(INDEX1,INDEX2,INDEX3)%HEAD
    DO WHILE(ASSOCIATED(ELEMENT_CURRENT))
        I0 = ELEMENT_CURRENT%I0
        V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,I0))
        V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,I0))
        V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,I0))
        CALL UNSIGNED_DISTANCE_FACE_POINT(V, V1, V2, V3, DIST)

        IF (DIST <= RET) THEN
            RET = DIST
        END IF

        ELEMENT_CURRENT => ELEMENT_CURRENT%NEXT
    END DO
    NULLIFY(ELEMENT_CURRENT)

    NULLIFY(SURFACE_CURRENT)
    END SUBROUTINE DISTANCE_SURFACE_POINT_HASH


    
    SUBROUTINE DISTANCE_SURFACE_FACE_TYPE(I0,TYP1,TYP2,DIR,  R,IDX)
    IMPLICIT NONE
    INTEGER :: I0
    INTEGER :: TYP1, TYP2
    INTEGER :: DIR, IDX
    REAL(8) :: R
    TYPE(HASH) :: HASH0

    CALL SET_HASH_TYP(TYP2, 2, HASH0)

    CALL DISTANCE_SURFACE_FACE_HASH(I0,TYP1,HASH0,DIR,R,IDX)

    CALL REMOVE_HASH(HASH0)
    END SUBROUTINE

    
    
    SUBROUTINE DISTANCE_SURFACE_FACE_HASH(I0,TYP1,HASH0,DIR,R,IDX)
    IMPLICIT NONE
    INTEGER :: I0
    INTEGER :: TYP1
    TYPE(HASH) :: HASH0
    INTEGER :: DIR, IDX
    REAL(8) :: R
    TYPE(HASH_ELEMENT), POINTER :: ELEMENT_CURRENT
    INTEGER :: INDEX1, INDEX2, INDEX3
    INTEGER :: I1
    REAL(8) :: THRESH
    REAL(8) :: V1(3), V2(3), V3(3), V(3), W1(3), W2(3), L(3), ERR, T
    INTEGER :: SGN
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT1, SURFACE_CURRENT2

    IF (TYP1==0) THEN
        SURFACE_CURRENT1 => SURFACE_FLUID
    END IF
    IF (TYP1==1) THEN
        SURFACE_CURRENT1 => SURFACE_PROPEL
    END IF
    IF (TYP1==2) THEN
        SURFACE_CURRENT1 => SURFACE_CASE
    END IF

    IF (HASH0%TYP==0) THEN
        SURFACE_CURRENT2 => SURFACE_FLUID
    END IF
    IF (HASH0%TYP==1) THEN
        SURFACE_CURRENT2 => SURFACE_PROPEL
    END IF
    IF (HASH0%TYP==2) THEN
        SURFACE_CURRENT2 => SURFACE_CASE
    END IF

    R = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
    IDX = 0

    V1 = SURFACE_CURRENT1%SURFACE_POINTS(:,SURFACE_CURRENT1%SURFACE_FACES(1,I0))
    V2 = SURFACE_CURRENT1%SURFACE_POINTS(:,SURFACE_CURRENT1%SURFACE_FACES(2,I0))
    V3 = SURFACE_CURRENT1%SURFACE_POINTS(:,SURFACE_CURRENT1%SURFACE_FACES(3,I0))

    THRESH = (SQRT(DOT_PRODUCT(V2-V1,V2-V1)) + SQRT(DOT_PRODUCT(V3-V2,V3-V2)) + SQRT(DOT_PRODUCT(V3-V1,V3-V1)))/3.

    CALL RANDOM_NUMBER(ERR)
    V = (1./3. - 0.000001 * ERR) * V1 + (1./3. + 0.000001 * ERR) * V2 + 1./3. * V3
    W1 = V2-V1
    W2 = V3-V1
    CALL VEC_CURL1(W1, W2, L)

    L = L/SQRT(DOT_PRODUCT(L,L))

    IF(DIR==0) THEN
        L = -L
    END IF

    CALL FIND_HASH_INDEX(HASH0, V, INDEX1, INDEX2, INDEX3)

    ELEMENT_CURRENT => HASH0%ELEMENT(INDEX1,INDEX2,INDEX3)%HEAD
    DO WHILE(ASSOCIATED(ELEMENT_CURRENT))
        I1 = ELEMENT_CURRENT%I0
        IF(TYP1==HASH0%TYP .AND. I0==I1) THEN
        ELSE
            CALL LINE_FACE_INTERSECTING(SURFACE_CURRENT2%SURFACE_POINTS_NUM, SURFACE_CURRENT2%SURFACE_POINTS, SURFACE_CURRENT2%SURFACE_FACES_NUM, SURFACE_CURRENT2%SURFACE_FACES,I1,L,V,SGN,T)

            IF (SGN.NE.-2 .AND. SGN.NE.-3 .AND. T > -1.*THRESH .AND. ABS(T) < ABS(R)) THEN
                R = T
                IDX = I1
            END IF
        END IF

        ELEMENT_CURRENT => ELEMENT_CURRENT%NEXT
    END DO
    NULLIFY(ELEMENT_CURRENT)

    NULLIFY(SURFACE_CURRENT1)
    NULLIFY(SURFACE_CURRENT2)
    END SUBROUTINE DISTANCE_SURFACE_FACE_HASH

    
    
    SUBROUTINE DISTANCE_FACE_FACE_TYPE(I0,TYP1,J0,TYP2,DIR,  R,B, WEIGHT1, WEIGHT2, WEIGHT3)
    IMPLICIT NONE
    INTEGER :: TYP1, TYP2
    INTEGER :: I0, J0, DIR
    LOGICAL :: B
    REAL(8) :: R
    REAL(8), OPTIONAL :: WEIGHT1, WEIGHT2, WEIGHT3
    !INTEGER :: N1
    REAL(8) :: V1(3), V2(3), V3(3), V(3), W1(3), W2(3), L(3), ERR
    INTEGER :: SGN
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT1
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT2

    
    IF (TYP1==0) THEN
        SURFACE_CURRENT1 => SURFACE_FLUID
    END IF
    IF (TYP1==1) THEN
        SURFACE_CURRENT1 => SURFACE_PROPEL
    END IF
    IF (TYP1==2) THEN
        SURFACE_CURRENT1 => SURFACE_CASE
    END IF

    IF (TYP2==0) THEN
        SURFACE_CURRENT2 => SURFACE_FLUID
    END IF
    IF (TYP2==1) THEN
        SURFACE_CURRENT2 => SURFACE_PROPEL
    END IF
    IF (TYP2==2) THEN
        SURFACE_CURRENT2 => SURFACE_CASE
    END IF

    IF(TYP1==TYP2 .AND. I0==J0) THEN
        R = 0.
        B = .FALSE.
        RETURN
    END IF

    V1 = SURFACE_CURRENT1%SURFACE_POINTS(:,SURFACE_CURRENT1%SURFACE_FACES(1,I0))
    V2 = SURFACE_CURRENT1%SURFACE_POINTS(:,SURFACE_CURRENT1%SURFACE_FACES(2,I0))
    V3 = SURFACE_CURRENT1%SURFACE_POINTS(:,SURFACE_CURRENT1%SURFACE_FACES(3,I0))

    IF(PRESENT(WEIGHT1)) THEN
        V = WEIGHT1 * V1 + WEIGHT2 * V2 + WEIGHT3 * V3
    ELSE
        CALL RANDOM_NUMBER(ERR)
        V = (1./3. - 0.000001 * ERR) * V1 + (1./3. + 0.000001 * ERR) * V2 + 1./3. * V3
    END IF

    W1 = V2-V1
    W2 = V3-V1
    CALL VEC_CURL1(W1, W2, L)

    L = L/SQRT(DOT_PRODUCT(L,L))

    IF(DIR==0) THEN
        L = -L
    END IF

    CALL LINE_FACE_INTERSECTING(SURFACE_CURRENT2%SURFACE_POINTS_NUM, SURFACE_CURRENT2%SURFACE_POINTS, SURFACE_CURRENT2%SURFACE_FACES_NUM, SURFACE_CURRENT2%SURFACE_FACES,J0,L,V,SGN,R)

    IF (SGN.NE.-2 .AND. SGN.NE.-3 .AND. R > -1.*(SQRT(DOT_PRODUCT(V2-V1,V2-V1)) + SQRT(DOT_PRODUCT(V3-V2,V3-V2)) + SQRT(DOT_PRODUCT(V3-V1,V3-V1)))/3.) THEN
        B = .TRUE.
    ELSE
        B = .FALSE.
    END IF

    NULLIFY(SURFACE_CURRENT1)
    NULLIFY(SURFACE_CURRENT2)
    END SUBROUTINE DISTANCE_FACE_FACE_TYPE

    
    
    SUBROUTINE FIND_IMPACT_ZONE(TYP1, TYP2)
    IMPLICIT NONE
    INTEGER :: TYP1, TYP2
    TYPE(HASH) :: HASH0

    CALL SET_HASH_TYP(TYP2, 2, HASH0)

    CALL FIND_IMPACT_ZONE_HASH(TYP1, HASH0)

    CALL REMOVE_HASH(HASH0)
    END SUBROUTINE FIND_IMPACT_ZONE


    
    SUBROUTINE FIND_IMPACT_ZONE_HASH(TYP1, HASH0)
    IMPLICIT NONE
    INTEGER :: TYP1
    TYPE(HASH) :: HASH0
    INTEGER :: I, IDX, DIR, J, K, I1
    REAL(8) :: R
    LOGICAL :: B
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP1==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP1==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP1==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    IF(TYP1==HASH0%TYP) THEN
        DIR = 0
    ELSE
        DIR = 1
    END IF

    SURFACE_CURRENT%FACE_IMPACT_ZONE(HASH0%TYP+1, :) = 0

    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        CALL DISTANCE_SURFACE_FACE_HASH(I,TYP1,HASH0,DIR,R,IDX)

        B = .TRUE.

        DO J=1,3
            DO K=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(SURFACE_CURRENT%SURFACE_FACES(J,I))
                I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(K,SURFACE_CURRENT%SURFACE_FACES(J,I))
                IF(IDX==I1) THEN
                    B = .FALSE.
                END IF
            END DO
        END DO

        IF(B) THEN
            SURFACE_CURRENT%FACE_IMPACT_ZONE(HASH0%TYP+1, I) = IDX
        END IF
    END DO

    NULLIFY(SURFACE_CURRENT)
    END SUBROUTINE FIND_IMPACT_ZONE_HASH


    
    SUBROUTINE UPDATE_IMPACT_ZONE(TYP1, TYP2)
    IMPLICIT NONE
    INTEGER :: TYP1, TYP2
    INTEGER :: I, J, K, DIR, I1, IPZ
    REAL(8) :: R
    LOGICAL :: B, FLAG
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT1, SURFACE_CURRENT2

    IF (TYP1==0) THEN
        SURFACE_CURRENT1 => SURFACE_FLUID
    END IF
    IF (TYP1==1) THEN
        SURFACE_CURRENT1 => SURFACE_PROPEL
    END IF
    IF (TYP1==2) THEN
        SURFACE_CURRENT1 => SURFACE_CASE
    END IF

    IF (TYP2==0) THEN
        SURFACE_CURRENT2 => SURFACE_FLUID
    END IF
    IF (TYP2==1) THEN
        SURFACE_CURRENT2 => SURFACE_PROPEL
    END IF
    IF (TYP2==2) THEN
        SURFACE_CURRENT2 => SURFACE_CASE
    END IF

    IF(TYP1==TYP2) THEN
        DIR = 0
    ELSE
        DIR = 1
    END IF

    DO I=1,SURFACE_CURRENT1%SURFACE_FACES_NUM
        IPZ = SURFACE_CURRENT1%FACE_IMPACT_ZONE(TYP2+1, I)

        FLAG = .FALSE.
        IF(IPZ==0) THEN
            FLAG = .TRUE.
        ELSE
            DO J=1,3
                DO K=1,SURFACE_CURRENT2%POINT_FACE_CONNECTION_NUM(SURFACE_CURRENT2%SURFACE_FACES(J,IPZ))
                    I1 = SURFACE_CURRENT2%POINT_FACE_CONNECTION(K,SURFACE_CURRENT2%SURFACE_FACES(J,IPZ))

                    CALL DISTANCE_FACE_FACE_TYPE(I,TYP1,I1,TYP2,DIR,  R,B)

                    IF(B) THEN
                        SURFACE_CURRENT1%FACE_IMPACT_ZONE(TYP2+1, I) = I1
                        FLAG = .TRUE.
                        EXIT
                    END IF
                END DO

                IF(FLAG) THEN
                    EXIT
                END IF
            END DO
        END IF

        IF(.NOT. FLAG) THEN
            SURFACE_CURRENT1%FACE_IMPACT_ZONE(TYP2+1, I) = 0
        END IF
    END DO

    END SUBROUTINE UPDATE_IMPACT_ZONE

    
    
    SUBROUTINE POINT_FACE_CONNECTING_TYPE(TYP)
    IMPLICIT NONE
    INTEGER::TYP
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    CALL POINT_FACE_CONNECTING(SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION)

    END SUBROUTINE POINT_FACE_CONNECTING_TYPE

    
    
    SUBROUTINE POINT_FACE_CONNECTING(POINT_NUM, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION)
    IMPLICIT NONE
    INTEGER :: POINT_NUM
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: I, I1,I2, J,J0,J1, K, TEMP
    INTEGER, ALLOCATABLE :: POINT_INDEX(:)


    CONNECTION_NUM = 0


    DO I=1,FACE_NUM
        ! Should modify for square case
        !IF(TYP==0) THEN
        DO J=1,3
            CONNECTION_NUM(FACE(J,I)) = CONNECTION_NUM(FACE(J,I)) + 1
            CONNECTION(CONNECTION_NUM(FACE(J,I)),FACE(J,I)) = I
        END DO
        !ELSE
        !    DO J=1,4
        !        CONNECTION_NUM(FACE(J,I)) = CONNECTION_NUM(FACE(J,I)) + 1
        !        CONNECTION(CONNECTION_NUM(FACE(J,I)),FACE(J,I)) = I
        !    END DO
        !END IF
    END DO

    DO I=1,POINT_NUM      
        ALLOCATE(POINT_INDEX(CONNECTION_NUM(I)))
        DO J=1,CONNECTION_NUM(I)
            J0 = CONNECTION(J,I)
            DO K=1,3
                IF(FACE(K,J0)==I) THEN
                    POINT_INDEX(J) = K
                    EXIT
                END IF
            END DO
        END DO

        DO J=1,CONNECTION_NUM(I)
            J0 = CONNECTION(J,I)
            I1 = FACE(MOD(POINT_INDEX(J)+1,3)+1, J0)
            DO K=J+1,CONNECTION_NUM(I)
                J1 = CONNECTION(K,I)
                I2 = FACE(MOD(POINT_INDEX(K),3)+1, J1)
                IF(I1==I2) THEN
                    TEMP = CONNECTION(J+1,I)
                    CONNECTION(J+1,I) = CONNECTION(K,I)
                    CONNECTION(K,I) = TEMP

                    TEMP = POINT_INDEX(J+1)
                    POINT_INDEX(J+1) = POINT_INDEX(K)
                    POINT_INDEX(K) = TEMP

                    EXIT
                END IF
            END DO
        END DO
        DEALLOCATE(POINT_INDEX)
    END DO

    END SUBROUTINE POINT_FACE_CONNECTING

    
    
    SUBROUTINE FIND_POINT_TYPE(TYP, RETURN_RIDGE_EDGE)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL, OPTIONAL :: RETURN_RIDGE_EDGE(:,:)
    REAL(8), ALLOCATABLE :: FACE_AREA(:)
    INTEGER :: I,J,K,L, TEMP_I
    INTEGER :: I1,I2,I3
    REAL(8) :: V1(3),V2(3),R
    REAL(8), ALLOCATABLE :: NORMAL(:,:)
    INTEGER :: CON_NUM
    REAL(8), ALLOCATABLE :: N(:,:), W(:)
    REAL(8) :: W_SUM
    REAL(8) :: E_VALUE(3)
    REAL(8) :: E_VECTOR(3,3), DUMMY(3,3)
    INTEGER :: JMIN
    REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
    REAL(8) :: THETA_A, PHI_C, PHI_R, CHI_C, CHI_R
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    ALLOCATE(FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_FACES_NUM))

    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM

    I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
    I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
    I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)

    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)

    CALL VEC_CURL1(V1,V2, NORMAL(:,I))

    R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))

    FACE_AREA(I) = R/2.

    NORMAL(:,I) = NORMAL(:,I) / R

    END DO

    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM         
        CON_NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)

        ALLOCATE(N(CON_NUM,3))
        ALLOCATE(W(CON_NUM))

        W_SUM = 0.
        THETA_A = 0.
        DO J = 1,CON_NUM
            W_SUM = W_SUM + FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))

            I1 = SURFACE_CURRENT%SURFACE_FACES(1,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
            I2 = SURFACE_CURRENT%SURFACE_FACES(2,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
            I3 = SURFACE_CURRENT%SURFACE_FACES(3,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))

            IF(I==I1) THEN
            ELSE IF(I==I2) THEN
                TEMP_I = I1
                I1 = I2
                I2 = I3
                I3 = TEMP_I
            ELSE
                TEMP_I = I1
                I1 = I3
                I3 = I2
                I2 = TEMP_I
            END IF

            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
        END DO

        DO J = 1,CON_NUM
            N(J,:) = NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
            W(J) = FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) / W_SUM
        END DO

        DO K=1,3
            DO L=1,3
                E_VECTOR(K,L) = 0.
                DO J = 1,CON_NUM
                    E_VECTOR(K,L) = E_VECTOR(K,L) + W(J)*N(J,K)*N(J,L)
                END DO
            END DO
        END DO

        ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX

        CALL SVDCMP_ROUTINE(E_VECTOR,3,3,3,3,E_VALUE,DUMMY)

        DO J=1,3-1
            JMIN = J
            DO K=J+1,3
                IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                    JMIN = K
                END IF
            END DO

            IF(J .NE. JMIN) THEN
                TEMP_E_VALUE = E_VALUE(J)
                TEMP_E_VECTOR = E_VECTOR(:,J)

                E_VALUE(J) = E_VALUE(JMIN)
                E_VECTOR(:,J) = E_VECTOR(:,JMIN)

                E_VALUE(JMIN) = TEMP_E_VALUE
                E_VECTOR(:,JMIN) = TEMP_E_VECTOR(:)
            END IF
        END DO

        THETA_A = THETA_A - 2.*PI

        PHI_R = 14. * PI/180.
        PHI_C = 45. * PI/180.

        CHI_R = 2.*(TAN(PHI_R/2.))**2
        CHI_C = 2.*(TAN(PHI_C/2.))**2

        IF(E_VALUE(3)/E_VALUE(1) > CHI_C .OR. ABS(THETA_A) >= PI/2.) THEN
            SURFACE_CURRENT%POINT_TYPE(I) = 3
        ELSE IF(E_VALUE(2)/E_VALUE(1) > CHI_R) THEN
            SURFACE_CURRENT%POINT_TYPE(I) = 2
        ELSE
            SURFACE_CURRENT%POINT_TYPE(I) = 1
        END IF

        DEALLOCATE(N)
        DEALLOCATE(W)

    END DO

    DEALLOCATE(NORMAL)
    DEALLOCATE(FACE_AREA)

    IF(PRESENT(RETURN_RIDGE_EDGE)) THEN
        CALL FILTERING_POINT_TYPE(TYP, RETURN_RIDGE_EDGE)
    ELSE
        CALL FILTERING_POINT_TYPE(TYP)
    END IF

    END SUBROUTINE FIND_POINT_TYPE
    
    
    

    SUBROUTINE FILTERING_POINT_TYPE(TYP, RETURN_RIDGE_EDGE)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL, OPTIONAL :: RETURN_RIDGE_EDGE(:,:)
    REAL(8), ALLOCATABLE :: FACE_AREA(:)
    INTEGER :: I,J,K,L,TEMP_I, T, JMIN, JMAX
    INTEGER :: I1,I2,I3, J1, J2, JJ
    REAL(8) :: V1(3),V2(3),R, V(3), RMIN, RMAX
    REAL(8), ALLOCATABLE :: NORMAL(:,:)
    INTEGER :: CON_NUM
    REAL(8), ALLOCATABLE :: N(:,:), W(:)
    REAL(8) :: W_SUM
    REAL(8) :: E_VALUE(3)
    REAL(8) :: DUMMY(3,3)
    REAL(8), ALLOCATABLE :: E_VECTOR(:,:,:)
    REAL(8) :: TEMP_E_VALUE, TEMP_E_VECTOR(3)
    REAL(8) :: THETA_A
    REAL(8) :: ANGLE
    LOGICAL, ALLOCATABLE :: RIDGE_EDGE(:,:)
    INTEGER :: RIDGE_EDGE_NUM
    INTEGER, ALLOCATABLE :: NEW_POINT_TYPE(:)
    LOGICAL :: B
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    ALLOCATE(E_VECTOR(3,3,SURFACE_CURRENT%SURFACE_POINTS_NUM))

    ALLOCATE(FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(NORMAL(3,SURFACE_CURRENT%SURFACE_FACES_NUM))

    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM

    I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
    I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
    I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)

    V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
    V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)

    CALL VEC_CURL1(V1,V2, NORMAL(:,I))

    R = SQRT(DOT_PRODUCT(NORMAL(:,I), NORMAL(:,I)))

    FACE_AREA(I) = R/2.

    NORMAL(:,I) = NORMAL(:,I) / R

    END DO

    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM         
        CON_NUM = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)

        ALLOCATE(N(CON_NUM,3))
        ALLOCATE(W(CON_NUM))

        W_SUM = 0.
        THETA_A = 0.
        DO J = 1,CON_NUM
            W_SUM = W_SUM + FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))

            I1 = SURFACE_CURRENT%SURFACE_FACES(1,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
            I2 = SURFACE_CURRENT%SURFACE_FACES(2,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
            I3 = SURFACE_CURRENT%SURFACE_FACES(3,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))

            IF(I==I1) THEN
            ELSE IF(I==I2) THEN
                TEMP_I = I1
                I1 = I2
                I2 = I3
                I3 = TEMP_I
            ELSE
                TEMP_I = I1
                I1 = I3
                I3 = I2
                I2 = TEMP_I
            END IF

            V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
            THETA_A = THETA_A + ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) )) )
        END DO

        DO J = 1,CON_NUM
            N(J,:) = NORMAL(:,SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))
            W(J) = FACE_AREA(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) / W_SUM
        END DO

        DO K=1,3
            DO L=1,3
                E_VECTOR(K,L,I) = 0.
                DO J = 1,CON_NUM
                    E_VECTOR(K,L,I) = E_VECTOR(K,L,I) + W(J)*N(J,K)*N(J,L)
                END DO
            END DO
        END DO

        ! COMPUTING EIGEN VALUE & EIGEN VECTOR OF LS_MATRIX

        CALL SVDCMP(E_VECTOR(:,:,I),3,3,3,3,E_VALUE,DUMMY)

        DO J=1,3-1
            JMIN = J
            DO K=J+1,3
                IF(E_VALUE(K)>E_VALUE(JMIN)) THEN
                    JMIN = K
                END IF
            END DO

            IF(J .NE. JMIN) THEN
                TEMP_E_VALUE = E_VALUE(J)
                TEMP_E_VECTOR = E_VECTOR(:,J,I)

                E_VALUE(J) = E_VALUE(JMIN)
                E_VECTOR(:,J,I) = E_VECTOR(:,JMIN,I)

                E_VALUE(JMIN) = TEMP_E_VALUE
                E_VECTOR(:,JMIN,I) = TEMP_E_VECTOR(:)
            END IF
        END DO

        DEALLOCATE(N)
        DEALLOCATE(W)

    END DO

    DEALLOCATE(NORMAL)
    DEALLOCATE(FACE_AREA)

    ALLOCATE(RIDGE_EDGE(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(NEW_POINT_TYPE(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        NEW_POINT_TYPE(I) = SURFACE_CURRENT%POINT_TYPE(I)
    END DO

    RIDGE_EDGE(:,:) = .FALSE.

    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        DO K=1,3
            CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,K, I1)
            CALL DIHEDRAL_ANGLE(SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, I, I1,        ANGLE)

            J1 = SURFACE_CURRENT%SURFACE_FACES(K,I)
            J2 = SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,I)

            IF(ANGLE > 30. * PI/180.) THEN
                RIDGE_EDGE(K,I) = .TRUE.
                !ELSE IF((NEW_POINT_TYPE(J1) == 4 .OR. NEW_POINT_TYPE(J1)==6) .AND. (NEW_POINT_TYPE(J2) == 4 .OR. NEW_POINT_TYPE(J2) == 6)) THEN
                !    RIDGE_EDGE(K,I) = .TRUE.
            ELSE IF(ANGLE > 8. * PI/180.) THEN

            DO T=1,2
                IF(T==1) THEN
                    J = J1
                ELSE
                    J = J2
                END IF

                IF(NEW_POINT_TYPE(J)>1) THEN
                    RMAX = 0.
                    JMAX = 0
                    RMIN = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
                    JMIN = 0

                    DO L=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(J)
                        CALL POINT_NEIGHBOR_POINT(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION, J, L, JJ)
                        V = SURFACE_CURRENT%SURFACE_POINTS(:,JJ) - SURFACE_CURRENT%SURFACE_POINTS(:,J)
                        R = DOT_PRODUCT(V, E_VECTOR(:,3,J))/SQRT(DOT_PRODUCT(V,V))

                        IF(R>RMAX) THEN
                            RMAX = R
                            JMAX = JJ
                        END IF
                        IF(R<RMIN) THEN
                            RMIN = R
                            JMIN = JJ
                        END IF
                    END DO

                    IF(JMAX==J1 .OR. JMIN==J1 .OR. JMAX==J2 .OR. JMIN==J2) THEN
                        RIDGE_EDGE(K,I) = .TRUE.
                        EXIT
                    END IF
                END IF
            END DO
            END IF
        END DO
    END DO

    B = .TRUE.
    DO WHILE(B)
        B = .FALSE.

        DO J=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            RIDGE_EDGE_NUM = 0

            DO L=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(J)
                I = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,J)
                DO K=1,3
                    IF(SURFACE_CURRENT%SURFACE_FACES(K,I)==J) THEN
                        EXIT
                    END IF
                END DO

                IF(RIDGE_EDGE(K,I)) THEN
                    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                END IF
            END DO

            IF(RIDGE_EDGE_NUM > 2) THEN
                IF (NEW_POINT_TYPE(J) == 1 .OR. NEW_POINT_TYPE(J) == 2) THEN !.OR. NEW_POINT_TYPE(J) == 4 .OR. NEW_POINT_TYPE(J) == 5) THEN
                    B = .TRUE.
                    NEW_POINT_TYPE(J) = 3
                END IF
            ELSE IF(RIDGE_EDGE_NUM == 2) THEN
                IF(NEW_POINT_TYPE(J)==1) THEN
                    B = .TRUE.
                    NEW_POINT_TYPE(J) = 2
                END IF
            ELSE IF(RIDGE_EDGE_NUM < 2) THEN
                IF(NEW_POINT_TYPE(J)==2) THEN
                    B = .TRUE.
                    NEW_POINT_TYPE(J) = 1
                END IF
            END IF
        END DO

        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            DO K=1,3
                J1 = SURFACE_CURRENT%SURFACE_FACES(K,I)
                J2 = SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,I)

                IF(RIDGE_EDGE(K,I) .AND. NEW_POINT_TYPE(J1)==1 .AND. NEW_POINT_TYPE(J2)==1) THEN
                    B = .TRUE.

                    RIDGE_EDGE(K,I) = .FALSE.
                END IF
            END DO
        END DO
    END DO


    B = .TRUE.
    DO WHILE(B)
        B = .FALSE.

        DO J=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
            RIDGE_EDGE_NUM = 0

            DO L=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(J)
                I = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,J)
                DO K=1,3
                    IF(SURFACE_CURRENT%SURFACE_FACES(K,I)==J) THEN
                        EXIT
                    END IF
                END DO

                IF(RIDGE_EDGE(K,I)) THEN
                    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                END IF
            END DO

            IF(RIDGE_EDGE_NUM < 1) THEN
                IF(NEW_POINT_TYPE(J)==2) THEN
                    B = .TRUE.
                    NEW_POINT_TYPE(J) = 1
                END IF
            END IF
        END DO

        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            DO K=1,3
                J1 = SURFACE_CURRENT%SURFACE_FACES(K,I)
                J2 = SURFACE_CURRENT%SURFACE_FACES(MOD(K,3)+1,I)

                IF(RIDGE_EDGE(K,I) .AND. (NEW_POINT_TYPE(J1)==1 .OR. NEW_POINT_TYPE(J2)==1)) THEN
                    B = .TRUE.

                    RIDGE_EDGE(K,I) = .FALSE.
                END IF
            END DO
        END DO
    END DO

    DO J=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        SURFACE_CURRENT%POINT_TYPE(J) = NEW_POINT_TYPE(J)
    END DO

    IF(PRESENT(RETURN_RIDGE_EDGE)) THEN
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            RETURN_RIDGE_EDGE(1,I) = RIDGE_EDGE(1,I)
            RETURN_RIDGE_EDGE(2,I) = RIDGE_EDGE(2,I)
            RETURN_RIDGE_EDGE(3,I) = RIDGE_EDGE(3,I)
        END DO
    END IF

    DEALLOCATE(NEW_POINT_TYPE)
    DEALLOCATE(RIDGE_EDGE)
    DEALLOCATE(E_VECTOR)
    END SUBROUTINE FILTERING_POINT_TYPE

    
    
    SUBROUTINE FIND_POINT_TYPE_4(TYP)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: I
    LOGICAL :: B1, B2, B3
    INTEGER :: J1, ITER
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM

    IF(TYP.NE.2) THEN

    B1 = .FALSE.
    B2 = .FALSE.
    B3 = .FALSE.
    DO ITER = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)	
        J1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(ITER,I)
        IF(SURFACE_CURRENT%FACE_ONINTERFACE(J1)==1-TYP) THEN
            B1 = .TRUE.
        ELSE IF(SURFACE_CURRENT%FACE_ONINTERFACE(J1)==2) THEN
            B2 = .TRUE.
        ELSE IF(SURFACE_CURRENT%FACE_ONINTERFACE(J1)==-1) THEN
            B3 = .TRUE.
        END IF
    END DO

    !IF(B1 .AND. B2 .AND. B3) THEN
    !    SURFACE_CURRENT%POINT_TYPE(I) = 6
    !ELSE IF((B1 .OR. B2) .AND. B3) THEN
    !    SURFACE_CURRENT%POINT_TYPE(I) = 5
    IF(B1 .AND. B2) THEN
        SURFACE_CURRENT%POINT_TYPE(I) = 4
    END IF

    ELSE

    B1 = .FALSE.
    B2 = .FALSE.
    B3 = .FALSE.
    DO ITER = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)	
        J1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(ITER,I)
        IF(SURFACE_CURRENT%FACE_ONINTERFACE(J1)==0) THEN
            B1 = .TRUE.
        ELSE IF(SURFACE_CURRENT%FACE_ONINTERFACE(J1)==1) THEN
            B2 = .TRUE.
        ELSE IF(SURFACE_CURRENT%FACE_ONINTERFACE(J1)==-1) THEN
            B3 = .TRUE.
        END IF
    END DO

    !IF(B1 .AND. B2 .AND. B3) THEN
    !    SURFACE_CURRENT%POINT_TYPE(I) = 6
    !ELSE IF((B1 .OR. B2) .AND. B3) THEN
    !    SURFACE_CURRENT%POINT_TYPE(I) = 5
    IF(B1 .AND. B2) THEN
        SURFACE_CURRENT%POINT_TYPE(I) = 4
    END IF

    END IF

    END DO
    END SUBROUTINE

    
    
    SUBROUTINE FIND_POINT_TYPE_56(TYP)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: I
    LOGICAL :: B1, B2, B3
    INTEGER :: J1, ITER
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        IF(TYP.NE.2) THEN

        B1 = .FALSE.
        B2 = .FALSE.
        B3 = .FALSE.
        DO ITER = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)	
            J1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(ITER,I)
            IF(SURFACE_CURRENT%FACE_ONINTERFACE(J1)==1-TYP) THEN
                B1 = .TRUE.
            ELSE IF(SURFACE_CURRENT%FACE_ONINTERFACE(J1)==2) THEN
                B2 = .TRUE.
            ELSE IF(SURFACE_CURRENT%FACE_ONINTERFACE(J1)==-1) THEN
                B3 = .TRUE.
            END IF
        END DO

        IF(B1 .AND. B2 .AND. B3) THEN
            SURFACE_CURRENT%POINT_TYPE(I) = 6
        ELSE IF((B1 .OR. B2) .AND. B3) THEN
            SURFACE_CURRENT%POINT_TYPE(I) = 5
        END IF

        ELSE

        B1 = .FALSE.
        B2 = .FALSE.
        B3 = .FALSE.
        DO ITER = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)	
            J1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(ITER,I)
            IF(SURFACE_CURRENT%FACE_ONINTERFACE(J1)==0) THEN
                B1 = .TRUE.
            ELSE IF(SURFACE_CURRENT%FACE_ONINTERFACE(J1)==1) THEN
                B2 = .TRUE.
            ELSE IF(SURFACE_CURRENT%FACE_ONINTERFACE(J1)==-1) THEN
                B3 = .TRUE.
            END IF
        END DO

        IF(B1 .AND. B2 .AND. B3) THEN
            SURFACE_CURRENT%POINT_TYPE(I) = 6
        ELSE IF((B1 .OR. B2) .AND. B3) THEN
            SURFACE_CURRENT%POINT_TYPE(I) = 5
        END IF

        END IF
    END DO

    END SUBROUTINE

    
    
    SUBROUTINE FIND_POINT_TYPE_USING_BOUNDARY(TYP)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: I,J,K,L, RIDGE_EDGE_NUM
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF


    DO J=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        RIDGE_EDGE_NUM = 0

        DO L=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(J)
            I = SURFACE_CURRENT%POINT_FACE_CONNECTION(L,J)
            DO K=1,3
                IF(SURFACE_CURRENT%SURFACE_FACES(K,I)==J) THEN
                    EXIT
                END IF
            END DO

            IF(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K,I) .NE. 0) THEN
                RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
            END IF
        END DO

        IF(RIDGE_EDGE_NUM >= 3) THEN
            SURFACE_CURRENT%POINT_TYPE(J) = 3
        ELSE IF(RIDGE_EDGE_NUM == 0) THEN
            SURFACE_CURRENT%POINT_TYPE(J) = 1
        ELSE
            SURFACE_CURRENT%POINT_TYPE(J) = 2
        END IF
    END DO

    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        SURFACE_CURRENT%INITIAL_POINT_TYPE(I) = SURFACE_CURRENT%POINT_TYPE(I)
    END DO

    CALL FIND_POINT_TYPE_4(TYP)
    CALL FIND_POINT_TYPE_56(TYP)

    END SUBROUTINE

    
    
    RECURSIVE SUBROUTINE AREA_DIVIDING_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY, USED_FACE, CURRENT_FACE)
    IMPLICIT NONE
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: DIVIDED_REGION_ARRAY(:)
    INTEGER :: DIVIDED_REGION_NUM
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    LOGICAL :: USED_FACE(:)
    INTEGER :: CURRENT_FACE, NEIGHBOR_FACE
    INTEGER :: I

    DIVIDED_REGION_ARRAY(CURRENT_FACE) = DIVIDED_REGION_NUM
    USED_FACE(CURRENT_FACE) = .TRUE.
    DO I=1,3
        IF(DIVIDED_BOUNDARY_ARRAY(I,CURRENT_FACE)==0) THEN
            CALL FACE_NEIGHBOR_FACE(FACE, CONNECTION_NUM, CONNECTION, CURRENT_FACE, I, NEIGHBOR_FACE)

            IF(.NOT. USED_FACE(NEIGHBOR_FACE)) THEN
                CALL AREA_DIVIDING_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY, USED_FACE, NEIGHBOR_FACE)
            END IF
        END IF
    END DO

    END SUBROUTINE AREA_DIVIDING_RECURSIVE

    
    
    SUBROUTINE AREA_DIVIDING(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY)
    IMPLICIT NONE
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)

    INTEGER :: DIVIDED_REGION_ARRAY(FACE_NUM)
    INTEGER :: DIVIDED_REGION_NUM
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(3,FACE_NUM)

    LOGICAL :: B
    LOGICAL, ALLOCATABLE :: USED_FACE(:)
    INTEGER :: CURRENT_FACE
    INTEGER :: I

    ALLOCATE(USED_FACE(FACE_NUM))
    USED_FACE(:) = .FALSE.

    DIVIDED_REGION_ARRAY(:) = 0
    DIVIDED_REGION_NUM = 0

    CURRENT_FACE = 1
    B = .TRUE.
    DO WHILE(B)
        B = .FALSE.
        DIVIDED_REGION_NUM = DIVIDED_REGION_NUM + 1
        CALL AREA_DIVIDING_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY, USED_FACE, CURRENT_FACE)

        DO I=1,FACE_NUM
            IF(.NOT. USED_FACE(I)) THEN
                B = .TRUE.
                CURRENT_FACE = I
                EXIT
            END IF
        END DO
    END DO

    DEALLOCATE(USED_FACE)

    END SUBROUTINE AREA_DIVIDING

    
    
    SUBROUTINE AREA_DIVIDING_TYP(TYP)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: I, ITER
    INTEGER :: ONINTERFACE(4), RESULT_ONINTERFACE
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    CALL AREA_DIVIDING(SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, &
    SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_REGION_NUM, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY)

    DO ITER = 1,SURFACE_CURRENT%FACE_DIVIDED_REGION_NUM
        ONINTERFACE(:) = 0

        DO I = 1,SURFACE_CURRENT%SURFACE_FACES_NUM
            IF(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I)==ITER) THEN
                ONINTERFACE(SURFACE_CURRENT%FACE_ONINTERFACE(I)+2) = ONINTERFACE(SURFACE_CURRENT%FACE_ONINTERFACE(I)+2) + 1
            END IF
        END DO

        DO I=1,4
            IF(ONINTERFACE(I)==MAX(ONINTERFACE(1),ONINTERFACE(2),ONINTERFACE(3),ONINTERFACE(4))) THEN
                RESULT_ONINTERFACE = I-2
                EXIT
            END IF
        END DO

        DO I = 1,SURFACE_CURRENT%SURFACE_FACES_NUM
            IF(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I)==ITER) THEN
                SURFACE_CURRENT%FACE_ONINTERFACE(I) = RESULT_ONINTERFACE
            END IF
        END DO
    END DO

    CALL FIND_POINT_TYPE_56(TYP)

    END SUBROUTINE AREA_DIVIDING_TYP


    
    RECURSIVE SUBROUTINE BOUNDARY_DIVIDING_RECURSIVE(POINT_NUM, POINT, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, POINT_TYPE, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM, USED_EDGE, RIDGE_EDGE, CURRENT_EDGE)
    IMPLICIT NONE
    INTEGER :: POINT_NUM
    REAL(8) :: POINT(:,:)
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: POINT_TYPE(:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER :: DIVIDED_BOUNDARY_NUM
    LOGICAL :: USED_EDGE(:,:)
    LOGICAL :: RIDGE_EDGE(:,:)
    INTEGER :: RIDGE_EDGE_NUM
    INTEGER :: CURRENT_EDGE(2), NEIGHBOR_EDGE(2)
    INTEGER :: I, J, K, I1, I2, L, J1, J2, T, JJ, S
    REAL(8) :: V1(3), V2(3)

    K = CURRENT_EDGE(1)
    I = CURRENT_EDGE(2)

    DIVIDED_BOUNDARY_ARRAY(K,I) = DIVIDED_BOUNDARY_NUM

    USED_EDGE(K,I) = .TRUE.

    CALL FACE_NEIGHBOR_FACE(FACE, CONNECTION_NUM, CONNECTION, I, K, I1)

    DO L=1,3
        IF(FACE(L,I1)==FACE(MOD(K,3)+1,I)) THEN
            EXIT
        END IF
    END DO

    DIVIDED_BOUNDARY_ARRAY(L,I1) = DIVIDED_BOUNDARY_NUM

    USED_EDGE(L,I1) = .TRUE.

    J1 = FACE(K,I)
    J2 = FACE(MOD(K,3)+1,I)

    DO T=1,2
        IF(T==1) THEN
            J = J1
            JJ = J2
        ELSE
            J = J2
            JJ = J1
        END IF

        IF(POINT_TYPE(J)==3 .OR. POINT_TYPE(J)==6) THEN
            CYCLE
        END IF

        RIDGE_EDGE_NUM = 1

        DO L=1,CONNECTION_NUM(J)
            I2 = CONNECTION(L,J)
            DO S=1,3
                IF(FACE(S,I2)==J) THEN
                    EXIT
                END IF
            END DO

            IF(RIDGE_EDGE(S,I2) .AND. FACE(MOD(S,3)+1,I2).NE.JJ) THEN
                RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                NEIGHBOR_EDGE(1) = S
                NEIGHBOR_EDGE(2) = I2
            END IF
        END DO

        IF(RIDGE_EDGE_NUM > 1) THEN
            IF(.NOT. USED_EDGE(NEIGHBOR_EDGE(1),NEIGHBOR_EDGE(2)) .AND. RIDGE_EDGE_NUM == 2) THEN
                V1 = POINT(:,JJ) - POINT(:,J)
                V2 = POINT(:,J) - POINT(:,FACE(MOD(NEIGHBOR_EDGE(1),3)+1,NEIGHBOR_EDGE(2)))
                IF(ACOS(MAX(-1., MIN(1., DOT_PRODUCT(V1,V2)/SQRT(DOT_PRODUCT(V1,V1) * DOT_PRODUCT(V2,V2)) ))) < 30. * PI/180.) THEN
                    CALL BOUNDARY_DIVIDING_RECURSIVE(POINT_NUM, POINT, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, POINT_TYPE, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM, USED_EDGE, RIDGE_EDGE, NEIGHBOR_EDGE)
                END IF
            END IF
        END IF
    END DO

    END SUBROUTINE BOUNDARY_DIVIDING_RECURSIVE

    
    
    SUBROUTINE BOUNDARY_DIVIDING(POINT_NUM, POINT, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, POINT_TYPE, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM, RIDGE_EDGE)
    IMPLICIT NONE
    INTEGER :: POINT_NUM
    REAL(8) :: POINT(:,:)
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: POINT_TYPE(:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(3,FACE_NUM)
    INTEGER :: DIVIDED_BOUNDARY_NUM
    LOGICAL :: RIDGE_EDGE(3,FACE_NUM)
    LOGICAL :: B
    LOGICAL, ALLOCATABLE :: USED_EDGE(:,:)
    INTEGER :: CURRENT_EDGE(2)
    INTEGER :: I,K

    ALLOCATE(USED_EDGE(3,FACE_NUM))
    USED_EDGE(:,:) = .FALSE.

    DIVIDED_BOUNDARY_ARRAY(:,:) = 0
    DIVIDED_BOUNDARY_NUM = 0

    B = .TRUE.
    DO WHILE(B)
        B = .FALSE.

        DO I=1,FACE_NUM
            DO K=1,3
                IF(.NOT. USED_EDGE(K,I) .AND. RIDGE_EDGE(K,I)) THEN
                    B = .TRUE.
                    CURRENT_EDGE(1) = K
                    CURRENT_EDGE(2) = I
                    EXIT
                END IF
            END DO
        END DO

        IF(B) THEN
            DIVIDED_BOUNDARY_NUM = DIVIDED_BOUNDARY_NUM + 1
            CALL BOUNDARY_DIVIDING_RECURSIVE(POINT_NUM, POINT, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, POINT_TYPE, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM, USED_EDGE, RIDGE_EDGE, CURRENT_EDGE)
        END IF
    END DO

    DEALLOCATE(USED_EDGE)

    END SUBROUTINE BOUNDARY_DIVIDING

    
    
    SUBROUTINE BOUNDARY_DIVIDING_TYP(TYP)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL, ALLOCATABLE :: RIDGE_EDGE(:,:)
    INTEGER :: I, J1, J2, K, I1
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    ALLOCATE(RIDGE_EDGE(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    RIDGE_EDGE(:,:) = .FALSE.

    CALL FIND_POINT_TYPE(TYP, RIDGE_EDGE)


    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        SURFACE_CURRENT%INITIAL_POINT_TYPE(I) = SURFACE_CURRENT%POINT_TYPE(I)
    END DO

    CALL FIND_POINT_TYPE_4(TYP)
    
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        DO K=1,3
            CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,K, I1)
            IF((SURFACE_CURRENT%FACE_ONINTERFACE(I) == MOD(TYP+1,3) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1) == MOD(TYP+2,3)) .OR. (SURFACE_CURRENT%FACE_ONINTERFACE(I) == MOD(TYP+2,3) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1) == MOD(TYP+1,3))) THEN
                RIDGE_EDGE(K,I) = .TRUE.
            END IF
        END DO
    END DO
    
    IF(TYP==0) THEN
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,K, I1)
                IF(SURFACE_CURRENT%FACE_ABLATION_FLAG(I) == -2 .XOR. SURFACE_CURRENT%FACE_ABLATION_FLAG(I1) == -2) THEN
                    RIDGE_EDGE(K,I) = .TRUE.
                END IF
            END DO
        END DO
        !        ELSE
        !            DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        !                DO K=1,3
        !                    CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,K, I1)
        !                    
        !                    DO L=1,3
        !                        IF(SURFACE_CURRENT%SURFACE_FACES(L,I1)==SURFACE_CURRENT%SURFACE_FACES(K,I)) THEN
        !                            EXIT
        !                        END IF
        !                    END DO
        !                    
        !                    J1 = SURFACE_CURRENT%POINT_RELATEDFACE(0+1,SURFACE_CURRENT%SURFACE_FACES(MOD(K+3-2,3)+1,I))
        !                    J2 = SURFACE_CURRENT%POINT_RELATEDFACE(0+1,SURFACE_CURRENT%SURFACE_FACES(MOD(L,3)+1,I1))
        !                    
        !                    IF(J1 .NE. 0 .AND. J2 .NE. 0) THEN
        !                        IF(SURFACE_FLUID%FACE_ABLATION_FLAG(J1) == -2 .XOR. SURFACE_FLUID%FACE_ABLATION_FLAG(J2) == -2) THEN
        !                            RIDGE_EDGE(K,I) = .TRUE.
        !                        END IF
        !                    END IF
        !                END DO
        !            END DO
    END IF
    CALL BOUNDARY_DIVIDING(SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, &
    SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%POINT_TYPE, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_NUM, RIDGE_EDGE)

    CALL FIND_RIDGE_GROUP_TYPE(TYP)

    DEALLOCATE(RIDGE_EDGE)

    END SUBROUTINE BOUNDARY_DIVIDING_TYP



    SUBROUTINE FIND_PATCH_NUM(TYP)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: PATCH_NUM
    INTEGER :: I,J
    LOGICAL :: B
    REAL(8), ALLOCATABLE :: TEMP(:)


    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    PATCH_NUM = 0
    ALLOCATE(TEMP(SURFACE_CURRENT%SURFACE_FACES_NUM)) 

    DO I = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
        B = .TRUE.
        IF(I .EQ. 1) THEN
            PATCH_NUM = PATCH_NUM + 1
            TEMP(PATCH_NUM) = SURFACE_CURRENT%FACE_LOCATION(I) 
        ELSE 
            DO J = 1, PATCH_NUM
                IF(SURFACE_CURRENT%FACE_LOCATION(I) .EQ. TEMP(J)) THEN
                    B = .FALSE.
                    EXIT
                END IF
            END DO
            IF(B) THEN
                PATCH_NUM = PATCH_NUM + 1
                TEMP(PATCH_NUM) = SURFACE_CURRENT%FACE_LOCATION(I) 
                EXIT
            END IF
        END IF
    END DO

    SURFACE_CURRENT%SURFACE_PATCHES_NUM = PATCH_NUM

    DEALLOCATE(TEMP)
    END SUBROUTINE FIND_PATCH_NUM

    
    
    SUBROUTINE FIND_INTERFACE(TYP, CASE1)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER, OPTIONAL :: CASE1
    TYPE(HASH) :: HASH0, HASH1, HASH2

    CALL SET_HASH_TYP(0, 2, HASH0)
    CALL SET_HASH_TYP(1, 2, HASH1)
    CALL SET_HASH_TYP(2, 2, HASH2)

    IF(PRESENT(CASE1)) THEN
        CALL FIND_INTERFACE_HASH(TYP, HASH0, HASH1, HASH2, CASE1)
    ELSE
        CALL FIND_INTERFACE_HASH(TYP, HASH0, HASH1, HASH2)
    END IF

    CALL REMOVE_HASH(HASH0)
    CALL REMOVE_HASH(HASH1)
    CALL REMOVE_HASH(HASH2)
    END SUBROUTINE FIND_INTERFACE

    
    
    SUBROUTINE FIND_INTERFACE_HASH(TYP, HASH0, HASH1, HASH2, CASE0)
    INTEGER :: TYP
    TYPE(HASH) :: HASH0, HASH1, HASH2
    INTEGER, OPTIONAL :: CASE0
    INTEGER :: CASE1
    INTEGER :: I
    INTEGER :: I1, I2, I3, K1, K2, K3
    INTEGER :: IDX1, IDX2, IDX3
    REAL(8) :: V1(3),V2(3),V3(3), R1, R2, R3, THRESH
    CHARACTER(500) :: STR, STR1

    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF(PRESENT(CASE0)) THEN
        CASE1 = CASE0
    ELSE
        CASE1 = 2
    END IF

    if(case1==2) then

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    SURFACE_CURRENT%FACE_ONINTERFACE(:) = -1

    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        V1 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,I))
        V2 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,I))
        V3 = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,I))

        THRESH = (SQRT(DOT_PRODUCT(V2-V1,V2-V1)) + SQRT(DOT_PRODUCT(V3-V2,V3-V2)) + SQRT(DOT_PRODUCT(V3-V1,V3-V1)))/3.

        R1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))
        R2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))
        R3 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))

        IDX1 = 0
        IDX2 = 0
        IDX3 = 0

        IF(TYP.NE.0) CALL DISTANCE_SURFACE_FACE_HASH(I, TYP, HASH0,  1, R1, IDX1)
        IF(TYP.NE.1) CALL DISTANCE_SURFACE_FACE_HASH(I, TYP, HASH1,  1, R2, IDX2)
        IF(TYP.NE.2) CALL DISTANCE_SURFACE_FACE_HASH(I, TYP, HASH2,  1, R3, IDX3)
        
        IF(TYP.NE.2) THEN
        
        IF(ABS(R1) <= ABS(R2) .AND. ABS(R1) <= ABS(R3) .AND. ABS(R1) < THRESH/2.75) THEN
            SURFACE_CURRENT%FACE_ONINTERFACE(I) = 0
        ELSE IF(ABS(R2) <= ABS(R1) .AND. ABS(R2) <= ABS(R3) .AND. ABS(R2) < THRESH/2.75) THEN
            SURFACE_CURRENT%FACE_ONINTERFACE(I) = 1
        ELSE IF(ABS(R3) <= ABS(R1) .AND. ABS(R3) <= ABS(R2) .AND. ABS(R3) < THRESH/2.75) THEN
            SURFACE_CURRENT%FACE_ONINTERFACE(I) = 2
        END IF
        
        ELSE
        
        IF(ABS(R1) <= ABS(R2) .AND. ABS(R1) <= ABS(R3) .AND. R1 > -THRESH/2.75 .AND. R1 < MAX(THRESH/2.75, SURFACE_FLUID%MESH_SIZE * THIN_REGION_ATTACHMENT * 2.)) THEN
            SURFACE_CURRENT%FACE_ONINTERFACE(I) = 0
        ELSE IF(ABS(R2) <= ABS(R1) .AND. ABS(R2) <= ABS(R3) .AND. R2 > -THRESH/2.75 .AND. R2 < MAX(THRESH/2.75, SURFACE_FLUID%MESH_SIZE * THIN_REGION_ATTACHMENT * 2.)) THEN
            SURFACE_CURRENT%FACE_ONINTERFACE(I) = 1
        ELSE IF(ABS(R3) <= ABS(R1) .AND. ABS(R3) <= ABS(R2) .AND. R3 > -THRESH/2.75 .AND. R3 < MAX(THRESH/2.75, SURFACE_FLUID%MESH_SIZE * THIN_REGION_ATTACHMENT * 2.)) THEN
            SURFACE_CURRENT%FACE_ONINTERFACE(I) = 2
        END IF
        
        END IF
        
    END DO

    IF(TYP==0) THEN
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,1, I1)
            CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,2, I2)
            CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,3, I3)

            K1 = SURFACE_CURRENT%FACE_ONINTERFACE(I1)
            K2 = SURFACE_CURRENT%FACE_ONINTERFACE(I2)
            K3 = SURFACE_CURRENT%FACE_ONINTERFACE(I3)

            IF(K1==K2 .AND. K1==1) THEN
                SURFACE_CURRENT%FACE_ONINTERFACE(I) = K1
            ELSE IF(K2==K3 .AND. K2==1) THEN
                SURFACE_CURRENT%FACE_ONINTERFACE(I) = K2
            ELSE IF(K3==K1 .AND. K3==1) THEN
                SURFACE_CURRENT%FACE_ONINTERFACE(I) = K3
            END IF

        END DO
    END IF

    !IF(TYP==2) THEN
    !    FLAG = .FALSE.
    !    CALL UPDATE_CASE_INTERFACE(FLAG)
    !END IF

    CALL COLLAPSE_INTERFACE(TYP)

    WRITE(STR1,*) TYP
    STR = './output/surface/face_oninterface_3d_initial_' // TRIM(ADJUSTL(STR1)) // '.txt'
    OPEN(UNIT=21, FILE = STR)
    !$OMP DO ORDERED 
    DO I = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
        WRITE(21,*) SURFACE_CURRENT%FACE_ONINTERFACE(I)
    END DO
    !$OMP END DO
    CLOSE(21)

    NULLIFY(SURFACE_CURRENT)

    else if(case1==3) then

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    WRITE(STR1,*) TYP
    STR = './output/surface/face_oninterface_3d_initial_' // TRIM(ADJUSTL(STR1)) // '.txt'
    OPEN(UNIT=21, FILE = STR)
    !$OMP DO ORDERED 
    DO I = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
        READ(21,*) SURFACE_CURRENT%FACE_ONINTERFACE(I)
    END DO
    !$OMP END DO
    CLOSE(21)
    end if

    NULLIFY(SURFACE_CURRENT)
    END SUBROUTINE FIND_INTERFACE_HASH

    

    RECURSIVE SUBROUTINE COLLAPSE_INTERFACE_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, ONINTERFACE, FACE_CLUSTER, FACE_CLUSTER_NUM, USED_FACE, CURRENT_FACE, NEIGHBOR_ONINTERFACE)
    IMPLICIT NONE
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: ONINTERFACE(:)
    INTEGER :: FACE_CLUSTER(:)
    INTEGER :: FACE_CLUSTER_NUM
    LOGICAL :: USED_FACE(:)
    INTEGER :: CURRENT_FACE, NEIGHBOR_FACE, NEIGHBOR_ONINTERFACE(:)
    INTEGER :: I

    FACE_CLUSTER_NUM = FACE_CLUSTER_NUM + 1
    FACE_CLUSTER(FACE_CLUSTER_NUM) = CURRENT_FACE
    USED_FACE(CURRENT_FACE) = .TRUE.

    DO I=1,3
        CALL FACE_NEIGHBOR_FACE(FACE, CONNECTION_NUM, CONNECTION, CURRENT_FACE, I, NEIGHBOR_FACE)

        IF(ONINTERFACE(CURRENT_FACE)==ONINTERFACE(NEIGHBOR_FACE) .AND. .NOT. USED_FACE(NEIGHBOR_FACE)) THEN
            CALL COLLAPSE_INTERFACE_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, ONINTERFACE, FACE_CLUSTER, FACE_CLUSTER_NUM, USED_FACE, NEIGHBOR_FACE, NEIGHBOR_ONINTERFACE)
        ELSE IF(ONINTERFACE(CURRENT_FACE).NE.ONINTERFACE(NEIGHBOR_FACE)) THEN
            NEIGHBOR_ONINTERFACE(ONINTERFACE(NEIGHBOR_FACE)+2) = NEIGHBOR_ONINTERFACE(ONINTERFACE(NEIGHBOR_FACE)+2) + 1
        END IF
    END DO

    END SUBROUTINE COLLAPSE_INTERFACE_RECURSIVE

    
    
    SUBROUTINE COLLAPSE_INTERFACE(TYP)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER, ALLOCATABLE :: FACE_CLUSTER(:)
    INTEGER :: FACE_CLUSTER_NUM
    LOGICAL, ALLOCATABLE :: USED_FACE(:)
    INTEGER :: CURRENT_FACE, NEIGHBOR_ONINTERFACE(4), RESULT_ONINTERFACE
    LOGICAL :: B
    INTEGER :: I,J
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    ALLOCATE(FACE_CLUSTER(SURFACE_CURRENT%SURFACE_FACES_NUM))

    ALLOCATE(USED_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    USED_FACE(:) = .FALSE.

    CURRENT_FACE = 1
    B = .TRUE.
    DO WHILE(B)
        B = .FALSE.

        FACE_CLUSTER(:) = 0
        FACE_CLUSTER_NUM = 0

        NEIGHBOR_ONINTERFACE(:) = 0

        CALL COLLAPSE_INTERFACE_RECURSIVE(SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%FACE_ONINTERFACE, FACE_CLUSTER, FACE_CLUSTER_NUM, USED_FACE, CURRENT_FACE, NEIGHBOR_ONINTERFACE)

        IF(FACE_CLUSTER_NUM < 20) THEN
            DO J=1,4
                IF(NEIGHBOR_ONINTERFACE(J)==MAX(NEIGHBOR_ONINTERFACE(1),NEIGHBOR_ONINTERFACE(2),NEIGHBOR_ONINTERFACE(3),NEIGHBOR_ONINTERFACE(4))) THEN
                    RESULT_ONINTERFACE = J-2
                    EXIT
                END IF
            END DO

            DO I=1,FACE_CLUSTER_NUM
                SURFACE_CURRENT%FACE_ONINTERFACE(FACE_CLUSTER(I)) = RESULT_ONINTERFACE
            END DO
        END IF

        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            IF(.NOT. USED_FACE(I)) THEN
                B = .TRUE.
                CURRENT_FACE = I
                EXIT
            END IF
        END DO
    END DO

    DEALLOCATE(USED_FACE)

    DEALLOCATE(FACE_CLUSTER)

    END SUBROUTINE COLLAPSE_INTERFACE



    SUBROUTINE FIND_RELATEDPT(TYP1, TYP2, RMIN_MAX, CASE1)
    IMPLICIT NONE
    INTEGER :: TYP1, TYP2
    REAL(8) :: RMIN_MAX
    INTEGER, OPTIONAL :: CASE1
    TYPE(HASH) :: HASH0

    CALL SET_HASH_TYP(TYP2, 1, HASH0)

    IF(PRESENT(CASE1)) THEN
        CALL FIND_RELATEDPT_HASH(TYP1, HASH0, RMIN_MAX, CASE1)
    ELSE
        CALL FIND_RELATEDPT_HASH(TYP1, HASH0, RMIN_MAX)
    END IF

    CALL REMOVE_HASH(HASH0)
    END SUBROUTINE FIND_RELATEDPT

    
    
    SUBROUTINE FIND_RELATEDPT_HASH(TYP1, HASH0, RMIN_MAX, CASE0)
    IMPLICIT NONE
    INTEGER :: TYP1
    TYPE(HASH) :: HASH0
    REAL(8) :: RMIN_MAX
    INTEGER, OPTIONAL :: CASE0
    INTEGER :: CASE1
    TYPE(HASH_ELEMENT), POINTER :: ELEMENT_CURRENT
    INTEGER :: INDEX1, INDEX2, INDEX3
    INTEGER :: I,I0,I1,K,J
    INTEGER :: JMIN
    REAL(8) :: RMIN, R
    LOGICAL, ALLOCATABLE :: POINT_USED(:)
    LOGICAL :: B
    CHARACTER(500) :: STR, STR1, STR2

    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT1, SURFACE_CURRENT2

    IF (TYP1==0) THEN
        SURFACE_CURRENT1 => SURFACE_FLUID
    END IF
    IF (TYP1==1) THEN
        SURFACE_CURRENT1 => SURFACE_PROPEL
    END IF
    IF (TYP1==2) THEN
        SURFACE_CURRENT1 => SURFACE_CASE
    END IF

    IF (HASH0%TYP==0) THEN
        SURFACE_CURRENT2 => SURFACE_FLUID
    END IF
    IF (HASH0%TYP==1) THEN
        SURFACE_CURRENT2 => SURFACE_PROPEL
    END IF
    IF (HASH0%TYP==2) THEN
        SURFACE_CURRENT2 => SURFACE_CASE
    END IF

    IF(PRESENT(CASE0)) THEN
        CASE1 = CASE0
    ELSE
        CASE1 = 1
    END IF

    if(case1==1) THEN
        K = HASH0%TYP + 1
        SURFACE_CURRENT1%POINT_RELATEDPT(K,:) = 0

        ALLOCATE(POINT_USED(SURFACE_CURRENT2%SURFACE_POINTS_NUM))

        POINT_USED(:) = .FALSE.

        DO I=1,SURFACE_CURRENT1%SURFACE_POINTS_NUM
            B = .FALSE.
            DO J=1,SURFACE_CURRENT1%POINT_FACE_CONNECTION_NUM(I)
                I1 = SURFACE_CURRENT1%POINT_FACE_CONNECTION(J,I)
                IF(SURFACE_CURRENT1%FACE_ONINTERFACE(I1)==HASH0%TYP) THEN
                    B = .TRUE.
                    EXIT
                END IF
            END DO

            IF(B) THEN
                JMIN = 0
                RMIN = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))

                CALL FIND_HASH_INDEX(HASH0, SURFACE_CURRENT1%SURFACE_POINTS(:,I), INDEX1, INDEX2, INDEX3)

                ELEMENT_CURRENT => HASH0%ELEMENT(INDEX1,INDEX2,INDEX3)%HEAD
                DO WHILE(ASSOCIATED(ELEMENT_CURRENT))
                    I0 = ELEMENT_CURRENT%I0
                    R = SQRT(DOT_PRODUCT(SURFACE_CURRENT2%SURFACE_POINTS(:,I0)-SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,I0)-SURFACE_CURRENT1%SURFACE_POINTS(:,I)))
                    IF(R<RMIN) THEN
                        RMIN = R
                        JMIN = I0
                    END IF
                    ELEMENT_CURRENT => ELEMENT_CURRENT%NEXT
                END DO
                NULLIFY(ELEMENT_CURRENT)

                IF(RMIN < RMIN_MAX) THEN
                    SURFACE_CURRENT1%POINT_RELATEDPT(K,I) = JMIN
                    POINT_USED(JMIN) = .TRUE.
                END IF
            END IF
        END DO

        DEALLOCATE(POINT_USED)

        WRITE(STR1,*) TYP1
        WRITE(STR2,*) HASH0%TYP
        STR = './output/surface/point_relatedpt_3d_initial_' // TRIM(ADJUSTL(STR1)) // '_' // TRIM(ADJUSTL(STR2)) // '.txt'

        OPEN(UNIT=21, FILE = STR)
        !$OMP DO ORDERED 
        DO I = 1, SURFACE_CURRENT1%SURFACE_POINTS_NUM
            WRITE(21,*) SURFACE_CURRENT1%POINT_RELATEDPT(1+HASH0%TYP,I)
        END DO
        !$OMP END DO
        CLOSE(21)
    else if(case1==2) then
        WRITE(STR1,*) TYP1
        WRITE(STR2,*) HASH0%TYP
        STR = './output/surface/point_relatedpt_3d_initial_' // TRIM(ADJUSTL(STR1)) // '_' // TRIM(ADJUSTL(STR2)) // '.txt'

        OPEN(UNIT=21, FILE = STR)
        !$OMP DO ORDERED 
        DO I = 1, SURFACE_CURRENT1%SURFACE_POINTS_NUM
            READ(21,*) SURFACE_CURRENT1%POINT_RELATEDPT(1+HASH0%TYP,I)
        END DO
        !$OMP END DO
        CLOSE(21)

    end if

    NULLIFY(SURFACE_CURRENT1)
    NULLIFY(SURFACE_CURRENT2)
    END SUBROUTINE FIND_RELATEDPT_HASH

    

    SUBROUTINE FIND_RELATEDFACE(TYP1, TYP2, ISPROJ, CASE1)
    IMPLICIT NONE
    INTEGER :: TYP1, TYP2
    LOGICAL :: ISPROJ
    INTEGER, OPTIONAL :: CASE1
    TYPE(HASH) :: HASH0


    CALL SET_HASH_TYP(TYP2, 2, HASH0)

    IF(PRESENT(CASE1)) THEN
        CALL FIND_RELATEDFACE_HASH(TYP1, HASH0, ISPROJ, CASE1)
    ELSE
        CALL FIND_RELATEDFACE_HASH(TYP1, HASH0, ISPROJ)
    END IF

    CALL REMOVE_HASH(HASH0)
    END SUBROUTINE FIND_RELATEDFACE

    

    SUBROUTINE FIND_RELATEDFACE_HASH(TYP1, HASH0, ISPROJ, CASE0)
    IMPLICIT NONE
    INTEGER :: TYP1
    TYPE(HASH) :: HASH0
    LOGICAL :: ISPROJ
    INTEGER, OPTIONAL :: CASE0
    INTEGER :: CASE1
    TYPE(HASH_ELEMENT), POINTER :: ELEMENT_CURRENT
    INTEGER :: INDEX1, INDEX2, INDEX3
    INTEGER :: I, J, K, I0, JMIN
    REAL(8) :: RMIN, R
    LOGICAL :: B, C
    INTEGER :: L,M, I1, I2, I3, I4, I5, I6, I7, J1,J2,J3,IDX,NUM
    INTEGER :: RIDGE_POINT_NUM, RIDGE_EDGE_NUM, FACE_INDEX
    CHARACTER(500) :: STR, STR1, STR2
    REAL(8) :: COORD, DIST, TEMPDIST
    INTEGER, ALLOCATABLE :: RIDGE_EDGE(:,:)
    REAL(8) :: DIST1, DIST2, DIST3
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT1, SURFACE_CURRENT2

    IF (TYP1==0) THEN
        SURFACE_CURRENT1 => SURFACE_FLUID
    END IF
    IF (TYP1==1) THEN
        SURFACE_CURRENT1 => SURFACE_PROPEL
    END IF
    IF (TYP1==2) THEN
        SURFACE_CURRENT1 => SURFACE_CASE
    END IF

    IF (HASH0%TYP==0) THEN
        SURFACE_CURRENT2 => SURFACE_FLUID
    END IF
    IF (HASH0%TYP==1) THEN
        SURFACE_CURRENT2 => SURFACE_PROPEL
    END IF
    IF (HASH0%TYP==2) THEN
        SURFACE_CURRENT2 => SURFACE_CASE
    END IF

    IF(PRESENT(CASE0)) THEN
        CASE1 = CASE0
    ELSE
        CASE1 = 1
    END IF


    if(case1 ==1)  then
        K = HASH0%TYP + 1
        SURFACE_CURRENT1%POINT_RELATEDFACE(K,:) = 0

        DO I=1,SURFACE_CURRENT1%SURFACE_POINTS_NUM
            B = .FALSE.
            DO J=1,SURFACE_CURRENT1%POINT_FACE_CONNECTION_NUM(I)
                I1 = SURFACE_CURRENT1%POINT_FACE_CONNECTION(J,I)
                IF(SURFACE_CURRENT1%FACE_ONINTERFACE(I1)==HASH0%TYP) THEN
                    B = .TRUE.
                    EXIT
                END IF
            END DO
            
            C = .FALSE.
            IF(TYP1==0 .AND. HASH0%TYP==2) THEN
                DO J=1,SURFACE_CURRENT1%POINT_FACE_CONNECTION_NUM(I)
                    I1 = SURFACE_CURRENT1%POINT_FACE_CONNECTION(J,I)
                    IF(SURFACE_CURRENT1%FACE_ONINTERFACE(I1)==1) THEN
                        C = .TRUE.
                        EXIT
                    END IF
                END DO
            END IF
            
            IF(B .OR. (TYP1==0 .AND. HASH0%TYP==2 .AND. C)) THEN
                JMIN = 0
                RMIN = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))

                CALL FIND_HASH_INDEX(HASH0, SURFACE_CURRENT1%SURFACE_POINTS(:,I), INDEX1, INDEX2, INDEX3)

                ELEMENT_CURRENT => HASH0%ELEMENT(INDEX1,INDEX2,INDEX3)%HEAD
                DO WHILE(ASSOCIATED(ELEMENT_CURRENT))
                    I0 = ELEMENT_CURRENT%I0
                    
                    IF((SURFACE_MOVING_TYPE>=1 .AND. SURFACE_CURRENT2%FACE_ONINTERFACE(I0) == TYP1) .OR. (SURFACE_MOVING_TYPE<=0 .AND. SURFACE_CURRENT2%FACE_ONINTERFACE(I0) .NE. -1)) THEN
                    !IF(SURFACE_CURRENT2%FACE_ONINTERFACE(I0) .NE. -1) THEN
                        IF(SURFACE_CURRENT1%POINT_TYPE(I)==1 .OR. ((SURFACE_CURRENT1%POINT_TYPE(I)==2 .OR. SURFACE_CURRENT1%POINT_TYPE(I)==3) .AND. (TYP1 == 0 .OR. TYP1 == 2)) .OR. (SURFACE_CURRENT1%POINT_TYPE(I)==4 .AND. TYP1 == 0) ) THEN
                            CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(1,I0)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(2,I0)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(3,I0)),R)
                            IF(R<RMIN) THEN
                                RMIN = R
                                JMIN = I0
                            END IF
                        ELSE
                        
                        DO L=1,3
                            IF(SURFACE_CURRENT2%FACE_DIVIDED_BOUNDARY_ARRAY(L,I0) .NE. 0) THEN
                                CALL UNSIGNED_DISTANCE_EDGE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(L,I0)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(MOD(L,3)+1,I0)),R)
                                IF(R<RMIN) THEN
                                    RMIN = R
                                    JMIN = I0
                                END IF
                            END IF
                        END DO
                        
                        END IF
                    END IF
                    ELEMENT_CURRENT => ELEMENT_CURRENT%NEXT
                END DO

                NULLIFY(ELEMENT_CURRENT)
                SURFACE_CURRENT1%POINT_RELATEDFACE(K,I) = JMIN
            END IF
        END DO

        IF(ISPROJ) THEN
            DO I=1, SURFACE_CURRENT1%SURFACE_POINTS_NUM
                IF(SURFACE_CURRENT1%POINT_RELATEDFACE(K,I).NE.0) THEN
                    RIDGE_POINT_NUM = 0
                    RIDGE_EDGE_NUM = 0
                    DIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
                    DIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
                    DIST3 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
                    J = SURFACE_CURRENT1%POINT_RELATEDFACE(K,I)
                    I2 = SURFACE_CURRENT2%SURFACE_FACES(1,J)
                    I3 = SURFACE_CURRENT2%SURFACE_FACES(2,J)
                    I4 = SURFACE_CURRENT2%SURFACE_FACES(3,J)
                    
                    IF(SURFACE_CURRENT1%POINT_TYPE(I) .NE. 2) THEN
                        CALL PROJECTION_FACE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(1,J)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(2,J)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(3,J)))
                    ELSE
                        ALLOCATE(RIDGE_EDGE(2,100))
                        RIDGE_EDGE_NUM = 0
                        DO L= 1,3
                            I5 = SURFACE_CURRENT2%SURFACE_FACES(L,J)
                            NUM = SURFACE_CURRENT2%POINT_FACE_CONNECTION_NUM(I5)
                            DO M= 1,NUM
                                FACE_INDEX = SURFACE_CURRENT2%POINT_FACE_CONNECTION(M,I5)
                                J1 = SURFACE_CURRENT2%SURFACE_FACES(1,FACE_INDEX)
                                J2 = SURFACE_CURRENT2%SURFACE_FACES(2,FACE_INDEX)
                                J3 = SURFACE_CURRENT2%SURFACE_FACES(3,FACE_INDEX)
                                IF(SURFACE_CURRENT2%POINT_TYPE(J1)==2 .AND. SURFACE_CURRENT2%POINT_TYPE(J2)==2) THEN
                                    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                                    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = J1
                                    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = J2
                                END IF
                                IF(SURFACE_CURRENT2%POINT_TYPE(J2)==2 .AND. SURFACE_CURRENT2%POINT_TYPE(J3)==2) THEN
                                    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                                    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = J2
                                    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = J3
                                END IF
                                IF(SURFACE_CURRENT2%POINT_TYPE(J3)==2 .AND. SURFACE_CURRENT2%POINT_TYPE(J1)==2) THEN
                                    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                                    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = J3
                                    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = J1
                                END IF
                            END DO
                        END DO

                        IF(RIDGE_EDGE_NUM==0) THEN
                            CALL PROJECTION_FACE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(1,J)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(2,J)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(3,J)))
                        ELSE
                            DIST = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))
                            DO L=1,RIDGE_EDGE_NUM
                                I6 = RIDGE_EDGE(1,L)
                                I7 = RIDGE_EDGE(2,L)
                                CALL UNSIGNED_DISTANCE_EDGE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,I6),SURFACE_CURRENT2%SURFACE_POINTS(:,I7),TEMPDIST)
                                IF(TEMPDIST<DIST) THEN
                                    DIST = TEMPDIST
                                    IDX = L
                                END IF
                            END DO
                            I6 = RIDGE_EDGE(1,IDX)
                            I7 = RIDGE_EDGE(2,IDX)
                            CALL PROJECTION_EDGE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,I6),SURFACE_CURRENT2%SURFACE_POINTS(:,I7),COORD)
                        END IF
                        DEALLOCATE(RIDGE_EDGE)
                    END IF			
                END IF

            END DO
        END IF

        WRITE(STR1,*) TYP1
        WRITE(STR2,*) HASH0%TYP
        STR = './output/surface/point_relatedface_3d_initial_' // TRIM(ADJUSTL(STR1)) // '_' // TRIM(ADJUSTL(STR2)) // '.txt'

        OPEN(UNIT=21, FILE = STR)
        !$OMP DO ORDERED 
        DO I = 1, SURFACE_CURRENT1%SURFACE_POINTS_NUM
            WRITE(21,*) SURFACE_CURRENT1%POINT_RELATEDFACE(1+HASH0%TYP,I)
        END DO
        !$OMP END DO
        CLOSE(21)

    else if(case1==2) then

    WRITE(STR1,*) TYP1
    WRITE(STR2,*) HASH0%TYP
    STR = './output/surface/point_relatedface_3d_initial_' // TRIM(ADJUSTL(STR1)) // '_' // TRIM(ADJUSTL(STR2)) // '.txt'

    OPEN(UNIT=21, FILE = STR)
    !$OMP DO ORDERED 
    DO I = 1, SURFACE_CURRENT1%SURFACE_POINTS_NUM
        READ(21,*) SURFACE_CURRENT1%POINT_RELATEDFACE(1+HASH0%TYP,I)
    END DO
    !$OMP END DO
    CLOSE(21)
    END IF        

    NULLIFY(SURFACE_CURRENT1)
    NULLIFY(SURFACE_CURRENT2)
    END SUBROUTINE FIND_RELATEDFACE_HASH

    
    
    SUBROUTINE UPDATE_RELATEDFACE(TYP1, TYP2, ISPROJ)
    IMPLICIT NONE
    INTEGER :: TYP1, TYP2
    LOGICAL :: ISPROJ
    INTEGER :: I, J, K, I0, JMIN, L2
    REAL(8) :: RMIN, R
    INTEGER :: L,M, I1, I2, I3, I4, I5, I6, I7, J1,J2,J3,IDX,NUM
    INTEGER :: RIDGE_POINT_NUM, RIDGE_EDGE_NUM, FACE_INDEX
    REAL(8) :: COORD, DIST, TEMPDIST
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT1, SURFACE_CURRENT2
    INTEGER, ALLOCATABLE :: RIDGE_EDGE(:,:)
    REAL(8) :: DIST1, DIST2, DIST3

    IF (TYP1==0) THEN
        SURFACE_CURRENT1 => SURFACE_FLUID
    END IF
    IF (TYP1==1) THEN
        SURFACE_CURRENT1 => SURFACE_PROPEL
    END IF
    IF (TYP1==2) THEN
        SURFACE_CURRENT1 => SURFACE_CASE
    END IF

    IF (TYP2==0) THEN
        SURFACE_CURRENT2 => SURFACE_FLUID
    END IF
    IF (TYP2==1) THEN
        SURFACE_CURRENT2 => SURFACE_PROPEL
    END IF
    IF (TYP2==2) THEN
        SURFACE_CURRENT2 => SURFACE_CASE
    END IF

    K = TYP2 + 1

    DO I=1,SURFACE_CURRENT1%SURFACE_POINTS_NUM
        I1 = SURFACE_CURRENT1%POINT_RELATEDFACE(K,I)         
        IF(I1.NE.0) THEN
            JMIN = 0
            RMIN = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))

            DO J=1,3
                DO L=1,SURFACE_CURRENT2%POINT_FACE_CONNECTION_NUM(SURFACE_CURRENT2%SURFACE_FACES(J,I1))
                    I0 = SURFACE_CURRENT2%POINT_FACE_CONNECTION(L,SURFACE_CURRENT2%SURFACE_FACES(J,I1))

                    IF((SURFACE_MOVING_TYPE>=1 .AND. SURFACE_CURRENT2%FACE_ONINTERFACE(I0) == TYP1) .OR. (SURFACE_MOVING_TYPE<=0 .AND. SURFACE_CURRENT2%FACE_ONINTERFACE(I0) .NE. -1)) THEN
                    !IF(SURFACE_CURRENT2%FACE_ONINTERFACE(I0) .NE. -1) THEN
                        IF(SURFACE_CURRENT1%POINT_TYPE(I)==1 .OR. ((SURFACE_CURRENT1%POINT_TYPE(I)==2 .OR. SURFACE_CURRENT1%POINT_TYPE(I)==3) .AND. (TYP1 == 0 .OR. TYP1 == 2)) .OR. (SURFACE_CURRENT1%POINT_TYPE(I)==4 .AND. TYP1 == 0) ) THEN
                            CALL UNSIGNED_DISTANCE_FACE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(1,I0)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(2,I0)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(3,I0)),R)
                            IF(R<RMIN) THEN
                                RMIN = R
                                JMIN = I0
                            END IF
                        ELSE

                        DO L2=1,3
                            IF(SURFACE_CURRENT2%FACE_DIVIDED_BOUNDARY_ARRAY(L2,I0) .NE. 0) THEN
                                CALL UNSIGNED_DISTANCE_EDGE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(L2,I0)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(MOD(L2,3)+1,I0)),R)
                                IF(R<RMIN) THEN
                                    RMIN = R
                                    JMIN = I0
                                END IF
                            END IF
                        END DO

                        END IF
                    END IF
                END DO
            END DO
            SURFACE_CURRENT1%POINT_RELATEDFACE(K,I) = JMIN
        END IF
    END DO

    IF(ISPROJ) THEN
        DO I=1, SURFACE_CURRENT1%SURFACE_POINTS_NUM
            IF(SURFACE_CURRENT1%POINT_RELATEDFACE(K,I) .NE. 0) THEN

            RIDGE_POINT_NUM = 0
            RIDGE_EDGE_NUM = 0
            DIST1 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
            DIST2 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))
            DIST3 = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1),DOMAIN_MAX(2)-DOMAIN_MIN(2),DOMAIN_MAX(3)-DOMAIN_MIN(3))

            J = SURFACE_CURRENT1%POINT_RELATEDFACE(K,I)
            I2 = SURFACE_CURRENT2%SURFACE_FACES(1,J)
            I3 = SURFACE_CURRENT2%SURFACE_FACES(2,J)
            I4 = SURFACE_CURRENT2%SURFACE_FACES(3,J)

            IF(SURFACE_CURRENT1%POINT_TYPE(I) == 1) THEN
                CALL PROJECTION_FACE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(1,J)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(2,J)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(3,J)))

            ELSEIF(SURFACE_CURRENT1%POINT_TYPE(I)==2) THEN
                ALLOCATE(RIDGE_EDGE(2,100))
                IF(SURFACE_CURRENT2%FACE_DIVIDED_BOUNDARY_ARRAY(1,J)>0) THEN
                    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = I2
                    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = I3
                END IF
                IF(SURFACE_CURRENT2%FACE_DIVIDED_BOUNDARY_ARRAY(2,J)>0) THEN
                    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = I3
                    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = I4
                END IF
                IF(SURFACE_CURRENT2%FACE_DIVIDED_BOUNDARY_ARRAY(3,J)>0) THEN
                    RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                    RIDGE_EDGE(1,RIDGE_EDGE_NUM) = I4
                    RIDGE_EDGE(2,RIDGE_EDGE_NUM) = I2
                END IF			

                IF(.FALSE.) THEN
                    DO L= 1,3
                        I5 = SURFACE_CURRENT2%SURFACE_FACES(L,J)
                        NUM = SURFACE_CURRENT2%POINT_FACE_CONNECTION_NUM(I5)
                        DO M= 1,NUM
                            FACE_INDEX = SURFACE_CURRENT2%POINT_FACE_CONNECTION(M,I5)
                            J1 = SURFACE_CURRENT2%SURFACE_FACES(1,FACE_INDEX)
                            J2 = SURFACE_CURRENT2%SURFACE_FACES(2,FACE_INDEX)
                            J3 = SURFACE_CURRENT2%SURFACE_FACES(3,FACE_INDEX)

                            IF(SURFACE_CURRENT2%POINT_TYPE(J1) .GE. 2) THEN
                                RIDGE_POINT_NUM = RIDGE_POINT_NUM + 1
                            END IF

                            IF(SURFACE_CURRENT2%POINT_TYPE(J2) .GE. 2) THEN
                                RIDGE_POINT_NUM = RIDGE_POINT_NUM + 1
                            END IF

                            IF(SURFACE_CURRENT2%POINT_TYPE(J3) .GE. 2) THEN
                                RIDGE_POINT_NUM = RIDGE_POINT_NUM + 1
                            END IF

                            IF(SURFACE_CURRENT2%POINT_TYPE(J1) .GE. 2 .AND. SURFACE_CURRENT2%POINT_TYPE(J2) .GE. 2) THEN
                                RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                                RIDGE_EDGE(1,RIDGE_EDGE_NUM) = J1
                                RIDGE_EDGE(2,RIDGE_EDGE_NUM) = J2
                            END IF
                            IF(SURFACE_CURRENT2%POINT_TYPE(J2) .GE. 2 .AND. SURFACE_CURRENT2%POINT_TYPE(J3) .GE. 2) THEN
                                RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                                RIDGE_EDGE(1,RIDGE_EDGE_NUM) = J2
                                RIDGE_EDGE(2,RIDGE_EDGE_NUM) = J3
                            END IF
                            IF(SURFACE_CURRENT2%POINT_TYPE(J3) .GE. 2 .AND. SURFACE_CURRENT2%POINT_TYPE(J1) .GE. 2) THEN
                                RIDGE_EDGE_NUM = RIDGE_EDGE_NUM + 1
                                RIDGE_EDGE(1,RIDGE_EDGE_NUM) = J3
                                RIDGE_EDGE(2,RIDGE_EDGE_NUM) = J1
                            END IF
                        END DO
                    END DO
                END IF

                IF(RIDGE_EDGE_NUM==0) THEN

                CALL PROJECTION_FACE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(1,J)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(2,J)),SURFACE_CURRENT2%SURFACE_POINTS(:,SURFACE_CURRENT2%SURFACE_FACES(3,J)))

                ELSE
                    DIST = MAX(DOMAIN_MAX(1)-DOMAIN_MIN(1), DOMAIN_MAX(2)-DOMAIN_MIN(2), DOMAIN_MAX(3)-DOMAIN_MIN(3))
                    DO L=1,RIDGE_EDGE_NUM
                        I6 = RIDGE_EDGE(1,L)
                        I7 = RIDGE_EDGE(2,L)
                        CALL UNSIGNED_DISTANCE_EDGE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,I6),SURFACE_CURRENT2%SURFACE_POINTS(:,I7),TEMPDIST)
                        IF(TEMPDIST<DIST) THEN
                            DIST = TEMPDIST
                            IDX = L
                        END IF
                    END DO
                    I6 = RIDGE_EDGE(1,IDX)
                    I7 = RIDGE_EDGE(2,IDX)
                    CALL PROJECTION_EDGE_POINT(SURFACE_CURRENT1%SURFACE_POINTS(:,I),SURFACE_CURRENT2%SURFACE_POINTS(:,I6),SURFACE_CURRENT2%SURFACE_POINTS(:,I7),COORD)
                END IF
                DEALLOCATE(RIDGE_EDGE)
            END IF			
            END IF
        END DO
    END IF

    NULLIFY(SURFACE_CURRENT1)
    NULLIFY(SURFACE_CURRENT2)
    END SUBROUTINE UPDATE_RELATEDFACE


    
    SUBROUTINE SAVING_COEFFS_SURFACE_STRUCT(FACE_AREA, CORNER_INDEX)
    IMPLICIT NONE
    INTEGER, ALLOCATABLE :: CORNER_INDEX(:)
    REAL(8), ALLOCATABLE :: FACE_AREA(:)

    IF(ALLOCATED(CORNER_INDEX)) THEN
        DEALLOCATE(CORNER_INDEX)
    END IF
    IF(ALLOCATED(FACE_AREA)) THEN
        DEALLOCATE(FACE_AREA)
    END IF

    ALLOCATE(CORNER_INDEX(SURFACE_PROPEL%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_AREA(SURFACE_PROPEL%SURFACE_FACES_NUM))

    CORNER_INDEX = SURFACE_PROPEL%POINT_TYPE   

    END SUBROUTINE SAVING_COEFFS_SURFACE_STRUCT

    

    SUBROUTINE LOADING_COEFFS_SURFACE_STRUCT(TYP, NEW_POINT_NUM, NEW_POINT, NEW_FACE_NUM, NEW_FACE, NEW_LOC, NEW_CORNER_INDEX, NEW_RIDGE_GROUP_NUM, NEW_RIDGE_NUM, NEW_RIDGE)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: I,I1,J1,J2,K,L, J, K1, K2
    INTEGER :: NEW_POINT_NUM
    REAL(8) :: NEW_POINT(3,NEW_POINT_NUM)
    INTEGER :: NEW_FACE_NUM
    INTEGER :: NEW_FACE(3,NEW_FACE_NUM)
    INTEGER :: NEW_LOC(NEW_FACE_NUM)
    INTEGER :: NEW_CORNER_INDEX(NEW_POINT_NUM)
    INTEGER :: NEW_RIDGE_GROUP_NUM
    INTEGER :: NEW_RIDGE_NUM(NEW_RIDGE_GROUP_NUM)
    INTEGER :: NEW_RIDGE(:,:)
    INTEGER, ALLOCATABLE :: NEW_CONNECTION_NUM(:)
    INTEGER, ALLOCATABLE :: NEW_CONNECTION(:,:)
    INTEGER, ALLOCATABLE :: NEW_ONINTERFACE(:)
    INTEGER :: NEW_DIVIDED_REGION_NUM
    INTEGER, ALLOCATABLE :: NEW_DIVIDED_REGION(:)
    INTEGER :: NEW_DIVIDED_BOUNDARY_NUM
    INTEGER, ALLOCATABLE :: NEW_DIVIDED_BOUNDARY(:,:)
    INTEGER, ALLOCATABLE :: TEMP1_REGION_BDRY(:,:)
    INTEGER, ALLOCATABLE :: TEMP2_REGION_BDRY(:,:)
    INTEGER, ALLOCATABLE :: REGION2REGION(:)
    INTEGER, ALLOCATABLE :: BDRY_NUM(:)
    INTEGER, ALLOCATABLE :: TEMP_ONINTERFACE(:)
    INTEGER :: MATCHING_NUM
    LOGICAL :: EXIT_FLAG
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF


    ALLOCATE(NEW_CONNECTION_NUM(NEW_POINT_NUM))
    ALLOCATE(NEW_CONNECTION(30,NEW_POINT_NUM))
    ALLOCATE(NEW_ONINTERFACE(NEW_FACE_NUM))
    ALLOCATE(NEW_DIVIDED_REGION(NEW_FACE_NUM))
    ALLOCATE(NEW_DIVIDED_BOUNDARY(3,NEW_FACE_NUM))

    NEW_CONNECTION_NUM(:) = 0
    NEW_CONNECTION(:,:) = 0

    NEW_ONINTERFACE(:) = 0

    NEW_DIVIDED_REGION(:) = 0
    NEW_DIVIDED_BOUNDARY(:,:) = 0

    CALL POINT_FACE_CONNECTING(NEW_POINT_NUM, NEW_FACE_NUM, NEW_FACE, NEW_CONNECTION_NUM, NEW_CONNECTION)

    DO I=1,NEW_FACE_NUM
        DO K=1,3
            DO J1=1,NEW_RIDGE_GROUP_NUM
                DO J2=1,NEW_RIDGE_NUM(J1)-1
                    IF(NEW_FACE(K,I) == NEW_RIDGE(J1,J2) .AND. NEW_FACE(MOD(K,3)+1,I) == NEW_RIDGE(J1,J2+1)) THEN
                        CALL FACE_NEIGHBOR_FACE(NEW_FACE, NEW_CONNECTION_NUM, NEW_CONNECTION, I, K, I1)

                        DO L=1,3
                            IF(NEW_FACE(L,I1)==NEW_FACE(MOD(K,3)+1,I)) THEN
                                EXIT
                            END IF
                        END DO

                        NEW_DIVIDED_BOUNDARY(K,I) = J1
                        NEW_DIVIDED_BOUNDARY(L,I1) = J1
                    END IF
                END DO
            END DO
        END DO
    END DO

    NEW_DIVIDED_BOUNDARY_NUM = NEW_RIDGE_GROUP_NUM

    if(new_divided_boundary_num .NE. surface_current%face_divided_boundary_num) then
        write(*,*) 'error00'
        write(*,*)  'new',new_divided_boundary_num
        write(*,*)  'old',surface_current%face_divided_boundary_num
    end if

    CALL AREA_DIVIDING(NEW_FACE_NUM, NEW_FACE, NEW_CONNECTION_NUM, NEW_CONNECTION, NEW_DIVIDED_REGION, NEW_DIVIDED_REGION_NUM, NEW_DIVIDED_BOUNDARY)

    if(new_divided_region_num .NE. surface_current%face_divided_region_num) then
        write(*,*) 'error11'
        write(*,*)  'new',new_divided_region_num
        write(*,*)  'old',surface_current%face_divided_region_num
        write(*,*)
    end if

    ALLOCATE(TEMP_ONINTERFACE(new_divided_region_num))
    TEMP_ONINTERFACE = 100
    ALLOCATE(BDRY_NUM(new_divided_region_num))
    BDRY_NUM = 0
    ALLOCATE(TEMP1_REGION_BDRY(new_divided_region_num,20))
    TEMP1_REGION_BDRY = 0

    DO I = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
        DO J = 1, 3
            IF (SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(J,I)>0) THEN
                DO K = 1, 20
                    IF(TEMP1_REGION_BDRY(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I),K)==SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(J,I)) THEN
                        EXIT
                    ELSE IF (TEMP1_REGION_BDRY(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I),K)==0)THEN
                        TEMP1_REGION_BDRY(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I),K) = SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(J,I)
                        BDRY_NUM(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I)) = BDRY_NUM(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I)) + 1
                        TEMP_ONINTERFACE(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I)) = SURFACE_CURRENT%FACE_ONINTERFACE(I)
                        EXIT
                    END IF
                END DO
            END IF
        END DO
    END DO

    DO I = 1, new_divided_region_num
        IF (TEMP_ONINTERFACE(I)==100) THEN
            WRITE(*,*) 'LOADING_COEFFS_SURFACE_STRUCT ERROR 1'
        END IF
    END DO
    ALLOCATE(TEMP2_REGION_BDRY(new_divided_region_num,20))
    TEMP2_REGION_BDRY = 0
    DO I = 1, NEW_FACE_NUM
        DO J = 1, 3
            IF (NEW_DIVIDED_BOUNDARY(J,I)>0) THEN
                DO K = 1, 20
                    IF(TEMP2_REGION_BDRY(NEW_DIVIDED_REGION(I),K)==NEW_DIVIDED_BOUNDARY(J,I)) THEN
                        EXIT
                    ELSE IF (TEMP2_REGION_BDRY(NEW_DIVIDED_REGION(I),K)==0)THEN
                        TEMP2_REGION_BDRY(NEW_DIVIDED_REGION(I),K) = NEW_DIVIDED_BOUNDARY(J,I)
                        EXIT
                    END IF
                END DO
            END IF
        END	DO
    END DO

    ALLOCATE(REGION2REGION(new_divided_region_num))
    REGION2REGION = 0
    DO I = 1, new_divided_region_num
        MATCHING_NUM = 0
        EXIT_FLAG = .FALSE.
        DO J = 1, new_divided_region_num
            DO K1 = 1, BDRY_NUM(I)
                DO K2 = 1, BDRY_NUM(J)
                    IF (TEMP1_REGION_BDRY(I,K1)==TEMP2_REGION_BDRY(J,K2)) THEN
                        MATCHING_NUM = MATCHING_NUM + 1
                        IF (MATCHING_NUM == BDRY_NUM(I)) THEN
                            REGION2REGION(J) = I
                            EXIT_FLAG = .TRUE.
                            EXIT
                        END IF
                    END IF
                END DO
                IF(MATCHING_NUM<K1 .OR. EXIT_FLAG) THEN
                    MATCHING_NUM = 0
                    EXIT
                END IF
            END DO
            IF(EXIT_FLAG) EXIT
        END DO
    END DO

    DO I = 1, NEW_FACE_NUM
        IF (REGION2REGION(NEW_DIVIDED_REGION(I))==0)THEN
            WRITE(*,*) 'LOADING_COEFFS_SURFACE_STRUCT ERROR 2'
        END IF
        NEW_ONINTERFACE(I) = TEMP_ONINTERFACE(REGION2REGION(NEW_DIVIDED_REGION(I)))
    END DO

    CALL RESET_SURFACE(TYP, .TRUE., NEW_POINT_NUM, NEW_FACE_NUM, SURFACE_POINTS = NEW_POINT, SURFACE_FACES = NEW_FACE, POINT_FACE_CONNECTION_NUM = NEW_CONNECTION_NUM, POINT_FACE_CONNECTION = NEW_CONNECTION, &
    FACE_LOCATION = NEW_LOC, FACE_ONINTERFACE = NEW_ONINTERFACE, FACE_DIVIDED_REGION_NUM = NEW_DIVIDED_REGION_NUM, FACE_DIVIDED_REGION_ARRAY = NEW_DIVIDED_REGION, FACE_DIVIDED_BOUNDARY_NUM = NEW_DIVIDED_BOUNDARY_NUM, FACE_DIVIDED_BOUNDARY_ARRAY = NEW_DIVIDED_BOUNDARY)
    
    CALL FIND_POINT_TYPE_USING_BOUNDARY(TYP)
    CALL FIND_RIDGE_GROUP_TYPE(TYP)

    DEALLOCATE(NEW_CONNECTION_NUM)
    DEALLOCATE(NEW_CONNECTION)
    DEALLOCATE(NEW_ONINTERFACE)
    DEALLOCATE(NEW_DIVIDED_REGION)
    DEALLOCATE(NEW_DIVIDED_BOUNDARY)
    DEALLOCATE(TEMP1_REGION_BDRY)
    DEALLOCATE(TEMP2_REGION_BDRY)
    DEALLOCATE(REGION2REGION)
    DEALLOCATE(BDRY_NUM)
    DEALLOCATE(TEMP_ONINTERFACE)
    END SUBROUTINE LOADING_COEFFS_SURFACE_STRUCT

    
    
    SUBROUTINE RESET_DIVIDED_REGION_BOUNDARY(POINT_NUM, POINT, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, POINT_TYPE, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM)
    IMPLICIT NONE
    INTEGER :: POINT_NUM
    REAL(8) :: POINT(:,:)
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: POINT_TYPE(:)
    INTEGER :: DIVIDED_REGION_ARRAY(FACE_NUM)
    INTEGER :: DIVIDED_REGION_NUM
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(3,FACE_NUM)
    INTEGER :: DIVIDED_BOUNDARY_NUM
    LOGICAL, ALLOCATABLE :: RIDGE_EDGE(:,:)
    INTEGER :: I,K

    !CALL TEST_SAVINGDATA_TECPLOT(10000, POINT_NUM, POINT, FACE_NUM, FACE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY)

    ALLOCATE(RIDGE_EDGE(3,FACE_NUM))
    RIDGE_EDGE(:,:) = .FALSE.

    !DO I=1,FACE_NUM
    !    DO K=1,3
    !        CALL FACE_NEIGHBOR_FACE(FACE, CONNECTION_NUM, CONNECTION,I,K, I1)
    !        IF(DIVIDED_REGION_ARRAY(I).NE.DIVIDED_REGION_ARRAY(I1)) THEN
    !            RIDGE_EDGE(K,I) = .TRUE.
    !        END IF
    !    END DO
    !END DO

    DO I=1,FACE_NUM
        DO K=1,3
            IF(DIVIDED_BOUNDARY_ARRAY(K,I).NE.0) THEN
                RIDGE_EDGE(K,I) = .TRUE.
            END IF
        END DO
    END DO

    CALL BOUNDARY_DIVIDING(POINT_NUM, POINT, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, POINT_TYPE, DIVIDED_BOUNDARY_ARRAY, DIVIDED_BOUNDARY_NUM, RIDGE_EDGE)

    CALL AREA_DIVIDING(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_REGION_ARRAY, DIVIDED_REGION_NUM, DIVIDED_BOUNDARY_ARRAY)

    DEALLOCATE(RIDGE_EDGE)

    !CALL TEST_SAVINGDATA_TECPLOT(10001, POINT_NUM, POINT, FACE_NUM, FACE, DIVIDED_REGION_ARRAY, DIVIDED_BOUNDARY_ARRAY)

    WRITE(*,*) 'RESET DIVIDED BOUDNARY & REGION'

    END SUBROUTINE RESET_DIVIDED_REGION_BOUNDARY

    
    
    SUBROUTINE CLASSIFY_PATCH(TYP)
    IMPLICIT NONE
    INTEGER :: TYP
    REAL(8), ALLOCATABLE :: NEWPOINT(:,:)
    INTEGER, ALLOCATABLE :: NEWFACE(:,:)
    REAL(8), ALLOCATABLE :: SURFACE_INITIAL_FACE_AREA(:)
    REAL(8), ALLOCATABLE :: SURFACE_INITIAL_EDGE_LENGTH(:,:)
    REAL(8), ALLOCATABLE :: FACE_B_RATE(:)
    REAL(8), ALLOCATABLE :: POINT_VELOCITY(:,:)
    REAL(8), ALLOCATABLE :: POINT_DISPLACEMENT(:,:)
    INTEGER, ALLOCATABLE :: POINT_FACE_CONNECTION(:,:)
    INTEGER, ALLOCATABLE :: POINT_FACE_CONNECTION_NUM(:)
    INTEGER, ALLOCATABLE :: INITIAL_POINT_TYPE(:)
    INTEGER, ALLOCATABLE :: POINT_TYPE(:)
    INTEGER, ALLOCATABLE :: FACE_LOCATION(:)
    INTEGER, ALLOCATABLE :: FACE_ONINTERFACE(:)
    INTEGER, ALLOCATABLE :: POINT_RELATEDPT(:,:)
    INTEGER, ALLOCATABLE :: POINT_RELATEDFACE(:,:)
    REAL(8), ALLOCATABLE :: FACE_PRESSURE(:)
    REAL(8), ALLOCATABLE :: POINT_FORCE(:,:)
    REAL(8), ALLOCATABLE :: POINT_DISTANCE(:,:)
    INTEGER, ALLOCATABLE :: FACE_IMPACT_ZONE(:,:)
    INTEGER, ALLOCATABLE :: FACE_ABLATION_FLAG(:)
    INTEGER, ALLOCATABLE :: FACE_DIVIDED_REGION_ARRAY(:)
    INTEGER, ALLOCATABLE :: FACE_DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER :: PATCH_NUM
    INTEGER :: TEMP
    INTEGER :: I,J
    INTEGER, ALLOCATABLE :: POINT_INDEX(:)
    INTEGER, ALLOCATABLE :: FACE_INDEX(:)
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    ALLOCATE(NEWPOINT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(NEWFACE(3,SURFACE_CURRENT%SURFACE_FACES_NUM))

    ALLOCATE(POINT_INDEX(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_INDEX(SURFACE_CURRENT%SURFACE_FACES_NUM))

    ALLOCATE(SURFACE_INITIAL_FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(SURFACE_INITIAL_EDGE_LENGTH(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(FACE_B_RATE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(POINT_VELOCITY(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(POINT_DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(POINT_FACE_CONNECTION(30,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(POINT_FACE_CONNECTION_NUM(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(INITIAL_POINT_TYPE(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(POINT_TYPE(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_LOCATION(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(FACE_ONINTERFACE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(POINT_RELATEDPT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(POINT_RELATEDFACE(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_PRESSURE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(POINT_FORCE(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(POINT_DISTANCE(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_IMPACT_ZONE(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(FACE_ABLATION_FLAG(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(FACE_DIVIDED_REGION_ARRAY(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(FACE_DIVIDED_BOUNDARY_ARRAY(3,SURFACE_CURRENT%SURFACE_FACES_NUM))

    PATCH_NUM = 1 
    TEMP = 0

    DO WHILE(TEMP < SURFACE_CURRENT%SURFACE_POINTS_NUM)
        DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SURFACE_CURRENT%FACE_LOCATION(SURFACE_CURRENT%POINT_FACE_CONNECTION(1,I))==PATCH_NUM) THEN
                TEMP = TEMP+1
                NEWPOINT(:,TEMP) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
                POINT_INDEX(I) = TEMP
            END IF
        END DO
        PATCH_NUM = PATCH_NUM + 1
    END DO

    SURFACE_CURRENT%SURFACE_POINTS(:,:) = NEWPOINT(:,:)

    DO J = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
        SURFACE_CURRENT%SURFACE_FACES(:,J) = POINT_INDEX(SURFACE_CURRENT%SURFACE_FACES(:,J))
    END DO

    PATCH_NUM = 1
    TEMP = 0

    DO WHILE(TEMP < SURFACE_CURRENT%SURFACE_FACES_NUM)
        DO J = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
            IF(SURFACE_CURRENT%FACE_LOCATION(J)==PATCH_NUM) THEN
                TEMP = TEMP+1                       
                NEWFACE(:,TEMP) = SURFACE_CURRENT%SURFACE_FACES(:,J)
                FACE_INDEX(J) = TEMP
            END IF
        END DO
        PATCH_NUM = PATCH_NUM + 1
    END DO

    SURFACE_CURRENT%SURFACE_FACES(:,:) = NEWFACE(:,:)

    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
        POINT_VELOCITY(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_VELOCITY(:,I)
        POINT_DISPLACEMENT(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_DISPLACEMENT(:,I)
        POINT_FACE_CONNECTION(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_FACE_CONNECTION(:,I)
        POINT_FACE_CONNECTION_NUM(POINT_INDEX(I)) = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
        INITIAL_POINT_TYPE(POINT_INDEX(I)) = SURFACE_CURRENT%INITIAL_POINT_TYPE(I)
        POINT_TYPE(POINT_INDEX(I)) = SURFACE_CURRENT%POINT_TYPE(I)
        POINT_RELATEDPT(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_RELATEDPT(:,I)
        POINT_RELATEDFACE(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_RELATEDFACE(:,I)
        POINT_FORCE(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_FORCE(:,I)
        POINT_DISTANCE(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_DISTANCE(:,I)
    END DO

    DO J = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
        SURFACE_INITIAL_FACE_AREA(FACE_INDEX(J)) = SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(J)
        SURFACE_INITIAL_EDGE_LENGTH(:,FACE_INDEX(J)) = SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(:,J)
        FACE_B_RATE(FACE_INDEX(J)) = SURFACE_CURRENT%FACE_B_RATE(J)
        FACE_LOCATION(FACE_INDEX(J)) = SURFACE_CURRENT%FACE_LOCATION(J)
        FACE_ONINTERFACE(FACE_INDEX(J)) = SURFACE_CURRENT%FACE_ONINTERFACE(J)
        FACE_PRESSURE(FACE_INDEX(J)) = SURFACE_CURRENT%FACE_PRESSURE(J)
        FACE_IMPACT_ZONE(:,FACE_INDEX(J)) = SURFACE_CURRENT%FACE_IMPACT_ZONE(:,J)
        FACE_ABLATION_FLAG(FACE_INDEX(J)) = SURFACE_CURRENT%FACE_ABLATION_FLAG(J)
        FACE_DIVIDED_REGION_ARRAY(FACE_INDEX(J)) = SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(J)
        FACE_DIVIDED_BOUNDARY_ARRAY(:,FACE_INDEX(J)) = SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(:,J)
    END DO

    DO J = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
        DO I = 1, POINT_FACE_CONNECTION_NUM(J)
            POINT_FACE_CONNECTION(I,J) = FACE_INDEX(POINT_FACE_CONNECTION(I,J))
        END DO
    END DO

    SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(:) = SURFACE_INITIAL_FACE_AREA(:)
    SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(:,:) = SURFACE_INITIAL_EDGE_LENGTH(:,:)
    SURFACE_CURRENT%FACE_B_RATE(:) = FACE_B_RATE(:)
    SURFACE_CURRENT%POINT_VELOCITY(:,:) = POINT_VELOCITY(:,:)
    SURFACE_CURRENT%POINT_DISPLACEMENT(:,:) = POINT_DISPLACEMENT(:,:)
    SURFACE_CURRENT%POINT_FACE_CONNECTION(:,:) = POINT_FACE_CONNECTION(:,:)
    SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(:) = POINT_FACE_CONNECTION_NUM(:)
    SURFACE_CURRENT%INITIAL_POINT_TYPE(:) = INITIAL_POINT_TYPE(:)
    SURFACE_CURRENT%POINT_TYPE(:) = POINT_TYPE(:)
    SURFACE_CURRENT%FACE_LOCATION(:) = FACE_LOCATION(:)
    SURFACE_CURRENT%FACE_ONINTERFACE(:) = FACE_ONINTERFACE(:)
    SURFACE_CURRENT%POINT_RELATEDPT(:,:) = POINT_RELATEDPT(:,:)
    SURFACE_CURRENT%POINT_RELATEDFACE(:,:) = POINT_RELATEDFACE(:,:)
    SURFACE_CURRENT%FACE_PRESSURE(:) = FACE_PRESSURE(:)
    SURFACE_CURRENT%POINT_FORCE(:,:) = POINT_FORCE(:,:)
    SURFACE_CURRENT%POINT_DISTANCE(:,:) = POINT_DISTANCE(:,:)
    SURFACE_CURRENT%FACE_IMPACT_ZONE(:,:) = FACE_IMPACT_ZONE(:,:)
    SURFACE_CURRENT%FACE_ABLATION_FLAG(:) = FACE_ABLATION_FLAG(:)
    SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(:) = FACE_DIVIDED_REGION_ARRAY(:)
    SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(:,:) = FACE_DIVIDED_BOUNDARY_ARRAY(:,:)


    DEALLOCATE(SURFACE_INITIAL_FACE_AREA)
    DEALLOCATE(SURFACE_INITIAL_EDGE_LENGTH)
    DEALLOCATE(FACE_B_RATE)
    DEALLOCATE(POINT_VELOCITY)
    DEALLOCATE(POINT_DISPLACEMENT)
    DEALLOCATE(POINT_FACE_CONNECTION)
    DEALLOCATE(POINT_FACE_CONNECTION_NUM)
    DEALLOCATE(INITIAL_POINT_TYPE)
    DEALLOCATE(POINT_TYPE)
    DEALLOCATE(FACE_LOCATION)
    DEALLOCATE(FACE_ONINTERFACE)
    DEALLOCATE(POINT_RELATEDPT)
    DEALLOCATE(POINT_RELATEDFACE)
    DEALLOCATE(FACE_PRESSURE)
    DEALLOCATE(POINT_FORCE)
    DEALLOCATE(POINT_DISTANCE)
    DEALLOCATE(FACE_IMPACT_ZONE)
    DEALLOCATE(FACE_ABLATION_FLAG)
    DEALLOCATE(FACE_DIVIDED_REGION_ARRAY)
    DEALLOCATE(FACE_DIVIDED_BOUNDARY_ARRAY)

    DEALLOCATE(FACE_INDEX)
    DEALLOCATE(POINT_INDEX)

    DEALLOCATE(NEWFACE)
    DEALLOCATE(NEWPOINT)

    END SUBROUTINE CLASSIFY_PATCH



    SUBROUTINE NEW_POINTFACE_INDEX(TYP, NEWPOINT_NUM, NEWPOINT, NEWFACE_NUM, NEWFACE, POINT_INDEX, FACE_INDEX) !NEW_PATCH_NUM)!, NEW_PATCH_ZIPPER_TYPE)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: NEWPOINT_NUM, NEWFACE_NUM
    REAL(8) :: NEWPOINT(3,NEWPOINT_NUM) 
    INTEGER :: NEWFACE(3,NEWFACE_NUM)
    !INTEGER :: NEW_PATCH_NUM
    INTEGER :: POINT_INDEX(:)
    INTEGER :: FACE_INDEX(:)
    INTEGER :: I,J
    !INTEGER :: NEW_PATCH_ZIPPER_TYPE(NEW_PATCH_NUM) 
    REAL(8), ALLOCATABLE :: SURFACE_INITIAL_FACE_AREA(:)
    REAL(8), ALLOCATABLE :: SURFACE_INITIAL_EDGE_LENGTH(:,:)
    REAL(8), ALLOCATABLE :: FACE_B_RATE(:)
    REAL(8), ALLOCATABLE :: POINT_VELOCITY(:,:)
    REAL(8), ALLOCATABLE :: POINT_DISPLACEMENT(:,:)
    INTEGER, ALLOCATABLE :: POINT_FACE_CONNECTION(:,:)
    INTEGER, ALLOCATABLE :: POINT_FACE_CONNECTION_NUM(:)
    INTEGER, ALLOCATABLE :: INITIAL_POINT_TYPE(:)
    INTEGER, ALLOCATABLE :: POINT_TYPE(:)
    INTEGER, ALLOCATABLE :: FACE_LOCATION(:)
    INTEGER, ALLOCATABLE :: FACE_ONINTERFACE(:)
    INTEGER, ALLOCATABLE :: POINT_RELATEDPT(:,:)
    INTEGER, ALLOCATABLE :: POINT_RELATEDFACE(:,:)
    REAL(8), ALLOCATABLE :: FACE_PRESSURE(:)
    REAL(8), ALLOCATABLE :: POINT_FORCE(:,:)
    REAL(8), ALLOCATABLE :: POINT_DISTANCE(:,:)
    INTEGER, ALLOCATABLE :: FACE_IMPACT_ZONE(:,:)
    INTEGER, ALLOCATABLE :: FACE_ABLATION_FLAG(:)
    INTEGER :: FACE_DIVIDED_REGION_NUM
    INTEGER, ALLOCATABLE :: FACE_DIVIDED_REGION_ARRAY(:)
    INTEGER :: FACE_DIVIDED_BOUNDARY_NUM
    INTEGER, ALLOCATABLE :: FACE_DIVIDED_BOUNDARY_ARRAY(:,:)
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    ALLOCATE(SURFACE_INITIAL_FACE_AREA(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(SURFACE_INITIAL_EDGE_LENGTH(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(FACE_B_RATE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(POINT_VELOCITY(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(POINT_DISPLACEMENT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(POINT_FACE_CONNECTION(30,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(POINT_FACE_CONNECTION_NUM(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(INITIAL_POINT_TYPE(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(POINT_TYPE(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_LOCATION(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(FACE_ONINTERFACE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(POINT_RELATEDPT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(POINT_RELATEDFACE(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_PRESSURE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(POINT_FORCE(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(POINT_DISTANCE(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_IMPACT_ZONE(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(FACE_ABLATION_FLAG(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(FACE_DIVIDED_REGION_ARRAY(SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(FACE_DIVIDED_BOUNDARY_ARRAY(3,SURFACE_CURRENT%SURFACE_FACES_NUM))


    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
        IF(POINT_INDEX(I).NE.0) THEN
            POINT_VELOCITY(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_VELOCITY(:,I)
            POINT_DISPLACEMENT(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_DISPLACEMENT(:,I)
            POINT_FACE_CONNECTION(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_FACE_CONNECTION(:,I)
            POINT_FACE_CONNECTION_NUM(POINT_INDEX(I)) = SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            INITIAL_POINT_TYPE(POINT_INDEX(I)) = SURFACE_CURRENT%INITIAL_POINT_TYPE(I)
            POINT_TYPE(POINT_INDEX(I)) = SURFACE_CURRENT%POINT_TYPE(I)
            POINT_RELATEDPT(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_RELATEDPT(:,I)
            POINT_RELATEDFACE(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_RELATEDFACE(:,I)
            POINT_FORCE(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_FORCE(:,I)
            POINT_DISTANCE(:,POINT_INDEX(I)) = SURFACE_CURRENT%POINT_DISTANCE(:,I)
        END IF
    END DO

    DO J = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(FACE_INDEX(J).NE.0) THEN
            SURFACE_INITIAL_FACE_AREA(FACE_INDEX(J)) = SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(J)
            SURFACE_INITIAL_EDGE_LENGTH(:,FACE_INDEX(J)) = SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(:,J)
            FACE_B_RATE(FACE_INDEX(J)) = SURFACE_CURRENT%FACE_B_RATE(J)
            FACE_LOCATION(FACE_INDEX(J)) = SURFACE_CURRENT%FACE_LOCATION(J)
            FACE_ONINTERFACE(FACE_INDEX(J)) = SURFACE_CURRENT%FACE_ONINTERFACE(J)
            FACE_PRESSURE(FACE_INDEX(J)) = SURFACE_CURRENT%FACE_PRESSURE(J)
            FACE_IMPACT_ZONE(:,FACE_INDEX(J)) = SURFACE_CURRENT%FACE_IMPACT_ZONE(:,J)
            FACE_ABLATION_FLAG(FACE_INDEX(J)) = SURFACE_CURRENT%FACE_ABLATION_FLAG(J)
            FACE_DIVIDED_REGION_ARRAY(FACE_INDEX(J)) = SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(J)
            FACE_DIVIDED_BOUNDARY_ARRAY(:,FACE_INDEX(J)) = SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(:,J)
        END IF
    END DO

    DO J = 1, NEWFACE_NUM
        NEWFACE(:,J) = POINT_INDEX(NEWFACE(:,J))
    END DO

    DO J = 1, NEWPOINT_NUM
        DO I = 1, POINT_FACE_CONNECTION_NUM(J)
            POINT_FACE_CONNECTION(I,J) = FACE_INDEX(POINT_FACE_CONNECTION(I,J))
        END DO
    END DO

    CALL RESET_DIVIDED_REGION_BOUNDARY(NEWPOINT_NUM, NEWPOINT, NEWFACE_NUM, NEWFACE, POINT_FACE_CONNECTION_NUM, POINT_FACE_CONNECTION, POINT_TYPE, FACE_DIVIDED_REGION_ARRAY, FACE_DIVIDED_REGION_NUM, FACE_DIVIDED_BOUNDARY_ARRAY, FACE_DIVIDED_BOUNDARY_NUM)

    FACE_LOCATION(:) = -1

    CALL RESET_SURFACE(TYP, .TRUE., NEWPOINT_NUM, NEWFACE_NUM, NEWPOINT, NEWFACE, &
    SURFACE_INITIAL_FACE_AREA, SURFACE_INITIAL_EDGE_LENGTH, FACE_B_RATE, POINT_VELOCITY, POINT_DISPLACEMENT, &
    POINT_FACE_CONNECTION, POINT_FACE_CONNECTION_NUM, INITIAL_POINT_TYPE, POINT_TYPE, FACE_LOCATION, FACE_ONINTERFACE, POINT_RELATEDPT, POINT_RELATEDFACE, FACE_PRESSURE, POINT_FORCE, POINT_DISTANCE, FACE_IMPACT_ZONE, FACE_ABLATION_FLAG, FACE_DIVIDED_REGION_NUM, FACE_DIVIDED_REGION_ARRAY, FACE_DIVIDED_BOUNDARY_NUM, FACE_DIVIDED_BOUNDARY_ARRAY)
    !SURFACE_CURRENT%SURFACE_PATCHES_NUM = NEW_PATCH_NUM

    CALL FIND_RIDGE_GROUP_TYPE(TYP)

    DEALLOCATE(SURFACE_INITIAL_FACE_AREA)
    DEALLOCATE(SURFACE_INITIAL_EDGE_LENGTH)
    DEALLOCATE(FACE_B_RATE)
    DEALLOCATE(POINT_VELOCITY)
    DEALLOCATE(POINT_DISPLACEMENT)
    DEALLOCATE(POINT_FACE_CONNECTION)
    DEALLOCATE(POINT_FACE_CONNECTION_NUM)
    DEALLOCATE(INITIAL_POINT_TYPE)
    DEALLOCATE(POINT_TYPE)
    DEALLOCATE(FACE_LOCATION)
    DEALLOCATE(FACE_ONINTERFACE)
    DEALLOCATE(POINT_RELATEDPT)
    DEALLOCATE(POINT_RELATEDFACE)
    DEALLOCATE(FACE_PRESSURE)
    DEALLOCATE(POINT_FORCE)
    DEALLOCATE(POINT_DISTANCE)
    DEALLOCATE(FACE_IMPACT_ZONE)
    DEALLOCATE(FACE_ABLATION_FLAG)
    DEALLOCATE(FACE_DIVIDED_REGION_ARRAY)
    DEALLOCATE(FACE_DIVIDED_BOUNDARY_ARRAY)

    END SUBROUTINE NEW_POINTFACE_INDEX

    
    
    RECURSIVE SUBROUTINE PATCH_DIVIDING_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, FACE_LOCATION, FACE_LOCATION_FLAG, USED_FACE, CURRENT_FACE)
    IMPLICIT NONE
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: FACE_LOCATION(:)
    INTEGER :: FACE_LOCATION_FLAG
    LOGICAL :: USED_FACE(:)
    INTEGER :: CURRENT_FACE, NEIGHBOR_FACE
    INTEGER :: I

    USED_FACE(CURRENT_FACE) = .TRUE.
    FACE_LOCATION(CURRENT_FACE) = FACE_LOCATION_FLAG

    DO I=1,3
        CALL FACE_NEIGHBOR_FACE(FACE, CONNECTION_NUM, CONNECTION, CURRENT_FACE, I, NEIGHBOR_FACE)

        IF(.NOT. USED_FACE(NEIGHBOR_FACE)) THEN
            CALL PATCH_DIVIDING_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, FACE_LOCATION, FACE_LOCATION_FLAG, USED_FACE, NEIGHBOR_FACE)
        END IF
    END DO

    END SUBROUTINE PATCH_DIVIDING_RECURSIVE

    
    
    SUBROUTINE RESET_PATCH(TYP)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: I, PATCH_NUM, CURRENT_FACE, TEMP
    LOGICAL :: B
    LOGICAL, ALLOCATABLE :: USED_FACE(:)
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    ALLOCATE(USED_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    USED_FACE(:) = .FALSE.

    PATCH_NUM = 1
    TEMP = 0

    B = .TRUE.
    DO WHILE(B)
        B = .FALSE.
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            IF(.NOT. USED_FACE(I)) THEN
                B = .TRUE.
                CURRENT_FACE = I
                EXIT
            END IF
        END DO

        IF(B) THEN
            CALL PATCH_DIVIDING_RECURSIVE(SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%FACE_LOCATION, PATCH_NUM, USED_FACE, CURRENT_FACE)

            PATCH_NUM = PATCH_NUM + 1
        END IF
    END DO

    DEALLOCATE(USED_FACE)

    END SUBROUTINE RESET_PATCH


    
    RECURSIVE SUBROUTINE FIND_RIDGE_ARRAY_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM, USED_POINT, CURRENT_POINT, DIR)
    IMPLICIT NONE
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER :: RIDGE_FLAG
    INTEGER :: RIDGE(:)
    INTEGER :: RIDGE_NUM
    LOGICAL :: USED_POINT(:)
    INTEGER :: CURRENT_POINT
    INTEGER :: DIR
    INTEGER :: NUM, I, J, K, J1, J2

    USED_POINT(CURRENT_POINT) = .TRUE.

    NUM = 0
    J1 = 0
    J2 = 0

    DO K=1,CONNECTION_NUM(CURRENT_POINT)
        I = CONNECTION(K,CURRENT_POINT)
        DO J=1,3
            IF(FACE(J,I)==CURRENT_POINT .AND. DIVIDED_BOUNDARY_ARRAY(J,I)==RIDGE_FLAG .AND. .NOT. USED_POINT(FACE(MOD(J,3)+1,I))) THEN
                NUM = NUM + 1
                IF(NUM==1) THEN
                    J1 = FACE(MOD(J,3)+1,I)
                ELSE
                    J2 = FACE(MOD(J,3)+1,I)
                END IF
                EXIT
            END IF
        END DO
        IF (NUM >1) EXIT
    END DO

    IF(DIR==0) THEN
        IF(J1>0) THEN
            CALL FIND_RIDGE_ARRAY_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM, USED_POINT, J1, -1)

            RIDGE_NUM = RIDGE_NUM + 1
            RIDGE(RIDGE_NUM) = CURRENT_POINT
        END IF

        IF(NUM>=2 .AND. J2>0) THEN
            CALL FIND_RIDGE_ARRAY_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM, USED_POINT, J2, 1)
        END IF

    ELSE IF(DIR==-1) THEN

    IF(NUM>=1 .AND. J1>0) THEN
        CALL FIND_RIDGE_ARRAY_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM, USED_POINT, J1, -1)
    END IF

    RIDGE_NUM = RIDGE_NUM + 1
    RIDGE(RIDGE_NUM) = CURRENT_POINT

    ELSE IF(DIR==1) THEN

    RIDGE_NUM = RIDGE_NUM + 1
    RIDGE(RIDGE_NUM) = CURRENT_POINT

    IF(NUM>=1 .AND. J1>0) THEN
        CALL FIND_RIDGE_ARRAY_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM, USED_POINT, J1, 1)
    END IF

    END IF

    END SUBROUTINE FIND_RIDGE_ARRAY_RECURSIVE

    
    
    SUBROUTINE FIND_RIDGE_ARRAY_TYPE(TYP, RIDGE_FLAG, RIDGE, RIDGE_NUM)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: RIDGE_FLAG
    INTEGER :: RIDGE(:)
    INTEGER :: RIDGE_NUM
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    CALL FIND_RIDGE_ARRAY(SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM)

    END SUBROUTINE FIND_RIDGE_ARRAY_TYPE

    
    
    SUBROUTINE FIND_RIDGE_ARRAY(POINT_NUM, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM)
    IMPLICIT NONE
    INTEGER :: POINT_NUM
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER :: RIDGE_FLAG
    INTEGER :: RIDGE(:)
    INTEGER :: RIDGE_NUM
    INTEGER :: CURRENT_POINT
    LOGICAL, ALLOCATABLE :: USED_POINT(:)
    INTEGER :: I,K

    RIDGE_NUM = 0

    ALLOCATE(USED_POINT(POINT_NUM))
    USED_POINT(:) = .FALSE.

    CURRENT_POINT =  0
    DO I=1,FACE_NUM
        DO K=1,3
            IF(DIVIDED_BOUNDARY_ARRAY(K,I)==RIDGE_FLAG) THEN
                CURRENT_POINT = FACE(K,I)
                EXIT
            END IF
        END DO
        IF(CURRENT_POINT>0) THEN
            IF(.NOT. USED_POINT(CURRENT_POINT)) THEN
                CALL FIND_RIDGE_ARRAY_RECURSIVE(FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, RIDGE_FLAG, RIDGE, RIDGE_NUM, USED_POINT, CURRENT_POINT, 0)
            END IF
            EXIT
        END IF
    END DO

    DEALLOCATE(USED_POINT)

    END SUBROUTINE FIND_RIDGE_ARRAY


    
    SUBROUTINE FIND_RIDGE_GROUP_TYPE(TYP)
    IMPLICIT NONE
    INTEGER :: TYP
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    CALL FIND_RIDGE_GROUP(SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_NUM, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, SURFACE_CURRENT%RIDGE_NUM, SURFACE_CURRENT%RIDGE)

    END SUBROUTINE FIND_RIDGE_GROUP_TYPE

    
    
    SUBROUTINE FIND_RIDGE_GROUP(POINT_NUM, FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_NUM, DIVIDED_BOUNDARY_ARRAY, RIDGE_NUM, RIDGE)
    IMPLICIT NONE
    INTEGER :: POINT_NUM
    INTEGER :: FACE_NUM
    INTEGER :: FACE(:,:)
    INTEGER :: CONNECTION_NUM(:)
    INTEGER :: CONNECTION(:,:)
    INTEGER :: DIVIDED_BOUNDARY_NUM
    INTEGER :: DIVIDED_BOUNDARY_ARRAY(:,:)
    INTEGER, ALLOCATABLE :: RIDGE_NUM(:)
    INTEGER, ALLOCATABLE :: RIDGE(:,:)
    INTEGER :: I

    IF(ALLOCATED(RIDGE_NUM)) THEN
        DEALLOCATE(RIDGE_NUM)
    END IF
    ALLOCATE(RIDGE_NUM(DIVIDED_BOUNDARY_NUM))
    RIDGE_NUM = 0

    IF(ALLOCATED(RIDGE)) THEN
        DEALLOCATE(RIDGE)
    END IF
    ALLOCATE(RIDGE(DIVIDED_BOUNDARY_NUM,1000))
    RIDGE(:,:) = 0

    DO I= 1, DIVIDED_BOUNDARY_NUM
        CALL FIND_RIDGE_ARRAY(POINT_NUM,FACE_NUM, FACE, CONNECTION_NUM, CONNECTION, DIVIDED_BOUNDARY_ARRAY, I, RIDGE(I,:), RIDGE_NUM(I))
    END DO

    END SUBROUTINE FIND_RIDGE_GROUP


    SUBROUTINE RESET_SURFACE(TYP, FLAG, POINT_NUM, FACE_NUM, SURFACE_POINTS, SURFACE_FACES, &
    SURFACE_INITIAL_FACE_AREA, SURFACE_INITIAL_EDGE_LENGTH, FACE_B_RATE, POINT_VELOCITY, POINT_DISPLACEMENT, &
    POINT_FACE_CONNECTION, POINT_FACE_CONNECTION_NUM, INITIAL_POINT_TYPE, POINT_TYPE, FACE_LOCATION, FACE_ONINTERFACE, POINT_RELATEDPT, POINT_RELATEDFACE, FACE_PRESSURE, POINT_FORCE, POINT_DISTANCE, FACE_IMPACT_ZONE, FACE_ABLATION_FLAG, FACE_DIVIDED_REGION_NUM, FACE_DIVIDED_REGION_ARRAY, FACE_DIVIDED_BOUNDARY_NUM, FACE_DIVIDED_BOUNDARY_ARRAY)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL :: FLAG
    INTEGER :: POINT_NUM, FACE_NUM
    REAL(8), OPTIONAL :: SURFACE_POINTS(3,POINT_NUM)
    INTEGER, OPTIONAL :: SURFACE_FACES(:,:)
    REAL(8), OPTIONAL :: SURFACE_INITIAL_FACE_AREA(FACE_NUM)
    REAL(8), OPTIONAL :: SURFACE_INITIAL_EDGE_LENGTH(3,FACE_NUM)
    REAL(8), OPTIONAL :: FACE_B_RATE(FACE_NUM)
    REAL(8), OPTIONAL :: POINT_VELOCITY(3,POINT_NUM)
    REAL(8), OPTIONAL :: POINT_DISPLACEMENT(3,POINT_NUM)
    INTEGER, OPTIONAL :: POINT_FACE_CONNECTION(30,POINT_NUM)
    INTEGER, OPTIONAL :: POINT_FACE_CONNECTION_NUM(POINT_NUM)
    INTEGER, OPTIONAL :: INITIAL_POINT_TYPE(POINT_NUM)  
    INTEGER, OPTIONAL :: POINT_TYPE(POINT_NUM)  
    INTEGER, OPTIONAL :: FACE_LOCATION(FACE_NUM)
    INTEGER, OPTIONAL :: FACE_ONINTERFACE(FACE_NUM)
    INTEGER, OPTIONAL :: POINT_RELATEDPT(3,POINT_NUM)
    INTEGER, OPTIONAL :: POINT_RELATEDFACE(3,POINT_NUM)
    REAL(8), OPTIONAL :: FACE_PRESSURE(FACE_NUM)
    REAL(8), OPTIONAL :: POINT_FORCE(3,POINT_NUM)
    REAL(8), OPTIONAL :: POINT_DISTANCE(3,POINT_NUM)
    INTEGER, OPTIONAL :: FACE_IMPACT_ZONE(3,FACE_NUM)
    INTEGER, OPTIONAL :: FACE_ABLATION_FLAG(FACE_NUM)
    INTEGER, OPTIONAL :: FACE_DIVIDED_REGION_NUM
    INTEGER, OPTIONAL :: FACE_DIVIDED_REGION_ARRAY(FACE_NUM)
    INTEGER, OPTIONAL :: FACE_DIVIDED_BOUNDARY_NUM
    INTEGER, OPTIONAL :: FACE_DIVIDED_BOUNDARY_ARRAY(3,FACE_NUM)
    INTEGER :: I, I1, I2, I3
    REAL(8) :: R, V1(3), V2(3), V3(3), N(3), L, R1, R2, R3, F_SIZE, F_SHAPE
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    IF(ALLOCATED(SURFACE_CURRENT%SURFACE_POINTS)) THEN
        DEALLOCATE(SURFACE_CURRENT%SURFACE_POINTS)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%SURFACE_FACES)) THEN
        DEALLOCATE(SURFACE_CURRENT%SURFACE_FACES)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA)) THEN
        DEALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH)) THEN
        DEALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%SURFACE_INITIAL_MESH_QUALITY)) THEN
        DEALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_MESH_QUALITY)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%FACE_B_RATE)) THEN
        DEALLOCATE(SURFACE_CURRENT%FACE_B_RATE)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%POINT_VELOCITY)) THEN
        DEALLOCATE(SURFACE_CURRENT%POINT_VELOCITY)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%POINT_DISPLACEMENT)) THEN
        DEALLOCATE(SURFACE_CURRENT%POINT_DISPLACEMENT)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%POINT_FACE_CONNECTION)) THEN
        DEALLOCATE(SURFACE_CURRENT%POINT_FACE_CONNECTION)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM)) THEN
        DEALLOCATE(SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%INITIAL_POINT_TYPE)) THEN
        DEALLOCATE(SURFACE_CURRENT%INITIAL_POINT_TYPE)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%POINT_TYPE)) THEN
        DEALLOCATE(SURFACE_CURRENT%POINT_TYPE)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%FACE_LOCATION)) THEN
        DEALLOCATE(SURFACE_CURRENT%FACE_LOCATION)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%FACE_ONINTERFACE)) THEN
        DEALLOCATE(SURFACE_CURRENT%FACE_ONINTERFACE)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%POINT_RELATEDPT)) THEN
        DEALLOCATE(SURFACE_CURRENT%POINT_RELATEDPT)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%POINT_RELATEDFACE)) THEN
        DEALLOCATE(SURFACE_CURRENT%POINT_RELATEDFACE)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%FACE_PRESSURE)) THEN
        DEALLOCATE(SURFACE_CURRENT%FACE_PRESSURE)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%POINT_FORCE)) THEN
        DEALLOCATE(SURFACE_CURRENT%POINT_FORCE)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%POINT_DISTANCE)) THEN
        DEALLOCATE(SURFACE_CURRENT%POINT_DISTANCE)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%FACE_IMPACT_ZONE)) THEN
        DEALLOCATE(SURFACE_CURRENT%FACE_IMPACT_ZONE)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%FACE_ABLATION_FLAG)) THEN
        DEALLOCATE(SURFACE_CURRENT%FACE_ABLATION_FLAG)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY)) THEN
        DEALLOCATE(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY)
    END IF
    IF(ALLOCATED(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY)) THEN
        DEALLOCATE(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY)
    END IF

    IF(FLAG) THEN

    SURFACE_CURRENT%SURFACE_POINTS_NUM = POINT_NUM
    SURFACE_CURRENT%SURFACE_FACES_NUM = FACE_NUM

    ALLOCATE(SURFACE_CURRENT%SURFACE_POINTS(3,POINT_NUM))
    !IF(TYP==0) THEN
    ALLOCATE(SURFACE_CURRENT%SURFACE_FACES(3,FACE_NUM))
    !ELSE
    !    ALLOCATE(SURFACE_CURRENT%SURFACE_FACES(4,FACE_NUM))
    !END IF
    ALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(FACE_NUM))
    ALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(3,FACE_NUM))
    ALLOCATE(SURFACE_CURRENT%FACE_B_RATE(FACE_NUM))
    ALLOCATE(SURFACE_CURRENT%POINT_VELOCITY(3,POINT_NUM))
    ALLOCATE(SURFACE_CURRENT%POINT_DISPLACEMENT(3,POINT_NUM))
    ALLOCATE(SURFACE_CURRENT%POINT_FACE_CONNECTION(30,POINT_NUM))
    ALLOCATE(SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(POINT_NUM))
    ALLOCATE(SURFACE_CURRENT%INITIAL_POINT_TYPE(POINT_NUM))
    ALLOCATE(SURFACE_CURRENT%POINT_TYPE(POINT_NUM))
    ALLOCATE(SURFACE_CURRENT%FACE_LOCATION(FACE_NUM))
    ALLOCATE(SURFACE_CURRENT%FACE_ONINTERFACE(FACE_NUM))
    ALLOCATE(SURFACE_CURRENT%POINT_RELATEDPT(3,POINT_NUM))
    ALLOCATE(SURFACE_CURRENT%POINT_RELATEDFACE(3,POINT_NUM))
    ALLOCATE(SURFACE_CURRENT%FACE_PRESSURE(FACE_NUM))
    ALLOCATE(SURFACE_CURRENT%POINT_FORCE(3,POINT_NUM))
    ALLOCATE(SURFACE_CURRENT%POINT_DISTANCE(3,POINT_NUM))
    ALLOCATE(SURFACE_CURRENT%FACE_IMPACT_ZONE(3,FACE_NUM))
    ALLOCATE(SURFACE_CURRENT%FACE_ABLATION_FLAG(FACE_NUM))
    ALLOCATE(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(FACE_NUM))
    ALLOCATE(SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(3,FACE_NUM))
    IF(TYP .NE. 0) THEN
        ALLOCATE(SURFACE_CURRENT%SURFACE_INITIAL_MESH_QUALITY(FACE_NUM/2))
    END IF

    IF(PRESENT(SURFACE_POINTS)) THEN
        SURFACE_CURRENT%SURFACE_POINTS(:,:) = SURFACE_POINTS(:,:)
    END IF

    IF(PRESENT(SURFACE_FACES)) THEN
        SURFACE_CURRENT%SURFACE_FACES(:,:) = SURFACE_FACES(:,:)
    END IF

    IF(PRESENT(SURFACE_INITIAL_FACE_AREA)) THEN
        SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(:) = SURFACE_INITIAL_FACE_AREA(:)
        SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(:,:) = SURFACE_INITIAL_EDGE_LENGTH(:,:)
    ELSE
        SURFACE_CURRENT%MESH_SIZE = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
        SURFACE_CURRENT%MESH_SIZE_MAX = 0.

        !$OMP PARALLEL DO PRIVATE(I,R),REDUCTION(MIN:MESH_SIZE),REDUCTION(MAX:MESH_SIZE_MAX)
        DO I = 1, FACE_NUM

        I1 = SURFACE_CURRENT%SURFACE_FACES(1,I)
        I2 = SURFACE_CURRENT%SURFACE_FACES(2,I)
        I3 = SURFACE_CURRENT%SURFACE_FACES(3,I)

        V1 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
        V2 = SURFACE_CURRENT%SURFACE_POINTS(:,I3) - SURFACE_CURRENT%SURFACE_POINTS(:,I1)
        V3 = SURFACE_CURRENT%SURFACE_POINTS(:,I2) - SURFACE_CURRENT%SURFACE_POINTS(:,I3)

        CALL VEC_CURL1(V1,V2, N)

        R = SQRT(DOT_PRODUCT(N,N))/2

        SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(I) = R
        SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(1,I) = SQRT(DOT_PRODUCT(V1,V1))
        SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(2,I) = SQRT(DOT_PRODUCT(V3,V3))
        SURFACE_CURRENT%SURFACE_INITIAL_EDGE_LENGTH(3,I) = SQRT(DOT_PRODUCT(V2,V2))

        R1 = SQRT(DOT_PRODUCT(V1,V1))
        R2 = SQRT(DOT_PRODUCT(V2,V2))
        R3 = SQRT(DOT_PRODUCT(V3,V3))
        L = (R1 + R2 + R3) / 3.

        IF(SURFACE_CURRENT%MESH_SIZE > L) THEN
            SURFACE_CURRENT%MESH_SIZE = L
        END IF
        IF(SURFACE_CURRENT%MESH_SIZE_MAX < L) THEN
            SURFACE_CURRENT%MESH_SIZE_MAX = L
        END IF
        END DO
        !$OMP END PARALLEL DO

        SURFACE_CURRENT%HASH_SIZE = SURFACE_CURRENT%MESH_SIZE_MAX * 5.
    END IF

    IF(TYP .NE. 0) THEN
        DO I=1,FACE_NUM/2
            CALL MESH_QUALITY_SQUARE_ONE(SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,2*I-1)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,2*I-1)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,2*I-1)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,2*I)), SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(2*I-1) + SURFACE_CURRENT%SURFACE_INITIAL_FACE_AREA(2*I),        SURFACE_CURRENT%SURFACE_INITIAL_MESH_QUALITY(I), F_SIZE, F_SHAPE)
        END DO
    END IF

    IF(PRESENT(FACE_B_RATE)) THEN
        SURFACE_CURRENT%FACE_B_RATE(:) = FACE_B_RATE(:)
    ELSE
        SURFACE_CURRENT%FACE_B_RATE(:) = 0.
    END IF

    IF(PRESENT(POINT_VELOCITY)) THEN
        SURFACE_CURRENT%POINT_VELOCITY(:,:) = POINT_VELOCITY(:,:)
    ELSE
        SURFACE_CURRENT%POINT_VELOCITY(:,:) = 0.
    END IF

    IF(PRESENT(POINT_DISPLACEMENT)) THEN
        SURFACE_CURRENT%POINT_DISPLACEMENT(:,:) = POINT_DISPLACEMENT(:,:)
    ELSE
        SURFACE_CURRENT%POINT_DISPLACEMENT(:,:) = 0.
    END IF

    IF(PRESENT(POINT_FACE_CONNECTION)) THEN
        SURFACE_CURRENT%POINT_FACE_CONNECTION(:,:) = POINT_FACE_CONNECTION(:,:)
        SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(:) = POINT_FACE_CONNECTION_NUM(:)
    ELSE
        CALL POINT_FACE_CONNECTING_TYPE(TYP)
    END IF

    IF(PRESENT(FACE_LOCATION)) THEN
        SURFACE_CURRENT%FACE_LOCATION(:) = FACE_LOCATION(:)

        IF(TYP==1) THEN
            CALL RESET_PATCH(1)
            IF(FACE_LOCATION(1) .NE. -1) THEN
                IF(ALLOCATED(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP)) THEN
                    DEALLOCATE(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP)
                END IF
                CALL FIND_PATCH_NUM(1)
                ALLOCATE(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_CURRENT%SURFACE_PATCHES_NUM))
                SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(:) = 0
            END IF
        END IF
    ELSE
        SURFACE_CURRENT%FACE_LOCATION(:) = -1

        IF(TYP==1) THEN
            CALL RESET_PATCH(1)
            !CALL FIND_PATCH_NUM(1)
            !ALLOCATE(SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_CURRENT%SURFACE_PATCHES_NUM))
            !SURFACE_CURRENT%SURFACE_PATCHES_TOPCHANGE_TYP(:) = 0
        END IF
    END IF
    IF(PRESENT(POINT_DISTANCE)) THEN
        SURFACE_CURRENT%POINT_DISTANCE(:,:) = POINT_DISTANCE(:,:)
    ELSE
        SURFACE_CURRENT%POINT_DISTANCE(:,:) = 0.
    END IF

    IF(PRESENT(FACE_ONINTERFACE)) THEN
        SURFACE_CURRENT%FACE_ONINTERFACE(:) = FACE_ONINTERFACE(:)
    ELSE
        !CALL FIND_INTERFACE(TYP,2)
        SURFACE_CURRENT%FACE_ONINTERFACE(:) = -1
    END IF

    IF(PRESENT(POINT_RELATEDPT)) THEN
        SURFACE_CURRENT%POINT_RELATEDPT(:,:) = POINT_RELATEDPT(:,:)
    ELSE
        SURFACE_CURRENT%POINT_RELATEDPT(:,:) = 0
    END IF

    IF(PRESENT(POINT_RELATEDFACE)) THEN
        SURFACE_CURRENT%POINT_RELATEDFACE(:,:) = POINT_RELATEDFACE(:,:)
    ELSE
        SURFACE_CURRENT%POINT_RELATEDFACE(:,:) = 0
    END IF
    IF(PRESENT(FACE_PRESSURE)) THEN
        SURFACE_CURRENT%FACE_PRESSURE(:) = FACE_PRESSURE(:)
    ELSE
        SURFACE_CURRENT%FACE_PRESSURE(:) = 0.
    END IF
    IF(PRESENT(POINT_FORCE)) THEN
        SURFACE_CURRENT%POINT_FORCE(:,:) = POINT_FORCE(:,:)
    ELSE
        SURFACE_CURRENT%POINT_FORCE(:,:) = 0.
    END IF           
    IF(PRESENT(FACE_IMPACT_ZONE)) THEN
        SURFACE_CURRENT%FACE_IMPACT_ZONE(:,:) = FACE_IMPACT_ZONE(:,:)
    ELSE
        SURFACE_CURRENT%FACE_IMPACT_ZONE(:,:) = 0
    END IF

    IF(PRESENT(POINT_TYPE)) THEN
        SURFACE_CURRENT%POINT_TYPE(:) = POINT_TYPE(:)
        SURFACE_CURRENT%INITIAL_POINT_TYPE(:) = INITIAL_POINT_TYPE(:)
    ELSE
        SURFACE_CURRENT%POINT_TYPE(:) = -1
        !CALL FIND_POINT_TYPE(TYP)
    END IF

    IF(PRESENT(FACE_ABLATION_FLAG)) THEN
        SURFACE_CURRENT%FACE_ABLATION_FLAG(:) = FACE_ABLATION_FLAG(:)
    ELSE
        SURFACE_CURRENT%FACE_ABLATION_FLAG(:) = 0
    END IF

    IF(PRESENT(FACE_DIVIDED_REGION_ARRAY)) THEN
        SURFACE_CURRENT%FACE_DIVIDED_REGION_NUM = FACE_DIVIDED_REGION_NUM
        SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(:) = FACE_DIVIDED_REGION_ARRAY(:)
    ELSE
        SURFACE_CURRENT%FACE_DIVIDED_REGION_NUM = 0
        SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(:) = 0
    END IF

    IF(PRESENT(FACE_DIVIDED_BOUNDARY_ARRAY)) THEN
        SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_NUM = FACE_DIVIDED_BOUNDARY_NUM
        SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(:,:) = FACE_DIVIDED_BOUNDARY_ARRAY(:,:)
    ELSE
        SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_NUM = 0
        SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(:,:) = 0
    END IF

    END IF
    END SUBROUTINE RESET_SURFACE
    END MODULE OPERATORS_3D
