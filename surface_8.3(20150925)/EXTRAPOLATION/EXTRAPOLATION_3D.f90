MODULE EXTRAPOLATION_3D
    USE SURFACE_MODULE_3D
    USE SURFACES_3D
    USE OPERATORS_3D
    USE HASHING_3D
    USE SRMS_DATATRANS_MOD_3D
    IMPLICIT NONE

    TYPE INTERFACE_CLUSTER
	INTEGER :: POINT_NUM
	INTEGER :: FACE_NUM
        REAL(8), ALLOCATABLE :: POINT(:,:)
        INTEGER, ALLOCATABLE :: FACE(:,:)
        INTEGER, ALLOCATABLE :: CONNECTION(:,:)
        INTEGER, ALLOCATABLE :: CONNECTION_NUM(:)
        INTEGER, ALLOCATABLE :: POINT_LOC(:,:)
        INTEGER, ALLOCATABLE :: FACE_LOC(:,:)
	LOGICAL, ALLOCATABLE :: FACE_USED(:,:)
	INTEGER :: PROPEL_BDRY_NUM, CASE_BDRY_NUM
	INTEGER, ALLOCATABLE :: PROPEL_BDRY_CONNECTION_NUM(:)
	INTEGER, ALLOCATABLE :: CASE_BDRY_CONNECTION_NUM(:)
	INTEGER, ALLOCATABLE :: PROPEL_BDRY(:,:)
	INTEGER, ALLOCATABLE :: CASE_BDRY(:,:)
    END TYPE

    CONTAINS



    SUBROUTINE INITIAL_INTERFACE(TYP, STRUCT_INTERFACE)
	IMPLICIT NONE
	TYPE(INTERFACE_CLUSTER), POINTER :: STRUCT_INTERFACE
	INTEGER :: TYP

IF(TYP==1) THEN

	STRUCT_INTERFACE%POINT_NUM = 0
	STRUCT_INTERFACE%FACE_NUM = 0
	STRUCT_INTERFACE%PROPEL_BDRY_NUM = 0
	STRUCT_INTERFACE%CASE_BDRY_NUM = 0
	ALLOCATE(STRUCT_INTERFACE%POINT(3,SURFACE_PROPEL%SURFACE_POINTS_NUM+SURFACE_CASE%SURFACE_POINTS_NUM))
	ALLOCATE(STRUCT_INTERFACE%FACE(3,SURFACE_PROPEL%SURFACE_FACES_NUM+SURFACE_CASE%SURFACE_FACES_NUM))
	ALLOCATE(STRUCT_INTERFACE%CONNECTION(20,SURFACE_PROPEL%SURFACE_POINTS_NUM+SURFACE_CASE%SURFACE_POINTS_NUM))
	ALLOCATE(STRUCT_INTERFACE%CONNECTION_NUM(SURFACE_PROPEL%SURFACE_POINTS_NUM+SURFACE_CASE%SURFACE_POINTS_NUM))
	ALLOCATE(STRUCT_INTERFACE%POINT_LOC(4, SURFACE_PROPEL%SURFACE_POINTS_NUM+SURFACE_CASE%SURFACE_POINTS_NUM))
	ALLOCATE(STRUCT_INTERFACE%FACE_LOC(4, SURFACE_PROPEL%SURFACE_FACES_NUM+SURFACE_CASE%SURFACE_FACES_NUM))
	ALLOCATE(STRUCT_INTERFACE%PROPEL_BDRY(2,SURFACE_PROPEL%SURFACE_FACES_NUM))
	ALLOCATE(STRUCT_INTERFACE%CASE_BDRY(2,SURFACE_CASE%SURFACE_FACES_NUM))
	ALLOCATE(STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM(20))
	ALLOCATE(STRUCT_INTERFACE%CASE_BDRY_CONNECTION_NUM(20))
	STRUCT_INTERFACE%POINT = 0
	STRUCT_INTERFACE%FACE = 0
        STRUCT_INTERFACE%CONNECTION = 0
        STRUCT_INTERFACE%CONNECTION_NUM = 0
        STRUCT_INTERFACE%POINT_LOC = 0
        STRUCT_INTERFACE%FACE_LOC = 0
	STRUCT_INTERFACE%PROPEL_BDRY = 0
	STRUCT_INTERFACE%CASE_BDRY = 0
	STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM = 0
	 STRUCT_INTERFACE%CASE_BDRY_CONNECTION_NUM = 0

ELSE
	STRUCT_INTERFACE%POINT_NUM = 0
	STRUCT_INTERFACE%FACE_NUM = 0
	STRUCT_INTERFACE%PROPEL_BDRY_NUM = 0
	STRUCT_INTERFACE%CASE_BDRY_NUM = 0
	ALLOCATE(STRUCT_INTERFACE%POINT(3,SURFACE_FLUID%SURFACE_POINTS_NUM))
	ALLOCATE(STRUCT_INTERFACE%FACE(3,SURFACE_FLUID%SURFACE_FACES_NUM))
	ALLOCATE(STRUCT_INTERFACE%CONNECTION(20,SURFACE_FLUID%SURFACE_POINTS_NUM))
	ALLOCATE(STRUCT_INTERFACE%CONNECTION_NUM(SURFACE_FLUID%SURFACE_POINTS_NUM))
	ALLOCATE(STRUCT_INTERFACE%POINT_LOC(3, SURFACE_FLUID%SURFACE_POINTS_NUM))
	ALLOCATE(STRUCT_INTERFACE%FACE_LOC(3, SURFACE_FLUID%SURFACE_FACES_NUM))
	ALLOCATE(STRUCT_INTERFACE%PROPEL_BDRY(2,SURFACE_FLUID%SURFACE_FACES_NUM))
	ALLOCATE(STRUCT_INTERFACE%CASE_BDRY(2,SURFACE_FLUID%SURFACE_FACES_NUM))
	ALLOCATE(STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM(20))
	ALLOCATE(STRUCT_INTERFACE%CASE_BDRY_CONNECTION_NUM(20))
	STRUCT_INTERFACE%POINT = 0
	STRUCT_INTERFACE%FACE = 0
        STRUCT_INTERFACE%CONNECTION = 0
        STRUCT_INTERFACE%CONNECTION_NUM = 0
        STRUCT_INTERFACE%POINT_LOC = 0
        STRUCT_INTERFACE%FACE_LOC = 0
	STRUCT_INTERFACE%PROPEL_BDRY = 0
	STRUCT_INTERFACE%CASE_BDRY = 0
	STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM = 0
	STRUCT_INTERFACE%CASE_BDRY_CONNECTION_NUM = 0


END IF

    END SUBROUTINE
    
    SUBROUTINE DELETE_INTERFACE(STRUCT_INTERFACE)
	IMPLICIT NONE
	TYPE(INTERFACE_CLUSTER), POINTER :: STRUCT_INTERFACE

	DEALLOCATE(STRUCT_INTERFACE%POINT)
	DEALLOCATE(STRUCT_INTERFACE%FACE)
	DEALLOCATE(STRUCT_INTERFACE%CONNECTION)
	DEALLOCATE(STRUCT_INTERFACE%CONNECTION_NUM)
	DEALLOCATE(STRUCT_INTERFACE%POINT_LOC)
	DEALLOCATE(STRUCT_INTERFACE%FACE_LOC)
	DEALLOCATE(STRUCT_INTERFACE%PROPEL_BDRY)
	DEALLOCATE(STRUCT_INTERFACE%CASE_BDRY)
	DEALLOCATE(STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM)
	DEALLOCATE(STRUCT_INTERFACE%CASE_BDRY_CONNECTION_NUM)

    END SUBROUTINE



    RECURSIVE SUBROUTINE CONNECTING_INTERFACE_CLUSTER(TYP, ORIGIN_FACE_INDEX, STRUCT_INTERFACE)
        IMPLICIT NONE
	INTEGER :: TYP, ORIGIN_FACE_INDEX, ORIGIN_POINT_INDEX, TEMP_FACE_INDEX, CURRENT_FACE_INDEX, CURRENT_POINT_INDEX
	TYPE(INTERFACE_CLUSTER),POINTER :: STRUCT_INTERFACE
	TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
	INTEGER :: I, J, TEMP
	INTEGER :: USED_POINT_INDEX


	IF (TYP==0) THEN
	    SURFACE_CURRENT=>SURFACE_FLUID
	ELSE IF(TYP==1) THEN
	    SURFACE_CURRENT=>SURFACE_PROPEL
	ELSE IF(TYP==2) THEN
	    SURFACE_CURRENT=>SURFACE_CASE
	END IF

IF(TYP>0) THEN
	STRUCT_INTERFACE%FACE_NUM = STRUCT_INTERFACE%FACE_NUM + 1
	CURRENT_FACE_INDEX = STRUCT_INTERFACE%FACE_NUM
	STRUCT_INTERFACE%FACE_LOC(1,CURRENT_FACE_INDEX) = ORIGIN_FACE_INDEX
	STRUCT_INTERFACE%FACE_LOC(2,CURRENT_FACE_INDEX) = TYP
	STRUCT_INTERFACE%FACE_LOC(TYP+2,ORIGIN_FACE_INDEX) = CURRENT_FACE_INDEX

	DO I = 1,3
	    ORIGIN_POINT_INDEX = SURFACE_CURRENT%SURFACE_FACES(I,ORIGIN_FACE_INDEX)
	    USED_POINT_INDEX = STRUCT_INTERFACE%POINT_LOC(TYP+2, ORIGIN_POINT_INDEX)

	    IF (USED_POINT_INDEX>0) THEN
		STRUCT_INTERFACE%FACE(I,CURRENT_FACE_INDEX) = USED_POINT_INDEX
		STRUCT_INTERFACE%CONNECTION_NUM(USED_POINT_INDEX) = STRUCT_INTERFACE%CONNECTION_NUM(USED_POINT_INDEX) + 1
		TEMP = STRUCT_INTERFACE%CONNECTION_NUM(USED_POINT_INDEX)
		STRUCT_INTERFACE%CONNECTION(TEMP, USED_POINT_INDEX) = CURRENT_FACE_INDEX
	    ELSE
		STRUCT_INTERFACE%POINT_NUM = STRUCT_INTERFACE%POINT_NUM + 1
		CURRENT_POINT_INDEX = STRUCT_INTERFACE%POINT_NUM

		STRUCT_INTERFACE%POINT(:,CURRENT_POINT_INDEX) = SURFACE_CURRENT%SURFACE_POINTS(:,ORIGIN_POINT_INDEX)
		STRUCT_INTERFACE%POINT_LOC(1,CURRENT_POINT_INDEX) = ORIGIN_POINT_INDEX
		STRUCT_INTERFACE%POINT_LOC(2,CURRENT_POINT_INDEX) = TYP
		STRUCT_INTERFACE%POINT_LOC(TYP+2, ORIGIN_POINT_INDEX) = CURRENT_POINT_INDEX
		STRUCT_INTERFACE%CONNECTION_NUM(CURRENT_POINT_INDEX) = STRUCT_INTERFACE%CONNECTION_NUM(CURRENT_POINT_INDEX) + 1
		TEMP = STRUCT_INTERFACE%CONNECTION_NUM(CURRENT_POINT_INDEX)
		STRUCT_INTERFACE%CONNECTION(TEMP, CURRENT_POINT_INDEX) = CURRENT_FACE_INDEX
		STRUCT_INTERFACE%FACE(I,CURRENT_FACE_INDEX) = CURRENT_POINT_INDEX
		DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(ORIGIN_POINT_INDEX)
		    TEMP_FACE_INDEX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,ORIGIN_POINT_INDEX)
		    IF (STRUCT_INTERFACE%FACE_LOC(TYP+2,TEMP_FACE_INDEX)==0 .AND. SURFACE_CURRENT%FACE_ONINTERFACE(TEMP_FACE_INDEX)==0) THEN
			CALL CONNECTING_INTERFACE_CLUSTER(TYP, TEMP_FACE_INDEX, STRUCT_INTERFACE)
		    END IF
		END DO
	    END IF

	END DO

ELSE
	STRUCT_INTERFACE%FACE_NUM = STRUCT_INTERFACE%FACE_NUM + 1
	CURRENT_FACE_INDEX = STRUCT_INTERFACE%FACE_NUM
	STRUCT_INTERFACE%FACE_LOC(1,CURRENT_FACE_INDEX) = ORIGIN_FACE_INDEX
	STRUCT_INTERFACE%FACE_LOC(2,CURRENT_FACE_INDEX) = TYP
	STRUCT_INTERFACE%FACE_LOC(3,ORIGIN_FACE_INDEX) = CURRENT_FACE_INDEX

	DO I = 1,3
	    ORIGIN_POINT_INDEX = SURFACE_CURRENT%SURFACE_FACES(I,ORIGIN_FACE_INDEX)
	    USED_POINT_INDEX = STRUCT_INTERFACE%POINT_LOC(3, ORIGIN_POINT_INDEX)

	    IF (USED_POINT_INDEX>0) THEN
		STRUCT_INTERFACE%FACE(I,CURRENT_FACE_INDEX) = USED_POINT_INDEX
		STRUCT_INTERFACE%CONNECTION_NUM(USED_POINT_INDEX) = STRUCT_INTERFACE%CONNECTION_NUM(USED_POINT_INDEX) + 1
		TEMP = STRUCT_INTERFACE%CONNECTION_NUM(USED_POINT_INDEX)
		STRUCT_INTERFACE%CONNECTION(TEMP, USED_POINT_INDEX) = CURRENT_FACE_INDEX
	    ELSE
		STRUCT_INTERFACE%POINT_NUM = STRUCT_INTERFACE%POINT_NUM + 1
		CURRENT_POINT_INDEX = STRUCT_INTERFACE%POINT_NUM

		STRUCT_INTERFACE%POINT(:,CURRENT_POINT_INDEX) = SURFACE_CURRENT%SURFACE_POINTS(:,ORIGIN_POINT_INDEX)
		STRUCT_INTERFACE%POINT_LOC(1,CURRENT_POINT_INDEX) = ORIGIN_POINT_INDEX
		STRUCT_INTERFACE%POINT_LOC(2,CURRENT_POINT_INDEX) = TYP
		STRUCT_INTERFACE%POINT_LOC(3, ORIGIN_POINT_INDEX) = CURRENT_POINT_INDEX
		STRUCT_INTERFACE%CONNECTION_NUM(CURRENT_POINT_INDEX) = STRUCT_INTERFACE%CONNECTION_NUM(CURRENT_POINT_INDEX) + 1
		TEMP = STRUCT_INTERFACE%CONNECTION_NUM(CURRENT_POINT_INDEX)
		STRUCT_INTERFACE%CONNECTION(TEMP, CURRENT_POINT_INDEX) = CURRENT_FACE_INDEX
		STRUCT_INTERFACE%FACE(I,CURRENT_FACE_INDEX) = CURRENT_POINT_INDEX
		DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(ORIGIN_POINT_INDEX)
		    TEMP_FACE_INDEX = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,ORIGIN_POINT_INDEX)
		    IF (STRUCT_INTERFACE%FACE_LOC(3,TEMP_FACE_INDEX)==0 .AND. (SURFACE_CURRENT%FACE_ONINTERFACE(TEMP_FACE_INDEX)==1.OR.SURFACE_CURRENT%FACE_ONINTERFACE(TEMP_FACE_INDEX)==2)) THEN
			CALL CONNECTING_INTERFACE_CLUSTER(TYP, TEMP_FACE_INDEX, STRUCT_INTERFACE)
		    END IF
		END DO
	    END IF

	END DO


END IF	
    END SUBROUTINE CONNECTING_INTERFACE_CLUSTER
    






    SUBROUTINE FIND_BDRY(STRUCT_INTERFACE)
	IMPLICIT NONE
        INTEGER :: I, J, K, N1, N2
	TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
	TYPE(INTERFACE_CLUSTER),POINTER :: STRUCT_INTERFACE
	INTEGER :: ORIGIN_POINT_INDEX,ORIGIN_FACE_INDEX, TYP, OTHER_TYP, POINT_INDEX
	LOGICAL, ALLOCATABLE :: FACE_USED(:)
	INTEGER :: NBHD_FACE, POINT1, POINT2, COUNTING, COUNTING1
	INTEGER :: POINT_PAIR(2)
	INTEGER, ALLOCATABLE :: TEMP_BDRY(:,:)
	INTEGER, ALLOCATABLE :: TEMP_ARRAY1(:,:)
	INTEGER, ALLOCATABLE :: TEMP_ARRAY2(:,:)
	LOGICAL :: DEPARTURE, CASE1, CASE2
	INTEGER :: ROW1, ROW2, TEMP_PROPEL, TEMP_CASE, BDRY_NUM, TEMP_NOW(2), NOW, TEMP_BDRY_NUM
	REAL(8) :: MIN_DISTANCE, DISTANCE, BEFORE
	REAL(8) :: TEMP_POINT1(3), TEMP_POINT2(3)
	INTEGER :: STARTING_POINT, TEMP_COUNTING, START_I,TEMP_ARRAY1_COUNTING, TEMP_ARRAY2_COUNTING, START
	LOGICAL, ALLOCATABLE :: USED(:)


	ALLOCATE(FACE_USED(STRUCT_INTERFACE%FACE_NUM))
	FACE_USED = .FALSE.

	DO I = 1, STRUCT_INTERFACE%FACE_NUM
	    TYP = STRUCT_INTERFACE%FACE_LOC(2, I)
	    IF (TYP==1) THEN
		SURFACE_CURRENT => SURFACE_PROPEL
		OTHER_TYP = 2
	    ELSE
		SURFACE_CURRENT => SURFACE_CASE
		OTHER_TYP = 1
	    END IF

	    ORIGIN_FACE_INDEX = STRUCT_INTERFACE%FACE_LOC(1,I)
	    DO J = 1, 3
		POINT_INDEX = STRUCT_INTERFACE%FACE(J,I)
		ORIGIN_POINT_INDEX = STRUCT_INTERFACE%POINT_LOC(1, POINT_INDEX)

		DO K = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(ORIGIN_POINT_INDEX)
		    NBHD_FACE = SURFACE_CURRENT%POINT_FACE_CONNECTION(K, ORIGIN_POINT_INDEX)
		    IF(SURFACE_CURRENT%FACE_ONINTERFACE(NBHD_FACE)==OTHER_TYP .AND. .NOT. FACE_USED(I)) THEN 
			COUNTING = 0
			POINT_PAIR = 0
			DO N1 = 1, 3
			    POINT1 = SURFACE_CURRENT%SURFACE_FACES(N1,NBHD_FACE)
			    DO N2 = 1, 3
				POINT2 = SURFACE_CURRENT%SURFACE_FACES(N2, ORIGIN_FACE_INDEX)
				IF(POINT1 == POINT2) THEN
				    COUNTING = COUNTING + 1
				    POINT_PAIR(COUNTING) = STRUCT_INTERFACE%POINT_LOC(TYP+2,POINT1)
				END IF
				IF(COUNTING ==2) EXIT
			    END DO
			    IF(COUNTING ==2) EXIT
			END DO

			IF (COUNTING==2) THEN
			    FACE_USED(I) = .TRUE.
			    IF(TYP==1) THEN
				STRUCT_INTERFACE%PROPEL_BDRY_NUM = STRUCT_INTERFACE%PROPEL_BDRY_NUM + 1
				STRUCT_INTERFACE%PROPEL_BDRY(:, STRUCT_INTERFACE%PROPEL_BDRY_NUM) = POINT_PAIR
				EXIT
			    END IF
			    IF(TYP==2) THEN
				STRUCT_INTERFACE%CASE_BDRY_NUM = STRUCT_INTERFACE%CASE_BDRY_NUM + 1
				STRUCT_INTERFACE%CASE_BDRY(:, STRUCT_INTERFACE%CASE_BDRY_NUM) = POINT_PAIR
				EXIT
			    END IF
			END IF
		    END IF
		END DO
	    END DO
	    NULLIFY(SURFACE_CURRENT)
	END DO

	DEALLOCATE(FACE_USED)



IF (STRUCT_INTERFACE%PROPEL_BDRY_NUM>0) THEN
!!! propel bdry point rearrange
	ALLOCATE(TEMP_BDRY(2, STRUCT_INTERFACE%PROPEL_BDRY_NUM))
	ALLOCATE(TEMP_ARRAY1(2, STRUCT_INTERFACE%PROPEL_BDRY_NUM))
	ALLOCATE(TEMP_ARRAY2(2, STRUCT_INTERFACE%PROPEL_BDRY_NUM))
	ALLOCATE(USED(STRUCT_INTERFACE%PROPEL_BDRY_NUM))

	USED = .FALSE.
	TEMP_ARRAY1 = 0
	TEMP_ARRAY2 = 0
	TEMP_BDRY = STRUCT_INTERFACE%PROPEL_BDRY
	STRUCT_INTERFACE%PROPEL_BDRY = 0
	BDRY_NUM = 0
	TEMP_NOW = TEMP_BDRY(:,1)
	TEMP_ARRAY1_COUNTING = 1
	USED(1) = .TRUE.
	TEMP_COUNTING = 1
	DO WHILE(.TRUE.)
	    CASE1 = .TRUE.
	    DO ROW1 = 1, 2
		IF(ROW1==1) ROW2 = 2
		IF(ROW1==2) ROW2 = 1
		DO J = 1, STRUCT_INTERFACE%PROPEL_BDRY_NUM    
		    IF(TEMP_NOW(1)==TEMP_BDRY(1,J) .AND. .NOT.USED(J)) THEN
			TEMP_COUNTING = TEMP_COUNTING + 1
			TEMP_ARRAY1(1,TEMP_ARRAY1_COUNTING) = TEMP_NOW(2)
			TEMP_ARRAY1(2,TEMP_ARRAY1_COUNTING) = TEMP_NOW(1)
			TEMP_ARRAY1_COUNTING = TEMP_ARRAY1_COUNTING + 1
			TEMP_ARRAY1(1,TEMP_ARRAY1_COUNTING) = TEMP_BDRY(1,J)
			TEMP_ARRAY1(2,TEMP_ARRAY1_COUNTING) = TEMP_BDRY(2,J)
			TEMP_NOW = TEMP_BDRY(:,J)
			USED(J) = .TRUE.
			CASE1 = .FALSE.
			EXIT
		    END IF
		    IF(TEMP_NOW(2)==TEMP_BDRY(2,J) .AND. .NOT.USED(J)) THEN
			TEMP_COUNTING = TEMP_COUNTING + 1
			TEMP_ARRAY1_COUNTING = TEMP_ARRAY1_COUNTING + 1
			TEMP_ARRAY1(1,TEMP_ARRAY1_COUNTING) = TEMP_BDRY(2,J)
			TEMP_ARRAY1(2,TEMP_ARRAY1_COUNTING) = TEMP_BDRY(1,J)
			TEMP_NOW = TEMP_ARRAY1(:,TEMP_ARRAY1_COUNTING)
			USED(J) = .TRUE.
			CASE1 = .FALSE.
			EXIT
		    END IF
		    IF(TEMP_NOW(ROW2)==TEMP_BDRY(ROW1,J) .AND. .NOT.USED(J)) THEN
			TEMP_COUNTING = TEMP_COUNTING + 1
			TEMP_ARRAY1(1,TEMP_ARRAY1_COUNTING) = TEMP_NOW(ROW1)
			TEMP_ARRAY1(2,TEMP_ARRAY1_COUNTING) = TEMP_NOW(ROW2)
			TEMP_ARRAY1_COUNTING = TEMP_ARRAY1_COUNTING + 1
			TEMP_ARRAY1(1,TEMP_ARRAY1_COUNTING) = TEMP_BDRY(ROW1,J)
			TEMP_ARRAY1(2,TEMP_ARRAY1_COUNTING) = TEMP_BDRY(ROW2,J)
			TEMP_NOW = TEMP_BDRY(:,J)
			USED(J) = .TRUE.
			CASE1 = .FALSE.
			EXIT
		    END IF
		END DO
		IF (.NOT.CASE1) EXIT
	    END DO

	    START = TEMP_ARRAY1(1,1)
	    CASE2 = .FALSE.
	    IF (START == TEMP_ARRAY1(2,TEMP_ARRAY1_COUNTING)) THEN 
		CASE2 = .TRUE.
	    END IF

	    IF (CASE1 .AND. .NOT.CASE2) THEN
		BDRY_NUM = BDRY_NUM + 1
		BEFORE = START

		TEMP_ARRAY2_COUNTING = 0
		DO WHILE(.TRUE.)
		    DEPARTURE = .TRUE.
		    DO I = 1, STRUCT_INTERFACE%PROPEL_BDRY_NUM
			DO ROW1 = 1, 2
			    IF(ROW1==1) ROW2 = 2
			    IF(ROW1==2) ROW2 = 1
			    IF (BEFORE==TEMP_BDRY(ROW2,I) .AND. .NOT.USED(I)) THEN
				TEMP_COUNTING = TEMP_COUNTING + 1
				TEMP_ARRAY2_COUNTING = TEMP_ARRAY2_COUNTING + 1
				NOW = TEMP_BDRY(ROW2,I)
				BEFORE = TEMP_BDRY(ROW1,I)
				TEMP_ARRAY2(1,TEMP_ARRAY2_COUNTING) = BEFORE
				TEMP_ARRAY2(2,TEMP_ARRAY2_COUNTING) = NOW
				USED(I) = .TRUE.
				DEPARTURE = .FALSE.
				EXIT
			    END IF
			END DO
			IF (.NOT.DEPARTURE) THEN
			    EXIT
			END IF
		    END DO

		    
		    IF (DEPARTURE) THEN
			STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM(BDRY_NUM) = TEMP_ARRAY1_COUNTING + TEMP_ARRAY2_COUNTING
			STARTING_POINT = 0
			DO I = 1, BDRY_NUM-1
			    STARTING_POINT = STARTING_POINT + STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM(I)
			END DO
 
			DO I = 1, TEMP_ARRAY2_COUNTING
			    STRUCT_INTERFACE%PROPEL_BDRY(:,STARTING_POINT+I) = TEMP_ARRAY2(:,TEMP_ARRAY2_COUNTING + 1 - I)
			END DO
			STARTING_POINT = STARTING_POINT + TEMP_ARRAY2_COUNTING
			DO I = 1, TEMP_ARRAY1_COUNTING
			    STRUCT_INTERFACE%PROPEL_BDRY(:,STARTING_POINT+I) = TEMP_ARRAY1(:,I)
			END DO
			EXIT
		    END IF
		END DO

		TEMP_ARRAY1 = 0
		TEMP_ARRAY2 = 0
		TEMP_ARRAY1_COUNTING = 1
		DO J = 1, STRUCT_INTERFACE%PROPEL_BDRY_NUM    
		    IF(.NOT.USED(J)) THEN
			TEMP_COUNTING = TEMP_COUNTING + 1
			TEMP_NOW = TEMP_BDRY(:,J)
			USED(J) = .TRUE.
			EXIT
		    END IF
		END DO
	    END IF

	    IF (CASE2) THEN
		
		STARTING_POINT = 0
		DO I = 1, BDRY_NUM
		    STARTING_POINT = STARTING_POINT + STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM(I)
		END DO

		BDRY_NUM = BDRY_NUM + 1
		STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM(BDRY_NUM) = TEMP_ARRAY1_COUNTING

		DO I = 1, TEMP_ARRAY1_COUNTING
		    STRUCT_INTERFACE%PROPEL_BDRY(:,STARTING_POINT+I) = TEMP_ARRAY1(:,I)
		END DO

		TEMP_ARRAY1_COUNTING = 1
		TEMP_ARRAY1 = 0
		DO J = 1, STRUCT_INTERFACE%PROPEL_BDRY_NUM    
		    IF(.NOT.USED(J)) THEN
			TEMP_COUNTING = TEMP_COUNTING + 1
			TEMP_NOW = TEMP_BDRY(:,J)
			USED(J) = .TRUE.
			EXIT
		    END IF
		END DO
	    END IF
	    IF (TEMP_COUNTING == STRUCT_INTERFACE%PROPEL_BDRY_NUM .AND. (CASE1 .OR.CASE2)) THEN
		EXIT
	    END IF
	END DO
	DEALLOCATE(TEMP_BDRY)
	DEALLOCATE(TEMP_ARRAY1)
	DEALLOCATE(TEMP_ARRAY2)
	DEALLOCATE(USED)



!!! case bdry point rearrange
	ALLOCATE(TEMP_BDRY(2, STRUCT_INTERFACE%CASE_BDRY_NUM))
	ALLOCATE(TEMP_ARRAY1(2, STRUCT_INTERFACE%CASE_BDRY_NUM))
	ALLOCATE(USED(STRUCT_INTERFACE%CASE_BDRY_NUM))

	TEMP_BDRY = STRUCT_INTERFACE%CASE_BDRY
	STRUCT_INTERFACE%CASE_BDRY = 0	
	MIN_DISTANCE =100.0
	TEMP_ARRAY1 = 0
	TEMP_PROPEL = STRUCT_INTERFACE%PROPEL_BDRY(1,1)
	USED = .FALSE.

	TEMP_COUNTING = 0
	TEMP_ARRAY1_COUNTING = 0
	TEMP_BDRY_NUM = 1
	COUNTING1 = 0

	DO WHILE(TEMP_COUNTING<STRUCT_INTERFACE%CASE_BDRY_NUM)
	    STARTING_POINT = 1
	    DO I = 1, TEMP_BDRY_NUM-1
		STARTING_POINT = STARTING_POINT + STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM(I)
	    END DO

	    TEMP_PROPEL = STRUCT_INTERFACE%PROPEL_BDRY(1,STARTING_POINT)
	    MIN_DISTANCE =100.0
	    DO I = 1, STRUCT_INTERFACE%CASE_BDRY_NUM
		IF(.NOT.USED(I)) THEN
		    DO K = 1, 2
			TEMP_CASE = TEMP_BDRY(K,I)
			TEMP_POINT1 = STRUCT_INTERFACE%POINT(:,TEMP_CASE)
			TEMP_POINT2 = STRUCT_INTERFACE%POINT(:,TEMP_PROPEL)
			DISTANCE = DOT_PRODUCT(TEMP_POINT1-TEMP_POINT2,TEMP_POINT1-TEMP_POINT2) 
			IF(MIN_DISTANCE > DISTANCE)THEN
			    START_I = I
			    ROW1 = K
			    MIN_DISTANCE = DISTANCE
			END IF
		    END DO
		END IF
	    END DO

	    IF (ROW1==1) ROW2 = 2
	    IF (ROW1==2) ROW2 = 1
	    TEMP_ARRAY1(1,1) = TEMP_BDRY(ROW1,START_I)
	    TEMP_ARRAY1(2,1) = TEMP_BDRY(ROW2,START_I)
	    USED(START_I) = .TRUE.
	    TEMP_NOW = TEMP_ARRAY1(:,1)
	    TEMP_COUNTING = TEMP_COUNTING + 1
	    TEMP_ARRAY1_COUNTING = TEMP_ARRAY1_COUNTING + 1
	    CASE1 = .FALSE.
	    CASE2 = .FALSE.

	    DO WHILE(.NOT.(CASE1 .OR. CASE2))
		CASE1 = .TRUE.
		DO ROW1 = 1, 2
		    IF(ROW1==1) ROW2 = 2
		    IF(ROW1==2) ROW2 = 1
		    DO J = 1, STRUCT_INTERFACE%PROPEL_BDRY_NUM    
			IF(TEMP_NOW(2)==TEMP_BDRY(ROW1,J) .AND. .NOT.USED(J)) THEN
			    TEMP_COUNTING = TEMP_COUNTING + 1
			    TEMP_ARRAY1_COUNTING = TEMP_ARRAY1_COUNTING + 1
			    TEMP_ARRAY1(1,TEMP_ARRAY1_COUNTING) = TEMP_BDRY(ROW1,J)
			    TEMP_ARRAY1(2,TEMP_ARRAY1_COUNTING) = TEMP_BDRY(ROW2,J)
			    TEMP_NOW = TEMP_ARRAY1(:,TEMP_ARRAY1_COUNTING)
			    USED(J) = .TRUE.
			    CASE1 = .FALSE.
			    EXIT
			END IF
		    END DO
		    IF (.NOT.CASE1) EXIT
		END DO

		START = TEMP_ARRAY1(1,1)
		CASE2 = .FALSE.
		IF (START == TEMP_ARRAY1(2,TEMP_ARRAY1_COUNTING)) THEN 
		    CASE2 = .TRUE.
		END IF

		IF (CASE1 .OR.CASE2) THEN
		    TEMP_BDRY_NUM =  TEMP_BDRY_NUM + 1
		    COUNTING1 = COUNTING1 + 1
		    STRUCT_INTERFACE%CASE_BDRY_CONNECTION_NUM(COUNTING1) = TEMP_ARRAY1_COUNTING
		    STARTING_POINT = 1
		    DO I = 1, COUNTING1-1
			STARTING_POINT = STARTING_POINT + STRUCT_INTERFACE%CASE_BDRY_CONNECTION_NUM(I)
		    END DO
		    STRUCT_INTERFACE%CASE_BDRY(:,STARTING_POINT:STARTING_POINT+TEMP_ARRAY1_COUNTING-1) = TEMP_ARRAY1
		    TEMP_ARRAY1_COUNTING = 0
		    TEMP_ARRAY1 = 0
		END IF
	    END DO
	END DO

	DEALLOCATE(TEMP_BDRY)
	DEALLOCATE(TEMP_ARRAY1)
	DEALLOCATE(USED)
END IF
    END SUBROUTINE



    SUBROUTINE ATTACH_BDRY(STRUCT_INTERFACE)
	IMPLICIT NONE
	TYPE(INTERFACE_CLUSTER),POINTER :: STRUCT_INTERFACE
	INTEGER :: TEMP_PROPEL_NUM, TEMP_CASE_NUM
	INTEGER :: COUNTING, TEMP1, TEMP2
	INTEGER :: PROPEL_POINT_INDEX1, PROPEL_POINT_INDEX2, CASE_POINT_INDEX1, CASE_POINT_INDEX2
	INTEGER :: NBHD_FACE
	REAL(8) :: PROPEL_POINT1(3), PROPEL_POINT2(3), CASE_POINT1(3), CASE_POINT2(3)
	REAL(8) :: POINT1(3), POINT2(3), POINT3(3), V1(3), V2(3)
	REAL(8) :: POINT21(3), POINT22(3), POINT23(3)
	REAL(8) :: DISTANCE1, DISTANCE2


	COUNTING = 0
	TEMP_PROPEL_NUM = 0
	TEMP_CASE_NUM = 0
	
	DO WHILE(TEMP_PROPEL_NUM<STRUCT_INTERFACE%PROPEL_BDRY_NUM .AND. TEMP_CASE_NUM<STRUCT_INTERFACE%CASE_BDRY_NUM)
	    COUNTING = COUNTING + 1
	    TEMP1 = 0
	    TEMP2 = 0
	    
	    DO WHILE(TEMP1<STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM(COUNTING) .AND. TEMP2<STRUCT_INTERFACE%CASE_BDRY_CONNECTION_NUM(COUNTING))

	    PROPEL_POINT_INDEX1 = STRUCT_INTERFACE%PROPEL_BDRY(1,TEMP_PROPEL_NUM+1)
	    PROPEL_POINT_INDEX2 = STRUCT_INTERFACE%PROPEL_BDRY(2,TEMP_PROPEL_NUM+1)
	    CASE_POINT_INDEX1 = STRUCT_INTERFACE%CASE_BDRY(1, TEMP_CASE_NUM+1)
	    CASE_POINT_INDEX2 = STRUCT_INTERFACE%CASE_BDRY(2, TEMP_CASE_NUM+1)
	    PROPEL_POINT1 = STRUCT_INTERFACE%POINT(:,PROPEL_POINT_INDEX1)
	    PROPEL_POINT2 = STRUCT_INTERFACE%POINT(:,PROPEL_POINT_INDEX2)
	    CASE_POINT1 = STRUCT_INTERFACE%POINT(:,CASE_POINT_INDEX1)
	    CASE_POINT2 = STRUCT_INTERFACE%POINT(:,CASE_POINT_INDEX2)
	DISTANCE1 = DOT_PRODUCT(PROPEL_POINT1-CASE_POINT2,PROPEL_POINT1-CASE_POINT2)
	DISTANCE2 = DOT_PRODUCT(PROPEL_POINT2-CASE_POINT1,PROPEL_POINT2-CASE_POINT1)

	    IF (DISTANCE1<DISTANCE2) THEN
		STRUCT_INTERFACE%FACE_NUM = STRUCT_INTERFACE%FACE_NUM + 1

		POINT1 = STRUCT_INTERFACE%POINT(:,PROPEL_POINT_INDEX1)
		POINT2 = STRUCT_INTERFACE%POINT(:,CASE_POINT_INDEX1)
		POINT3 = STRUCT_INTERFACE%POINT(:,CASE_POINT_INDEX2)

		NBHD_FACE = STRUCT_INTERFACE%CONNECTION(1,CASE_POINT_INDEX1)
		POINT21 = STRUCT_INTERFACE%POINT(:,STRUCT_INTERFACE%FACE(1,NBHD_FACE))
		POINT22 = STRUCT_INTERFACE%POINT(:,STRUCT_INTERFACE%FACE(2,NBHD_FACE))
		POINT23 = STRUCT_INTERFACE%POINT(:,STRUCT_INTERFACE%FACE(3,NBHD_FACE))

		CALL VEC_CURL2(POINT2, POINT1, POINT3, POINT1, V1)
		CALL VEC_CURL2(POINT22, POINT21, POINT23, POINT21, V2)

		IF (DOT_PRODUCT(V1,V2)>0) THEN
		    STRUCT_INTERFACE%FACE(1,STRUCT_INTERFACE%FACE_NUM) = PROPEL_POINT_INDEX1
		    STRUCT_INTERFACE%FACE(2,STRUCT_INTERFACE%FACE_NUM) = CASE_POINT_INDEX1
		    STRUCT_INTERFACE%FACE(3,STRUCT_INTERFACE%FACE_NUM) = CASE_POINT_INDEX2
		ELSE
		    STRUCT_INTERFACE%FACE(1,STRUCT_INTERFACE%FACE_NUM) = CASE_POINT_INDEX2
		    STRUCT_INTERFACE%FACE(2,STRUCT_INTERFACE%FACE_NUM) = CASE_POINT_INDEX1
		    STRUCT_INTERFACE%FACE(3,STRUCT_INTERFACE%FACE_NUM) = PROPEL_POINT_INDEX1
		END IF
		STRUCT_INTERFACE%FACE_LOC(2,STRUCT_INTERFACE%FACE_NUM) = -1
		TEMP_PROPEL_NUM = TEMP_PROPEL_NUM
		TEMP_CASE_NUM = TEMP_CASE_NUM + 1

		TEMP1 = TEMP1
		TEMP2 = TEMP2 + 1
	    ELSE
		STRUCT_INTERFACE%FACE_NUM = STRUCT_INTERFACE%FACE_NUM + 1

		POINT1 = STRUCT_INTERFACE%POINT(:,CASE_POINT_INDEX1)
		POINT2 = STRUCT_INTERFACE%POINT(:,PROPEL_POINT_INDEX2)
		POINT3 = STRUCT_INTERFACE%POINT(:,PROPEL_POINT_INDEX1)

		NBHD_FACE = STRUCT_INTERFACE%CONNECTION(1,CASE_POINT_INDEX1)
		POINT21 = STRUCT_INTERFACE%POINT(:,STRUCT_INTERFACE%FACE(1,NBHD_FACE))
		POINT22 = STRUCT_INTERFACE%POINT(:,STRUCT_INTERFACE%FACE(2,NBHD_FACE))
		POINT23 = STRUCT_INTERFACE%POINT(:,STRUCT_INTERFACE%FACE(3,NBHD_FACE))

		CALL VEC_CURL2(POINT2, POINT1, POINT3, POINT1, V1)
		CALL VEC_CURL2(POINT22, POINT21, POINT23, POINT21, V2)

		IF (DOT_PRODUCT(V1,V2)>0) THEN
		    STRUCT_INTERFACE%FACE(1,STRUCT_INTERFACE%FACE_NUM) = CASE_POINT_INDEX1
		    STRUCT_INTERFACE%FACE(2,STRUCT_INTERFACE%FACE_NUM) = PROPEL_POINT_INDEX2
		    STRUCT_INTERFACE%FACE(3,STRUCT_INTERFACE%FACE_NUM) = PROPEL_POINT_INDEX1
		ELSE
		    STRUCT_INTERFACE%FACE(1,STRUCT_INTERFACE%FACE_NUM) = PROPEL_POINT_INDEX1
		    STRUCT_INTERFACE%FACE(2,STRUCT_INTERFACE%FACE_NUM) = PROPEL_POINT_INDEX2
		    STRUCT_INTERFACE%FACE(3,STRUCT_INTERFACE%FACE_NUM) = CASE_POINT_INDEX1
		END IF
		STRUCT_INTERFACE%FACE_LOC(2,STRUCT_INTERFACE%FACE_NUM) = -1
		TEMP_PROPEL_NUM = TEMP_PROPEL_NUM + 1
		TEMP_CASE_NUM = TEMP_CASE_NUM

		TEMP1 = TEMP1 + 1
		TEMP2 = TEMP2
	    END IF
	    
	    IF (TEMP1==STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM(COUNTING) .AND. TEMP2<STRUCT_INTERFACE%CASE_BDRY_CONNECTION_NUM(COUNTING)) THEN
		DO WHILE(TEMP2<STRUCT_INTERFACE%CASE_BDRY_CONNECTION_NUM(COUNTING))
		    STRUCT_INTERFACE%FACE_NUM = STRUCT_INTERFACE%FACE_NUM + 1

		    PROPEL_POINT_INDEX1 = STRUCT_INTERFACE%PROPEL_BDRY(1,TEMP_PROPEL_NUM)
		    PROPEL_POINT_INDEX2 = STRUCT_INTERFACE%PROPEL_BDRY(2,TEMP_PROPEL_NUM)
		    CASE_POINT_INDEX1 = STRUCT_INTERFACE%CASE_BDRY(1, TEMP_CASE_NUM+1)
		    CASE_POINT_INDEX2 = STRUCT_INTERFACE%CASE_BDRY(2, TEMP_CASE_NUM+1)

		    POINT1 = STRUCT_INTERFACE%POINT(:,PROPEL_POINT_INDEX2)
		    POINT2 = STRUCT_INTERFACE%POINT(:,CASE_POINT_INDEX1)
		    POINT3 = STRUCT_INTERFACE%POINT(:,CASE_POINT_INDEX2)

		    NBHD_FACE = STRUCT_INTERFACE%CONNECTION(1,CASE_POINT_INDEX1)
		    POINT21 = STRUCT_INTERFACE%POINT(:,STRUCT_INTERFACE%FACE(1,NBHD_FACE))
		    POINT22 = STRUCT_INTERFACE%POINT(:,STRUCT_INTERFACE%FACE(2,NBHD_FACE))
		    POINT23 = STRUCT_INTERFACE%POINT(:,STRUCT_INTERFACE%FACE(3,NBHD_FACE))

		    CALL VEC_CURL2(POINT2, POINT1, POINT3, POINT1, V1)
		    CALL VEC_CURL2(POINT22, POINT21, POINT23, POINT21, V2)

		    IF (DOT_PRODUCT(V1,V2)>0) THEN
		        STRUCT_INTERFACE%FACE(1,STRUCT_INTERFACE%FACE_NUM) = PROPEL_POINT_INDEX2
		        STRUCT_INTERFACE%FACE(2,STRUCT_INTERFACE%FACE_NUM) = CASE_POINT_INDEX1
		        STRUCT_INTERFACE%FACE(3,STRUCT_INTERFACE%FACE_NUM) = CASE_POINT_INDEX2
		    ELSE
			STRUCT_INTERFACE%FACE(1,STRUCT_INTERFACE%FACE_NUM) = CASE_POINT_INDEX2
			STRUCT_INTERFACE%FACE(2,STRUCT_INTERFACE%FACE_NUM) = CASE_POINT_INDEX1
			STRUCT_INTERFACE%FACE(3,STRUCT_INTERFACE%FACE_NUM) = PROPEL_POINT_INDEX2
		    END IF
		    STRUCT_INTERFACE%FACE_LOC(2,STRUCT_INTERFACE%FACE_NUM) = -1
		    TEMP_PROPEL_NUM = TEMP_PROPEL_NUM
		    TEMP_CASE_NUM = TEMP_CASE_NUM + 1

		    TEMP1 = TEMP1
		    TEMP2 = TEMP2 + 1
		END DO
	    END IF
	    IF (TEMP1<STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM(COUNTING) .AND. TEMP2==STRUCT_INTERFACE%CASE_BDRY_CONNECTION_NUM(COUNTING)) THEN
		DO WHILE(TEMP1<STRUCT_INTERFACE%PROPEL_BDRY_CONNECTION_NUM(COUNTING))
		    STRUCT_INTERFACE%FACE_NUM = STRUCT_INTERFACE%FACE_NUM + 1

		    PROPEL_POINT_INDEX1 = STRUCT_INTERFACE%PROPEL_BDRY(1,TEMP_PROPEL_NUM+1)
		    PROPEL_POINT_INDEX2 = STRUCT_INTERFACE%PROPEL_BDRY(2,TEMP_PROPEL_NUM+1)
		    CASE_POINT_INDEX1 = STRUCT_INTERFACE%CASE_BDRY(1, TEMP_CASE_NUM)
		    CASE_POINT_INDEX2 = STRUCT_INTERFACE%CASE_BDRY(2, TEMP_CASE_NUM)

		    POINT1 = STRUCT_INTERFACE%POINT(:,PROPEL_POINT_INDEX2)
		    POINT2 = STRUCT_INTERFACE%POINT(:,PROPEL_POINT_INDEX1)
		    POINT3 = STRUCT_INTERFACE%POINT(:,CASE_POINT_INDEX2)

		    NBHD_FACE = STRUCT_INTERFACE%CONNECTION(1,CASE_POINT_INDEX1)
		    POINT21 = STRUCT_INTERFACE%POINT(:,STRUCT_INTERFACE%FACE(1,NBHD_FACE))
		    POINT22 = STRUCT_INTERFACE%POINT(:,STRUCT_INTERFACE%FACE(2,NBHD_FACE))
		    POINT23 = STRUCT_INTERFACE%POINT(:,STRUCT_INTERFACE%FACE(3,NBHD_FACE))

		    CALL VEC_CURL2(POINT2, POINT1, POINT3, POINT1, V1)
		    CALL VEC_CURL2(POINT22, POINT21, POINT23, POINT21, V2)

		    IF (DOT_PRODUCT(V1,V2)>0) THEN
			STRUCT_INTERFACE%FACE(1,STRUCT_INTERFACE%FACE_NUM) = PROPEL_POINT_INDEX2
			STRUCT_INTERFACE%FACE(2,STRUCT_INTERFACE%FACE_NUM) = PROPEL_POINT_INDEX1
			STRUCT_INTERFACE%FACE(3,STRUCT_INTERFACE%FACE_NUM) = CASE_POINT_INDEX2
		    ELSE
			STRUCT_INTERFACE%FACE(1,STRUCT_INTERFACE%FACE_NUM) = CASE_POINT_INDEX2
			STRUCT_INTERFACE%FACE(2,STRUCT_INTERFACE%FACE_NUM) = PROPEL_POINT_INDEX1
			STRUCT_INTERFACE%FACE(3,STRUCT_INTERFACE%FACE_NUM) = PROPEL_POINT_INDEX2
		    END IF
		    STRUCT_INTERFACE%FACE_LOC(2,STRUCT_INTERFACE%FACE_NUM) = -1
		    TEMP_PROPEL_NUM = TEMP_PROPEL_NUM + 1
		    TEMP_CASE_NUM = TEMP_CASE_NUM

		    TEMP1 = TEMP1 + 1
		    TEMP2 = TEMP2
		END DO
	    END IF
	    END DO
	END DO


    END SUBROUTINE



!    SUBROUTINE FIND_INTERFACE_CLUSTER(TYP)
!	IMPLICIT NONE
!        INTEGER :: TYP, I!, INITIAL_INDEX
!	TYPE(INTERFACE_CLUSTER),POINTER :: STRUCT_INTERFACE
!	
!
!IF(TYP==1) THEN
!
!
!	ALLOCATE(STRUCT_INTERFACE)
!	CALL INITIAL_INTERFACE(TYP,STRUCT_INTERFACE)
!
!	DO I = 1, SURFACE_PROPEL%SURFACE_FACES_NUM
!	    IF (SURFACE_PROPEL%FACE_ONINTERFACE(I)==0 .AND. STRUCT_INTERFACE%FACE_LOC(3,I)==0) THEN
!		CALL CONNECTING_INTERFACE_CLUSTER(1,I, STRUCT_INTERFACE)
!	    END IF
!	END DO
!
!	DO I = 1, SURFACE_CASE%SURFACE_FACES_NUM
!	    IF (SURFACE_CASE%FACE_ONINTERFACE(I)==0 .AND. STRUCT_INTERFACE%FACE_LOC(4,I)==0) THEN
!		CALL CONNECTING_INTERFACE_CLUSTER(2,I, STRUCT_INTERFACE)
!	    END IF
!	END DO
!
!	CALL FIND_BDRY(STRUCT_INTERFACE)
!	IF (STRUCT_INTERFACE%PROPEL_BDRY_NUM>0) THEN
!	    CALL ATTACH_BDRY(STRUCT_INTERFACE)
!	END IF
!
!
!	IF(ALLOCATED(INTERFACE_STRUCT_POINTS)) THEN
!	    DEALLOCATE(INTERFACE_STRUCT_POINTS)
!	END IF
!	IF(ALLOCATED(INTERFACE_STRUCT_POINTS_LOC)) THEN
!	    DEALLOCATE(INTERFACE_STRUCT_POINTS_LOC)
!	END IF
!	IF(ALLOCATED(INTERFACE_STRUCT_FACES)) THEN
!	    DEALLOCATE(INTERFACE_STRUCT_FACES)
!	END IF
!	IF(ALLOCATED(INTERFACE_STRUCT_FACES_LOC)) THEN
!	    DEALLOCATE(INTERFACE_STRUCT_FACES_LOC)
!	END IF
!	ALLOCATE(INTERFACE_STRUCT_POINTS(3,STRUCT_INTERFACE%POINT_NUM))
!	ALLOCATE(INTERFACE_STRUCT_POINTS_LOC(2,STRUCT_INTERFACE%POINT_NUM))
!	ALLOCATE(INTERFACE_STRUCT_FACES(3,STRUCT_INTERFACE%FACE_NUM))
!	ALLOCATE(INTERFACE_STRUCT_FACES_LOC(2,STRUCT_INTERFACE%FACE_NUM))
!	INTERFACE_STRUCT_POINTS = 0.
!	INTERFACE_STRUCT_POINTS_LOC = 0
!	INTERFACE_STRUCT_FACES = 0
!	INTERFACE_STRUCT_FACES_LOC = 0
!
!	INTERFACE_STRUCT_POINTS_NUM = STRUCT_INTERFACE%POINT_NUM
!	DO I = 1, INTERFACE_STRUCT_POINTS_NUM
!	    INTERFACE_STRUCT_POINTS(:,I) = STRUCT_INTERFACE%POINT(:,I)
!	    INTERFACE_STRUCT_POINTS_LOC(1,I) = STRUCT_INTERFACE%POINT_LOC(1,I)
!	    INTERFACE_STRUCT_POINTS_LOC(2,I) = STRUCT_INTERFACE%POINT_LOC(2,I)
!	END DO
!	INTERFACE_STRUCT_FACES_NUM = STRUCT_INTERFACE%FACE_NUM
!	DO I = 1, INTERFACE_STRUCT_FACES_NUM
!	    INTERFACE_STRUCT_FACES(:,I) = STRUCT_INTERFACE%FACE(:,I)
!	    INTERFACE_STRUCT_FACES_LOC(1,I) = STRUCT_INTERFACE%FACE_LOC(1,I)
!	    INTERFACE_STRUCT_FACES_LOC(2,I) = STRUCT_INTERFACE%FACE_LOC(2,I)
!	END DO
!
!	CALL DELETE_INTERFACE(STRUCT_INTERFACE)
!ELSE
!
!	ALLOCATE(STRUCT_INTERFACE)
!	CALL INITIAL_INTERFACE(TYP,STRUCT_INTERFACE)
!
!	DO I = 1, SURFACE_FLUID%SURFACE_FACES_NUM
!	    IF ((SURFACE_FLUID%FACE_ONINTERFACE(I)==1 .OR. SURFACE_FLUID%FACE_ONINTERFACE(I)==2).AND. STRUCT_INTERFACE%FACE_LOC(3,I)==0) THEN
!		CALL CONNECTING_INTERFACE_CLUSTER(TYP,I, STRUCT_INTERFACE)
!	    END IF
!	END DO
!
!
!	IF(ALLOCATED(INTERFACE_FLUID_POINTS)) THEN
!	    DEALLOCATE(INTERFACE_FLUID_POINTS)
!	END IF
!	IF(ALLOCATED(INTERFACE_FLUID_POINTS_LOC)) THEN
!	    DEALLOCATE(INTERFACE_FLUID_POINTS_LOC)
!	END IF
!	IF(ALLOCATED(INTERFACE_FLUID_FACES)) THEN
!	    DEALLOCATE(INTERFACE_FLUID_FACES)
!	END IF
!	IF(ALLOCATED(INTERFACE_FLUID_FACES_LOC)) THEN
!	    DEALLOCATE(INTERFACE_FLUID_FACES_LOC)
!	END IF
!	ALLOCATE(INTERFACE_FLUID_POINTS(3,STRUCT_INTERFACE%POINT_NUM))
!	ALLOCATE(INTERFACE_FLUID_POINTS_LOC(2,STRUCT_INTERFACE%POINT_NUM))
!	ALLOCATE(INTERFACE_FLUID_FACES(3,STRUCT_INTERFACE%FACE_NUM))
!	ALLOCATE(INTERFACE_FLUID_FACES_LOC(2,STRUCT_INTERFACE%FACE_NUM))
!	INTERFACE_FLUID_POINTS = 0.
!	INTERFACE_FLUID_POINTS_LOC = 0
!	INTERFACE_FLUID_FACES = 0
!	INTERFACE_FLUID_FACES_LOC = 0
!	INTERFACE_FLUID_POINTS_NUM = STRUCT_INTERFACE%POINT_NUM
!	DO I = 1, INTERFACE_FLUID_POINTS_NUM
!	    INTERFACE_FLUID_POINTS(:,I) = STRUCT_INTERFACE%POINT(:,I)
!	    INTERFACE_FLUID_POINTS_LOC(1,I) = STRUCT_INTERFACE%POINT_LOC(1,I)
!	    INTERFACE_FLUID_POINTS_LOC(2,I) = STRUCT_INTERFACE%POINT_LOC(2,I)
!	END DO
!	INTERFACE_FLUID_FACES_NUM = STRUCT_INTERFACE%FACE_NUM
!	DO I = 1, INTERFACE_FLUID_FACES_NUM
!
!	    INTERFACE_FLUID_FACES(:,I) = STRUCT_INTERFACE%FACE(:,I)
!	    INTERFACE_FLUID_FACES_LOC(1,I) = STRUCT_INTERFACE%FACE_LOC(1,I)
!	    INTERFACE_FLUID_FACES_LOC(2,I) = STRUCT_INTERFACE%FACE_LOC(2,I)
!	END DO
!
!	CALL DELETE_INTERFACE(STRUCT_INTERFACE)
!END IF
!
!
!    END SUBROUTINE FIND_INTERFACE_CLUSTER
    
    
    
    
    SUBROUTINE FIND_INTERFACE_CLUSTER(TYP)
        IMPLICIT NONE
        INTEGER :: TYP
        
        INTEGER :: I, J
        
        INTEGER :: POINT_NUM
        REAL(8), ALLOCATABLE :: POINT(:,:)
        INTEGER, ALLOCATABLE :: POINTLOC(:,:)
        
        INTEGER :: FACE_NUM
        INTEGER, ALLOCATABLE :: FACE(:,:)
        INTEGER, ALLOCATABLE :: FACELOC(:,:)
        
        INTEGER, ALLOCATABLE :: POINT_INDEX_FLUID(:), POINT_INDEX_PROPEL(:), POINT_INDEX_CASE(:)
        
        LOGICAL :: B, C
        
        IF(TYP==0) THEN
        
        POINT_NUM = 0
        FACE_NUM = 0
        ALLOCATE(POINT(3,SURFACE_FLUID%SURFACE_POINTS_NUM))
        ALLOCATE(POINTLOC(2,SURFACE_FLUID%SURFACE_POINTS_NUM))
        ALLOCATE(FACE(3,SURFACE_FLUID%SURFACE_FACES_NUM))
        ALLOCATE(FACELOC(2,SURFACE_FLUID%SURFACE_FACES_NUM))
        
        ALLOCATE(POINT_INDEX_FLUID(SURFACE_FLUID%SURFACE_POINTS_NUM))
        
        DO I = 1, SURFACE_FLUID%SURFACE_POINTS_NUM
            B = .FALSE.
            DO J = 1, SURFACE_FLUID%POINT_FACE_CONNECTION_NUM(I)
                IF(SURFACE_FLUID%FACE_ONINTERFACE(SURFACE_FLUID%POINT_FACE_CONNECTION(J,I))==1 .OR. SURFACE_FLUID%FACE_ONINTERFACE(SURFACE_FLUID%POINT_FACE_CONNECTION(J,I))==2) THEN
                    B = .TRUE.
                    EXIT
                END IF
            END DO
            
            IF(B) THEN
                POINT_NUM = POINT_NUM + 1
                POINT(:,POINT_NUM) = SURFACE_FLUID%SURFACE_POINTS(:,I)
                POINTLOC(2,POINT_NUM) = 0
                POINTLOC(1,POINT_NUM) = I
                
                POINT_INDEX_FLUID(I) = POINT_NUM
            END IF
        END DO
        
        DO I = 1, SURFACE_FLUID%SURFACE_FACES_NUM
            IF (SURFACE_FLUID%FACE_ONINTERFACE(I)==1 .OR. SURFACE_FLUID%FACE_ONINTERFACE(I)==2) THEN
                FACE_NUM = FACE_NUM + 1
                FACE(1,FACE_NUM) = POINT_INDEX_FLUID(SURFACE_FLUID%SURFACE_FACES(1,I))
                FACE(2,FACE_NUM) = POINT_INDEX_FLUID(SURFACE_FLUID%SURFACE_FACES(2,I))
                FACE(3,FACE_NUM) = POINT_INDEX_FLUID(SURFACE_FLUID%SURFACE_FACES(3,I))
                FACELOC(2,FACE_NUM) = 0
                FACELOC(1,FACE_NUM) = I
            END IF
        END DO
        
        DEALLOCATE(POINT_INDEX_FLUID)
        
        IF(ALLOCATED(INTERFACE_FLUID_POINTS)) THEN
            DEALLOCATE(INTERFACE_FLUID_POINTS)
        END IF
        IF(ALLOCATED(INTERFACE_FLUID_POINTS_LOC)) THEN
            DEALLOCATE(INTERFACE_FLUID_POINTS_LOC)
        END IF
        IF(ALLOCATED(INTERFACE_FLUID_FACES)) THEN
            DEALLOCATE(INTERFACE_FLUID_FACES)
        END IF
        IF(ALLOCATED(INTERFACE_FLUID_FACES_LOC)) THEN
            DEALLOCATE(INTERFACE_FLUID_FACES_LOC)
        END IF
        
        ALLOCATE(INTERFACE_FLUID_POINTS(3,POINT_NUM))
        ALLOCATE(INTERFACE_FLUID_POINTS_LOC(2,POINT_NUM))
        ALLOCATE(INTERFACE_FLUID_FACES(3,FACE_NUM))
        ALLOCATE(INTERFACE_FLUID_FACES_LOC(2,FACE_NUM))
        INTERFACE_FLUID_POINTS = 0.
        INTERFACE_FLUID_POINTS_LOC = 0
        INTERFACE_FLUID_FACES = 0
        INTERFACE_FLUID_FACES_LOC = 0
        INTERFACE_FLUID_POINTS_NUM = POINT_NUM
        DO I = 1, INTERFACE_FLUID_POINTS_NUM
            INTERFACE_FLUID_POINTS(:,I) = POINT(:,I)
            INTERFACE_FLUID_POINTS_LOC(:,I) = POINTLOC(:,I)
        END DO
        INTERFACE_FLUID_FACES_NUM = FACE_NUM
        DO I = 1, INTERFACE_FLUID_FACES_NUM
            INTERFACE_FLUID_FACES(:,I) = FACE(:,I)
            INTERFACE_FLUID_FACES_LOC(:,I) = FACELOC(:,I)
        END DO
        
        DEALLOCATE(POINT)
        DEALLOCATE(POINTLOC)
        DEALLOCATE(FACE)
        DEALLOCATE(FACELOC)
        
        ELSE
        
        POINT_NUM = 0
        FACE_NUM = 0
        ALLOCATE(POINT(3,SURFACE_PROPEL%SURFACE_POINTS_NUM + SURFACE_CASE%SURFACE_POINTS_NUM))
        ALLOCATE(POINTLOC(2,SURFACE_PROPEL%SURFACE_POINTS_NUM + SURFACE_CASE%SURFACE_POINTS_NUM))
        ALLOCATE(FACE(3,SURFACE_PROPEL%SURFACE_FACES_NUM + SURFACE_CASE%SURFACE_FACES_NUM))
        ALLOCATE(FACELOC(2,SURFACE_PROPEL%SURFACE_FACES_NUM + SURFACE_CASE%SURFACE_FACES_NUM))
        
        ALLOCATE(POINT_INDEX_PROPEL(SURFACE_PROPEL%SURFACE_POINTS_NUM))
        ALLOCATE(POINT_INDEX_CASE(SURFACE_CASE%SURFACE_POINTS_NUM))
        
        DO I = 1, SURFACE_PROPEL%SURFACE_POINTS_NUM
            B = .FALSE.
            DO J = 1, SURFACE_PROPEL%POINT_FACE_CONNECTION_NUM(I)
                IF(SURFACE_PROPEL%FACE_ONINTERFACE(SURFACE_PROPEL%POINT_FACE_CONNECTION(J,I))==0) THEN
                    B = .TRUE.
                    EXIT
                END IF
            END DO
            
            IF(B) THEN
                POINT_NUM = POINT_NUM + 1
                POINT(:,POINT_NUM) = SURFACE_PROPEL%SURFACE_POINTS(:,I)
                POINTLOC(2,POINT_NUM) = 1
                POINTLOC(1,POINT_NUM) = I
                
                POINT_INDEX_PROPEL(I) = POINT_NUM
            END IF
        END DO
        
        DO I = 1, SURFACE_CASE%SURFACE_POINTS_NUM
            B = .FALSE.
            DO J = 1, SURFACE_CASE%POINT_FACE_CONNECTION_NUM(I)
                IF(SURFACE_CASE%FACE_ONINTERFACE(SURFACE_CASE%POINT_FACE_CONNECTION(J,I))==0) THEN
                    B = .TRUE.
                    EXIT
                END IF
            END DO
            
            IF(B) THEN
                C = .FALSE.
                DO J = 1, SURFACE_CASE%POINT_FACE_CONNECTION_NUM(I)
                    IF(SURFACE_CASE%FACE_ONINTERFACE(SURFACE_CASE%POINT_FACE_CONNECTION(J,I))==1) THEN
                        C = .TRUE.
                        EXIT
                    END IF
                END DO
                
                IF(C) THEN
                    POINT_INDEX_CASE(I) = POINT_INDEX_PROPEL(SURFACE_CASE%POINT_RELATEDPT(1+1,I))
                ELSE
                    POINT_NUM = POINT_NUM + 1
                    POINT(:,POINT_NUM) = SURFACE_CASE%SURFACE_POINTS(:,I)
                    POINTLOC(2,POINT_NUM) = 2
                    POINTLOC(1,POINT_NUM) = I
                    
                    POINT_INDEX_CASE(I) = POINT_NUM
                END IF
            END IF
        END DO
        
        DO I = 1, SURFACE_PROPEL%SURFACE_FACES_NUM
            IF (SURFACE_PROPEL%FACE_ONINTERFACE(I)==0) THEN
                FACE_NUM = FACE_NUM + 1
                FACE(1,FACE_NUM) = POINT_INDEX_PROPEL(SURFACE_PROPEL%SURFACE_FACES(1,I))
                FACE(2,FACE_NUM) = POINT_INDEX_PROPEL(SURFACE_PROPEL%SURFACE_FACES(2,I))
                FACE(3,FACE_NUM) = POINT_INDEX_PROPEL(SURFACE_PROPEL%SURFACE_FACES(3,I))
                FACELOC(2,FACE_NUM) = 1
                FACELOC(1,FACE_NUM) = I
            END IF
        END DO
        
        DO I = 1, SURFACE_CASE%SURFACE_FACES_NUM
            IF (SURFACE_CASE%FACE_ONINTERFACE(I)==0) THEN
                FACE_NUM = FACE_NUM + 1
                FACE(1,FACE_NUM) = POINT_INDEX_CASE(SURFACE_CASE%SURFACE_FACES(1,I))
                FACE(2,FACE_NUM) = POINT_INDEX_CASE(SURFACE_CASE%SURFACE_FACES(2,I))
                FACE(3,FACE_NUM) = POINT_INDEX_CASE(SURFACE_CASE%SURFACE_FACES(3,I))
                FACELOC(2,FACE_NUM) = 2
                FACELOC(1,FACE_NUM) = I
            END IF
        END DO
        
        DEALLOCATE(POINT_INDEX_PROPEL)
        DEALLOCATE(POINT_INDEX_CASE)
        
        IF(ALLOCATED(INTERFACE_STRUCT_POINTS)) THEN
            DEALLOCATE(INTERFACE_STRUCT_POINTS)
        END IF
        IF(ALLOCATED(INTERFACE_STRUCT_POINTS_LOC)) THEN
            DEALLOCATE(INTERFACE_STRUCT_POINTS_LOC)
        END IF
        IF(ALLOCATED(INTERFACE_STRUCT_FACES)) THEN
            DEALLOCATE(INTERFACE_STRUCT_FACES)
        END IF
        IF(ALLOCATED(INTERFACE_STRUCT_FACES_LOC)) THEN
            DEALLOCATE(INTERFACE_STRUCT_FACES_LOC)
        END IF
        
        ALLOCATE(INTERFACE_STRUCT_POINTS(3,POINT_NUM))
        ALLOCATE(INTERFACE_STRUCT_POINTS_LOC(2,POINT_NUM))
        ALLOCATE(INTERFACE_STRUCT_FACES(3,FACE_NUM))
        ALLOCATE(INTERFACE_STRUCT_FACES_LOC(2,FACE_NUM))
        INTERFACE_STRUCT_POINTS = 0.
        INTERFACE_STRUCT_POINTS_LOC = 0
        INTERFACE_STRUCT_FACES = 0
        INTERFACE_STRUCT_FACES_LOC = 0
        INTERFACE_STRUCT_POINTS_NUM = POINT_NUM
        DO I = 1, INTERFACE_STRUCT_POINTS_NUM
            INTERFACE_STRUCT_POINTS(:,I) = POINT(:,I)
            INTERFACE_STRUCT_POINTS_LOC(:,I) = POINTLOC(:,I)
        END DO
        INTERFACE_STRUCT_FACES_NUM = FACE_NUM
        DO I = 1, INTERFACE_STRUCT_FACES_NUM
            INTERFACE_STRUCT_FACES(:,I) = FACE(:,I)
            INTERFACE_STRUCT_FACES_LOC(:,I) = FACELOC(:,I)
        END DO
        
        DEALLOCATE(POINT)
        DEALLOCATE(POINTLOC)
        DEALLOCATE(FACE)
        DEALLOCATE(FACELOC)
        
        END IF
        
    END SUBROUTINE FIND_INTERFACE_CLUSTER


    SUBROUTINE UPDATE_INTERFACE_CLUSTER(TYP)
        IMPLICIT NONE
        INTEGER :: TYP
        INTEGER :: I
        
        IF(TYP==0) THEN
	    !$OMP PARALLEL DO PRIVATE(I)
            DO I=1,INTERFACE_FLUID_POINTS_NUM
                INTERFACE_FLUID_POINTS(:,I) = SURFACE_FLUID%SURFACE_POINTS(:,INTERFACE_FLUID_POINTS_LOC(1,I))
            END DO
	    !$OMP END PARALLEL DO
        ELSE
	    !$OMP PARALLEL DO PRIVATE(I)
            DO I=1,INTERFACE_STRUCT_POINTS_NUM
                IF(INTERFACE_STRUCT_POINTS_LOC(2,I)==1) THEN
                    INTERFACE_STRUCT_POINTS(:,I) = SURFACE_PROPEL%SURFACE_POINTS(:,INTERFACE_STRUCT_POINTS_LOC(1,I))
                ELSE IF(INTERFACE_STRUCT_POINTS_LOC(2,I)==2) THEN
                    INTERFACE_STRUCT_POINTS(:,I) = SURFACE_CASE%SURFACE_POINTS(:,INTERFACE_STRUCT_POINTS_LOC(1,I))
                END IF
            END DO
	    !$OMP END PARALLEL DO
        END IF
        
    END SUBROUTINE UPDATE_INTERFACE_CLUSTER
    
    SUBROUTINE EXTRAPOLATION_COMMON_REFINEMENT(TYP1, TYP2, DATA1, DATA2, TARGET1, TARGET2)
	IMPLICIT NONE
        INTEGER :: TYP1, TYP2
    
        !INTEGER :: I
        
        INTEGER :: TYP1_POINT_NUM
        REAL(8), POINTER, DIMENSION(:,:) :: TYP1_POINT
        INTEGER, POINTER, DIMENSION(:,:) :: TYP1_POINTLOC
        INTEGER :: TYP1_FACE_NUM
        INTEGER, POINTER, DIMENSION(:,:) :: TYP1_FACE
        
        INTEGER :: TYP2_POINT_NUM
        REAL(8), POINTER, DIMENSION(:,:) :: TYP2_POINT
        INTEGER, POINTER, DIMENSION(:,:) :: TYP2_POINTLOC
        INTEGER :: TYP2_FACE_NUM
        INTEGER, POINTER, DIMENSION(:,:) :: TYP2_FACE
        
        REAL(8) :: DATA1(:), DATA2(:), TARGET1(:), TARGET2(:)
        
        REAL(8), ALLOCATABLE :: CR_SOURCE(:), CR_TARGET(:)
        INTEGER :: I

        CALL UPDATE_INTERFACE_CLUSTER(0)
        CALL UPDATE_INTERFACE_CLUSTER(1)
        
        IF (TYP1==0) THEN
            TYP1_POINT_NUM = INTERFACE_FLUID_POINTS_NUM
            TYP1_POINT => INTERFACE_FLUID_POINTS
            TYP1_POINTLOC => INTERFACE_FLUID_POINTS_LOC
            TYP1_FACE_NUM = INTERFACE_FLUID_FACES_NUM
            TYP1_FACE => INTERFACE_FLUID_FACES
        ELSE
            TYP1_POINT_NUM = INTERFACE_STRUCT_POINTS_NUM
            TYP1_POINT => INTERFACE_STRUCT_POINTS
            TYP1_POINTLOC => INTERFACE_STRUCT_POINTS_LOC
            TYP1_FACE_NUM = INTERFACE_STRUCT_FACES_NUM
            TYP1_FACE => INTERFACE_STRUCT_FACES
        END IF
        
        IF (TYP2==0) THEN
            TYP2_POINT_NUM = INTERFACE_FLUID_POINTS_NUM
            TYP2_POINT => INTERFACE_FLUID_POINTS
            TYP2_POINTLOC => INTERFACE_FLUID_POINTS_LOC
            TYP2_FACE_NUM = INTERFACE_FLUID_FACES_NUM
            TYP2_FACE => INTERFACE_FLUID_FACES
        ELSE
            TYP2_POINT_NUM = INTERFACE_STRUCT_POINTS_NUM
            TYP2_POINT => INTERFACE_STRUCT_POINTS
            TYP2_POINTLOC => INTERFACE_STRUCT_POINTS_LOC
            TYP2_FACE_NUM = INTERFACE_STRUCT_FACES_NUM
            TYP2_FACE => INTERFACE_STRUCT_FACES
        END IF
        
        ALLOCATE(CR_SOURCE(TYP1_POINT_NUM))
        
	!$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP1_POINT_NUM
            IF(TYP1_POINTLOC(2,I)==0 .OR. TYP1_POINTLOC(2,I)==1) THEN
                CR_SOURCE(I) = DATA1(TYP1_POINTLOC(1,I))
            ELSE
                CR_SOURCE(I) = DATA2(TYP1_POINTLOC(1,I))
            END IF
        END DO
        !$OMP END PARALLEL DO
        
        ALLOCATE(CR_TARGET(TYP2_POINT_NUM))
        
        
        !CALL DATA_TRANSFER_WITHOUT_CR(TYP1_POINT_NUM, TYP1_POINT, TYP1_FACE_NUM, TYP1_FACE, CR_SOURCE, TYP2_POINT_NUM, TYP2_POINT, TYP2_FACE_NUM, TYP2_FACE, CR_TARGET)
        CALL DATA_TRANSFER_WITHOUT_CR(TYP1_POINT_NUM, TYP1_POINT, TYP1_FACE_NUM, TYP1_FACE, CR_SOURCE, TYP2_POINT_NUM, TYP2_POINT, CR_TARGET)
        
        !$OMP PARALLEL DO PRIVATE(I)
        DO I=1,TYP2_POINT_NUM
            IF(TYP2_POINTLOC(2,I)==0 .OR. TYP2_POINTLOC(2,I)==1) THEN
                TARGET1(TYP2_POINTLOC(1,I)) = CR_TARGET(I)
            ELSE
                TARGET2(TYP2_POINTLOC(1,I)) = CR_TARGET(I)
            END IF
        END DO
        !$OMP END PARALLEL DO
        
        DEALLOCATE(CR_SOURCE)
        DEALLOCATE(CR_TARGET)
        
    END SUBROUTINE EXTRAPOLATION_COMMON_REFINEMENT
    
    
    SUBROUTINE RELATE_INTERFACE_POINT(V, POINT_NUM, POINT, FACE_NUM, FACE, IDX, V_RET)
        IMPLICIT NONE
        REAL(8) :: V(3), V_RET(3)
        INTEGER :: POINT_NUM
        REAL(8) :: POINT(:,:)
        INTEGER :: FACE_NUM
        INTEGER :: FACE(:,:)
        
        INTEGER :: IDX
        
        TYPE(HASH) :: HASH0
        
        CALL SET_HASH(POINT_NUM, POINT, FACE_NUM, FACE, 2, DOMAIN_MAX, DOMAIN_MIN, HASH0)
        
        CALL RELATE_INTERFACE_POINT_HASH(V, POINT, FACE, HASH0,  IDX, V_RET)
        
        CALL REMOVE_HASH(HASH0)
    END SUBROUTINE
    
    
    SUBROUTINE RELATE_INTERFACE_POINT_HASH(V, POINT, FACE, HASH0,  IDX, V_RET)
        IMPLICIT NONE
        REAL(8) :: V(3), V_RET(3)
        REAL(8) :: POINT(:,:)
        INTEGER :: FACE(:,:)
        
        TYPE(HASH) :: HASH0
        
        TYPE(HASH_ELEMENT), POINTER :: ELEMENT_CURRENT
        INTEGER :: INDEX1, INDEX2, INDEX3
        
        INTEGER :: IDX
        
        INTEGER :: I0
        REAL(8) :: R, V1(3), V2(3), V3(3), DIST
        
        R =  MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
        
        CALL FIND_HASH_INDEX(HASH0, V, INDEX1, INDEX2, INDEX3)
        
        ELEMENT_CURRENT => HASH0%ELEMENT(INDEX1,INDEX2,INDEX3)%HEAD
        DO WHILE(ASSOCIATED(ELEMENT_CURRENT))
            I0 = ELEMENT_CURRENT%I0
            V1 = POINT(:,FACE(1,I0))
            V2 = POINT(:,FACE(2,I0))
            V3 = POINT(:,FACE(3,I0))
            CALL UNSIGNED_DISTANCE_FACE_POINT(V, V1, V2, V3, DIST)
            
            IF (DIST <= R) THEN
                R = DIST
                
                IDX = I0
                V_RET = V
                CALL PROJECTION_FACE_POINT(V_RET, V1, V2, V3)
            END IF
            
            ELEMENT_CURRENT => ELEMENT_CURRENT%NEXT
        END DO
        NULLIFY(ELEMENT_CURRENT)
        
    END SUBROUTINE RELATE_INTERFACE_POINT_HASH
    
    SUBROUTINE FIND_RELATED_FACE_INTERFACE(TYP1_POINT_NUM, TYP1_POINT, TYP2_POINT_NUM, TYP2_POINT, TYP2_FACE_NUM, TYP2_FACE, RELATED_FACE, PROJECTION_POINT)
        IMPLICIT NONE
        
        INTEGER :: TYP1_POINT_NUM
        REAL(8) :: TYP1_POINT(:,:)
        
        INTEGER :: TYP2_POINT_NUM
        REAL(8) :: TYP2_POINT(:,:)
        INTEGER :: TYP2_FACE_NUM
        INTEGER :: TYP2_FACE(:,:)
        
        INTEGER :: RELATED_FACE(:)
        REAL(8) :: PROJECTION_POINT(:,:)
        
        INTEGER :: I, IDX
        TYPE(HASH) :: HASH0
        
        REAL(8) :: V(3)
        
        CALL SET_HASH(TYP2_POINT_NUM, TYP2_POINT, TYP2_FACE_NUM, TYP2_FACE, 2, DOMAIN_MAX, DOMAIN_MIN, HASH0)
        
        DO I=1,TYP1_POINT_NUM
            CALL RELATE_INTERFACE_POINT_HASH(TYP1_POINT(:,I), TYP2_POINT, TYP2_FACE, HASH0,  IDX,V)
            RELATED_FACE(I) = IDX
            PROJECTION_POINT(:,I) = V
        END DO
        
        CALL REMOVE_HASH(HASH0)
        
    END SUBROUTINE FIND_RELATED_FACE_INTERFACE

    
    SUBROUTINE DATA_TRANSFER_WITHOUT_CR(TYP1_POINT_NUM, TYP1_POINT, TYP1_FACE_NUM, TYP1_FACE, CR_SOURCE, TYP2_POINT_NUM, TYP2_POINT, CR_TARGET) !TYP2_FACE_NUM, TYP2_FACE,
	IMPLICIT NONE
        
        INTEGER :: TYP1_POINT_NUM
        REAL(8) :: TYP1_POINT(:,:)
        INTEGER :: TYP1_FACE_NUM
        INTEGER :: TYP1_FACE(:,:)
        
        INTEGER :: TYP2_POINT_NUM
        REAL(8) :: TYP2_POINT(:,:)
        !INTEGER :: TYP2_FACE_NUM
        !INTEGER :: TYP2_FACE(:,:)
        
        REAL(8) :: CR_SOURCE(:), CR_TARGET(:)
        
        INTEGER, ALLOCATABLE :: RELATED_FACE(:)
        REAL(8), ALLOCATABLE :: PROJECTION_POINT(:,:)
        INTEGER :: I
        
        ALLOCATE(PROJECTION_POINT(3,TYP2_POINT_NUM))
        ALLOCATE(RELATED_FACE(TYP2_POINT_NUM))
        
        PROJECTION_POINT(:,:) = 0.
        RELATED_FACE(:) = 0.
        
        CALL FIND_RELATED_FACE_INTERFACE(TYP2_POINT_NUM, TYP2_POINT, TYP1_POINT_NUM, TYP1_POINT, TYP1_FACE_NUM, TYP1_FACE, RELATED_FACE, PROJECTION_POINT)
        
        DO I=1,TYP2_POINT_NUM
            CALL INTERPOLATION_ONE_FACE(PROJECTION_POINT(:,I), TYP1_POINT(:,TYP1_FACE(1,RELATED_FACE(I))), TYP1_POINT(:,TYP1_FACE(2,RELATED_FACE(I))), TYP1_POINT(:,TYP1_FACE(3,RELATED_FACE(I))), CR_SOURCE(TYP1_FACE(1,RELATED_FACE(I))), CR_SOURCE(TYP1_FACE(2,RELATED_FACE(I))), CR_SOURCE(TYP1_FACE(3,RELATED_FACE(I))), CR_TARGET(I))
        END DO
        
        DEALLOCATE(RELATED_FACE)
        DEALLOCATE(PROJECTION_POINT)
        
    END SUBROUTINE DATA_TRANSFER_WITHOUT_CR
    
    
END MODULE
